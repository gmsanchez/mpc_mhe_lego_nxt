<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CasADi: Qpsol</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://casadi.org"><img src="/api/html/casadi.png" alt="CasADi" height="55px"/></a>&#160;<span>public API<sup style="font-size: 30%">(<a href="../../../internal/index.html">switch to internal</a>)</sup></span> - <a href="https://github.com/casadi/casadi/tree/40d1934d2cb4eb46565debb8477cb04f4a3e2729" id="40d1934d2cb4eb46565debb8477cb04f4a3e2729" >revision 3.0.0</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Function&#160;overview</span></a></li>
      <li><a href="../../da/da4/classcasadi_1_1Function.html"><span>Function</span></a></li>
      <li><a href="../../usergroup0.html"><span>Expression&#160;graphs</span></a></li>
      <li><a href="../../usergroup1.html"><span>Solvers</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Qpsol</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9fd0da0e60e185ead6ea61c72aca46c9"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT Function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga9fd0da0e60e185ead6ea61c72aca46c9">casadi::qpsol</a> (const std::string &amp;name, const std::string &amp;solver, const SpDict &amp;qp, const Dict &amp;opts=Dict())</td></tr>
<tr class="separator:ga9fd0da0e60e185ead6ea61c72aca46c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23baf2e59ef068abbd4e332df1e5da0f"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT Function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga23baf2e59ef068abbd4e332df1e5da0f">casadi::qpsol</a> (const std::string &amp;name, const std::string &amp;solver, const SXDict &amp;qp, const Dict &amp;opts=Dict())</td></tr>
<tr class="separator:ga23baf2e59ef068abbd4e332df1e5da0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b314477828b23c90e9bab031b8566a1"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT Function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga7b314477828b23c90e9bab031b8566a1">casadi::qpsol</a> (const std::string &amp;name, const std::string &amp;solver, const MXDict &amp;qp, const Dict &amp;opts=Dict())</td></tr>
<tr class="separator:ga7b314477828b23c90e9bab031b8566a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1b8283e9ec55f7b2ce3dcc95b2f145"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT std::vector<br class="typebreak" />
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga6e1b8283e9ec55f7b2ce3dcc95b2f145">casadi::qpsol_in</a> ()</td></tr>
<tr class="memdesc:ga6e1b8283e9ec55f7b2ce3dcc95b2f145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get input scheme of QP solvers.  <a href="#ga6e1b8283e9ec55f7b2ce3dcc95b2f145">More...</a><br /></td></tr>
<tr class="separator:ga6e1b8283e9ec55f7b2ce3dcc95b2f145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7aa2a000cf84f9ef2b74448272db66"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT std::vector<br class="typebreak" />
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga0f7aa2a000cf84f9ef2b74448272db66">casadi::qpsol_out</a> ()</td></tr>
<tr class="memdesc:ga0f7aa2a000cf84f9ef2b74448272db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get QP solver output scheme of QP solvers.  <a href="#ga0f7aa2a000cf84f9ef2b74448272db66">More...</a><br /></td></tr>
<tr class="separator:ga0f7aa2a000cf84f9ef2b74448272db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48770ec5b8b26e0477c8209a31e60ee1"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga48770ec5b8b26e0477c8209a31e60ee1">casadi::qpsol_in</a> (int ind)</td></tr>
<tr class="memdesc:ga48770ec5b8b26e0477c8209a31e60ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get QP solver input scheme name by index.  <a href="#ga48770ec5b8b26e0477c8209a31e60ee1">More...</a><br /></td></tr>
<tr class="separator:ga48770ec5b8b26e0477c8209a31e60ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a94f5c8d318ff50554d185bd1265591"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga2a94f5c8d318ff50554d185bd1265591">casadi::qpsol_out</a> (int ind)</td></tr>
<tr class="memdesc:ga2a94f5c8d318ff50554d185bd1265591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output scheme name by index.  <a href="#ga2a94f5c8d318ff50554d185bd1265591">More...</a><br /></td></tr>
<tr class="separator:ga2a94f5c8d318ff50554d185bd1265591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818012da1e1e5b58897fd573faf400b3"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga818012da1e1e5b58897fd573faf400b3">casadi::qpsol_n_in</a> ()</td></tr>
<tr class="memdesc:ga818012da1e1e5b58897fd573faf400b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of QP solver inputs.  <a href="#ga818012da1e1e5b58897fd573faf400b3">More...</a><br /></td></tr>
<tr class="separator:ga818012da1e1e5b58897fd573faf400b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd1da9829c609be2eb8d67b8f1b755e"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#gaebd1da9829c609be2eb8d67b8f1b755e">casadi::qpsol_n_out</a> ()</td></tr>
<tr class="memdesc:gaebd1da9829c609be2eb8d67b8f1b755e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of QP solver outputs.  <a href="#gaebd1da9829c609be2eb8d67b8f1b755e">More...</a><br /></td></tr>
<tr class="separator:gaebd1da9829c609be2eb8d67b8f1b755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79794625706a81e184124ea5ca493f15"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga79794625706a81e184124ea5ca493f15">casadi::has_qpsol</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ga79794625706a81e184124ea5ca493f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a particular plugin is available.  <a href="#ga79794625706a81e184124ea5ca493f15">More...</a><br /></td></tr>
<tr class="separator:ga79794625706a81e184124ea5ca493f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f9140e48e375c501d0d347675e466c"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#ga22f9140e48e375c501d0d347675e466c">casadi::load_qpsol</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ga22f9140e48e375c501d0d347675e466c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly load a plugin dynamically.  <a href="#ga22f9140e48e375c501d0d347675e466c">More...</a><br /></td></tr>
<tr class="separator:ga22f9140e48e375c501d0d347675e466c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03e9f5a9d6cc56c4c47152e7f50b6ae"><td class="memItemLeft" align="right" valign="top">CASADI_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d37/group__qpsol.html#gad03e9f5a9d6cc56c4c47152e7f50b6ae">casadi::doc_qpsol</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:gad03e9f5a9d6cc56c4c47152e7f50b6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the documentation string for a plugin.  <a href="#gad03e9f5a9d6cc56c4c47152e7f50b6ae">More...</a><br /></td></tr>
<tr class="separator:gad03e9f5a9d6cc56c4c47152e7f50b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Create a QP solver Solves the following strictly convex problem:</p>
<pre class="fragment">min          1/2 x' H x + g' x
x

subject to
LBA &lt;= A x &lt;= UBA
LBX &lt;= x   &lt;= UBX

with :
H sparse (n x n) positive definite
g dense  (n x 1)

n: number of decision variables (x)
nc: number of constraints (A)</pre><p>If H is not positive-definite, the solver should throw an error.</p>
<h3>General information</h3>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description</th><th>Used in </th></tr>
<tr>
<td>ad_weight</td><td>OT_DOUBLE</td><td>Weighting factor for derivative calculation.When there is an option of either using forward or reverse mode directional derivatives, the condition ad_weight*nf&lt;=(1-ad_weight)*na is used where nf and na are estimates of the number of forward/reverse mode directional derivatives needed. By default, ad_weight is calculated automatically, but this can be overridden by setting this option. In particular, 0 means forcing forward mode and 1 forcing reverse mode. Leave unset for (class specific) heuristics.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>ad_weight_sp</td><td>OT_DOUBLE</td><td>Weighting factor for sparsity pattern calculation calculation.Overrides default behavior. Set to 0 and 1 to force forward and reverse mode respectively. Cf. option "ad_weight".</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>compiler</td><td>OT_STRING</td><td>Just-in-time compiler plugin to be used.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>derivative_of</td><td>OT_FUNCTION</td><td>The function is a derivative of another function. The type of derivative (directional derivative, Jacobian) is inferred from the function name.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>discrete</td><td>OT_BOOLVECTOR</td><td>Indicates which of the variables are discrete, i.e. integer-valued</td><td>casadi::Qpsol </td></tr>
<tr>
<td>gather_stats</td><td>OT_BOOL</td><td>Flag to indicate whether statistics must be gathered</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>input_scheme</td><td>OT_STRINGVECTOR</td><td>Custom input scheme</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>inputs_check</td><td>OT_BOOL</td><td>Throw exceptions when the numerical values of the inputs don't make sense</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jac_penalty</td><td>OT_DOUBLE</td><td>When requested for a number of forward/reverse directions, it may be cheaper to compute first the full jacobian and then multiply with seeds, rather than obtain the requested directions in a straightforward manner. Casadi uses a heuristic to decide which is cheaper. A high value of 'jac_penalty' makes it less likely for the heurstic to chose the full Jacobian strategy. The special value -1 indicates never to use the full Jacobian strategy</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit</td><td>OT_BOOL</td><td>Use just-in-time compiler to speed up the evaluation</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>jit_options</td><td>OT_DICT</td><td>Options to be passed to the jit compiler.</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>monitor</td><td>OT_STRINGVECTOR</td><td>Monitors to be activated</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>output_scheme</td><td>OT_STRINGVECTOR</td><td>Custom output scheme</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>regularity_check</td><td>OT_BOOL</td><td>Throw exceptions when NaN or Inf appears during evaluation</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>user_data</td><td>OT_VOIDPTR</td><td>A user-defined field that can be used to identify the function or pass additional information</td><td>casadi::FunctionInternal </td></tr>
<tr>
<td>verbose</td><td>OT_BOOL</td><td>Verbose evaluation &ndash; for debugging</td><td>casadi::FunctionInternal </td></tr>
</table>
</dd></dl>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption align="bottom">Input scheme: casadi::QpsolInput (QPSOL_NUM_IN = 9) []</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>QPSOL_H</td><td></td><td>The square matrix H: sparse, (n x n). Only the lower triangular part is actually used. The matrix is assumed to be symmetrical. </td></tr>
<tr>
<td>QPSOL_G</td><td></td><td>The vector g: dense, (n x 1) </td></tr>
<tr>
<td>QPSOL_A</td><td></td><td>The matrix A: sparse, (nc x n) - product with x must be dense. </td></tr>
<tr>
<td>QPSOL_LBA</td><td></td><td>dense, (nc x 1) </td></tr>
<tr>
<td>QPSOL_UBA</td><td></td><td>dense, (nc x 1) </td></tr>
<tr>
<td>QPSOL_LBX</td><td></td><td>dense, (n x 1) </td></tr>
<tr>
<td>QPSOL_UBX</td><td></td><td>dense, (n x 1) </td></tr>
<tr>
<td>QPSOL_X0</td><td></td><td>dense, (n x 1) </td></tr>
<tr>
<td>QPSOL_LAM_X0</td><td></td><td>dense </td></tr>
</table>
<p><a class="anchor" id="schemes"></a></p><table class="doxtable">
<caption align="bottom">Output scheme: casadi::QpsolOutput (QPSOL_NUM_OUT = 4) []</caption>
<tr>
<th>Full name</th><th>Short</th><th>Description </th></tr>
<tr>
<td>QPSOL_X</td><td></td><td>The primal solution. </td></tr>
<tr>
<td>QPSOL_COST</td><td></td><td>The optimal cost. </td></tr>
<tr>
<td>QPSOL_LAM_A</td><td></td><td>The dual solution corresponding to linear bounds. </td></tr>
<tr>
<td>QPSOL_LAM_X</td><td></td><td>The dual solution corresponding to simple bounds. </td></tr>
</table>
<h3>List of plugins</h3>
<p>- <a href='#plugin_Qpsol_cplex'>cplex</a> <p>- <a href='#plugin_Qpsol_gurobi'>gurobi</a> <p>- <a href='#plugin_Qpsol_ooqp'>ooqp</a> <p>- <a href='#plugin_Qpsol_qpoases'>qpoases</a> <p>- <a href='#plugin_Qpsol_sqic'>sqic</a> <p>- <a href='#plugin_Qpsol_nlp'>nlp</a> <p>Note: some of the plugins in this list might not be available on your system. Also, there might be extra plugins available to you that are not listed here. You can obtain their documentation with <code>Qpsol.doc("myextraplugin")</code></p>
<hr/>
 <h4>cplex <a class="anchor" id="plugin_Qpsol_cplex"></a></h4>
<p>Interface to Cplex solver for sparse Quadratic Programs</p>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>cplex</td><td>OT_DICT</td><td>Options to be passed to CPLEX </td></tr>
<tr>
<td>dep_check</td><td>OT_INT</td><td>Detect redundant constraints. </td></tr>
<tr>
<td>dump_filename</td><td>OT_STRING</td><td>The filename to dump to. </td></tr>
<tr>
<td>dump_to_file</td><td>OT_BOOL</td><td>Dumps QP to file in CPLEX format. </td></tr>
<tr>
<td>qp_method</td><td>OT_INT</td><td>Determines which CPLEX algorithm to use. </td></tr>
<tr>
<td>tol</td><td>OT_DOUBLE</td><td>Tolerance of solver </td></tr>
<tr>
<td>warm_start</td><td>OT_BOOL</td><td>Use warm start with simplex methods (affects only the simplex methods). </td></tr>
</table>
<hr/>
</dd></dl>
<hr/>
 <h4>gurobi <a class="anchor" id="plugin_Qpsol_gurobi"></a></h4>
<p>Interface to the GUROBI Solver for quadratic programming</p>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>vtype</td><td>OT_STRINGVECTOR</td><td>Type of variables: [CONTINUOUS|binary|integer|semicont|semiint] </td></tr>
</table>
<hr/>
</dd></dl>
<hr/>
 <h4>ooqp <a class="anchor" id="plugin_Qpsol_ooqp"></a></h4>
<p>Interface to the OOQP Solver for quadratic programming The current implementation assumes that OOQP is configured with the MA27 sparse linear solver.</p>
<p>NOTE: when doing multiple calls to evaluate(), check if you need to reInit();</p>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>artol</td><td>OT_DOUBLE</td><td>tolerance as provided with setArTol to OOQP </td></tr>
<tr>
<td>mutol</td><td>OT_DOUBLE</td><td>tolerance as provided with setMuTol to OOQP </td></tr>
<tr>
<td>print_level</td><td>OT_INT</td><td>Print level. OOQP listens to print_level 0, 10 and 100 </td></tr>
</table>
<hr/>
</dd></dl>
<hr/>
 <h4>qpoases <a class="anchor" id="plugin_Qpsol_qpoases"></a></h4>
<p>Interface to QPOases Solver for quadratic programming</p>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>CPUtime</td><td>OT_DOUBLE</td><td>The maximum allowed CPU time in seconds for the whole initialisation (and the actually required one on output). Disabled if unset. </td></tr>
<tr>
<td>boundRelaxation</td><td>OT_DOUBLE</td><td>Initial relaxation of bounds to start homotopy and initial value for far bounds. </td></tr>
<tr>
<td>boundTolerance</td><td>OT_DOUBLE</td><td>If upper and lower bounds differ less than this tolerance, they are regarded equal, i.e. as equality constraint. </td></tr>
<tr>
<td>enableCholeskyRefactorisation</td><td>OT_INT</td><td>Specifies the frequency of a full re-factorisation of projected Hessian matrix: 0: turns them off, 1: uses them at each iteration etc. </td></tr>
<tr>
<td>enableDriftCorrection</td><td>OT_INT</td><td>Specifies the frequency of drift corrections: 0: turns them off. </td></tr>
<tr>
<td>enableEqualities</td><td>OT_BOOL</td><td>Specifies whether equalities should be treated as always active (True) or not (False) </td></tr>
<tr>
<td>enableFarBounds</td><td>OT_BOOL</td><td>Enables the use of far bounds. </td></tr>
<tr>
<td>enableFlippingBounds</td><td>OT_BOOL</td><td>Enables the use of flipping bounds. </td></tr>
<tr>
<td>enableFullLITests</td><td>OT_BOOL</td><td>Enables condition-hardened (but more expensive) LI test. </td></tr>
<tr>
<td>enableNZCTests</td><td>OT_BOOL</td><td>Enables nonzero curvature tests. </td></tr>
<tr>
<td>enableRamping</td><td>OT_BOOL</td><td>Enables ramping. </td></tr>
<tr>
<td>enableRegularisation</td><td>OT_BOOL</td><td>Enables automatic Hessian regularisation. </td></tr>
<tr>
<td>epsDen</td><td>OT_DOUBLE</td><td>Denominator tolerance for ratio tests. </td></tr>
<tr>
<td>epsFlipping</td><td>OT_DOUBLE</td><td>Tolerance of squared Cholesky diagonal factor which triggers flipping bound. </td></tr>
<tr>
<td>epsIterRef</td><td>OT_DOUBLE</td><td>Early termination tolerance for iterative refinement. </td></tr>
<tr>
<td>epsLITests</td><td>OT_DOUBLE</td><td>Tolerance for linear independence tests. </td></tr>
<tr>
<td>epsNZCTests</td><td>OT_DOUBLE</td><td>Tolerance for nonzero curvature tests. </td></tr>
<tr>
<td>epsNum</td><td>OT_DOUBLE</td><td>Numerator tolerance for ratio tests. </td></tr>
<tr>
<td>epsRegularisation</td><td>OT_DOUBLE</td><td>Scaling factor of identity matrix used for Hessian regularisation. </td></tr>
<tr>
<td>finalRamping</td><td>OT_DOUBLE</td><td>Final value for ramping strategy. </td></tr>
<tr>
<td>growFarBounds</td><td>OT_DOUBLE</td><td>Factor to grow far bounds. </td></tr>
<tr>
<td>initialFarBounds</td><td>OT_DOUBLE</td><td>Initial size for far bounds. </td></tr>
<tr>
<td>initialRamping</td><td>OT_DOUBLE</td><td>Start value for ramping strategy. </td></tr>
<tr>
<td>initialStatusBounds</td><td>OT_STRING</td><td>Initial status of bounds at first iteration. </td></tr>
<tr>
<td>maxDualJump</td><td>OT_DOUBLE</td><td>Maximum allowed jump in dual variables in linear independence tests. </td></tr>
<tr>
<td>maxPrimalJump</td><td>OT_DOUBLE</td><td>Maximum allowed jump in primal variables in nonzero curvature tests. </td></tr>
<tr>
<td>nWSR</td><td>OT_INT</td><td>The maximum number of working set recalculations to be performed during the initial homotopy. Default is 5(nx + nc) </td></tr>
<tr>
<td>numRefinementSteps</td><td>OT_INT</td><td>Maximum number of iterative refinement steps. </td></tr>
<tr>
<td>numRegularisationSteps</td><td>OT_INT</td><td>Maximum number of successive regularisation steps. </td></tr>
<tr>
<td>printLevel</td><td>OT_STRING</td><td>Defines the amount of text output during QP solution, see Section 5.7 </td></tr>
<tr>
<td>sparse</td><td>OT_BOOL</td><td>Formulate the QP using sparse matrices. Default: false </td></tr>
<tr>
<td>terminationTolerance</td><td>OT_DOUBLE</td><td>Relative termination tolerance to stop homotopy. </td></tr>
</table>
<hr/>
</dd></dl>
<hr/>
 <h4>sqic <a class="anchor" id="plugin_Qpsol_sqic"></a></h4>
<p>Interface to the SQIC solver for quadratic programming </p><hr/>
<hr/>
 <h4>nlp <a class="anchor" id="plugin_Qpsol_nlp"></a></h4>
<p><a class="el" href="../../dd/de8/classcasadi_1_1Solve.html" title="An MX atomic for linear solver solution: x = r * A^-1 or x = r * A^-T. ">Solve</a> QPs using an Nlpsol</p>
<p><br />
</p><dl class="section user"><dt></dt><dd><a class="anchor" id="options"></a><table class="doxtable">
<caption align="bottom">List of available options</caption>
<tr>
<th>Id</th><th>Type</th><th>Description </th></tr>
<tr>
<td>nlpsol</td><td>OT_STRING</td><td>Name of solver. </td></tr>
<tr>
<td>nlpsol_options</td><td>OT_DICT</td><td>Options to be passed to solver. </td></tr>
</table>
<hr/>
</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Joel Andersson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2011-2015 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad03e9f5a9d6cc56c4c47152e7f50b6ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT std::string casadi::doc_qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga79794625706a81e184124ea5ca493f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT bool casadi::has_qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22f9140e48e375c501d0d347675e466c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT void casadi::load_qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fd0da0e60e185ead6ea61c72aca46c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT Function casadi::qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpDict &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dict &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code>Dict()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga23baf2e59ef068abbd4e332df1e5da0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT Function casadi::qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SXDict &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dict &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code>Dict()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7b314477828b23c90e9bab031b8566a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT Function casadi::qpsol </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MXDict &amp;&#160;</td>
          <td class="paramname"><em>qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Dict &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code>Dict()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6e1b8283e9ec55f7b2ce3dcc95b2f145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT std::vector&lt;std::string&gt; casadi::qpsol_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga48770ec5b8b26e0477c8209a31e60ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT std::string casadi::qpsol_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga818012da1e1e5b58897fd573faf400b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT int casadi::qpsol_n_in </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaebd1da9829c609be2eb8d67b8f1b755e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT int casadi::qpsol_n_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0f7aa2a000cf84f9ef2b74448272db66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT std::vector&lt;std::string&gt; casadi::qpsol_out </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a94f5c8d318ff50554d185bd1265591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CASADI_EXPORT std::string casadi::qpsol_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr class="footer"/>
Release pointers: <a href="https://github.com/casadi/casadi/tree/40d1934d2cb4eb46565debb8477cb04f4a3e2729/docs/examples/python">extensive python examples</a>, <a href="../../../../tutorials">tutorials</a>, Users Guide (<a href="../../../../users_guide/casadi-users_guide.pdf">pdf</a> | <a href="../../../../users_guide/html">html</a> )
<address class="footer"><small>
Generated for CasADi by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.8</small></address>
<br/>
Official releases: <a href="/3.0.0-rc1">3.0.0-rc1</a> <a href="/2.4.2">2.4.2</a> <a href="/2.3.0">2.3.0</a> <a href="/2.2.0">2.2.0</a> <a href="/2.1.1">2.1.1</a> <a href="/2.0.0">2.0.0</a> <a href="/1.9.0">1.9.0</a> <a href="/1.8.0">1.8.0</a> <a href="/1.7.1">1.7.1</a> <a href="/1.7.0">1.7.0</a> <a href="/1.6.1">1.6.1</a> <a href="/1.6.0">1.6.0</a> <a href="/1.5.0">1.5.0</a> <a href="/1.4.0">1.4.0</a> <a href="/1.3.0">1.3.0</a>
<b
<a href="/">bleeding edge</a>
</body>
</html>

# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_casadi', [dirname(__file__)])
        except ImportError:
            import _casadi
            return _casadi
        if fp is not None:
            try:
                _mod = imp.load_module('_casadi', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _casadi = swig_import_helper()
    del swig_import_helper
else:
    import _casadi
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import contextlib

class _copyableObject(_object):
  def __copy__(self):
    return self.__class__(self)

  def __deepcopy__(self,dummy=None):
    return self.__class__(self)

_object = _copyableObject

_swig_repr_default = _swig_repr
def _swig_repr(self):
  if hasattr(self,'getRepresentation'):
    return self.getRepresentation()
  else:
    return _swig_repr_default(self)


class SwigPyIterator(_object):
    """Proxy of C++ swig::SwigPyIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_SwigPyIterator
    def value(self, *args):
        """value(SwigPyIterator self) -> PyObject *"""
        return _casadi.SwigPyIterator_value(self, *args)

    def incr(self, *args):
        """incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _casadi.SwigPyIterator_incr(self, *args)

    def decr(self, *args):
        """decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _casadi.SwigPyIterator_decr(self, *args)

    def distance(self, *args):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _casadi.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
        """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi.SwigPyIterator_equal(self, *args)

    def copy(self, *args):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _casadi.SwigPyIterator_copy(self, *args)

    def next(self, *args):
        """next(SwigPyIterator self) -> PyObject *"""
        return _casadi.SwigPyIterator_next(self, *args)

    def __next__(self, *args):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _casadi.SwigPyIterator___next__(self, *args)

    def previous(self, *args):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _casadi.SwigPyIterator_previous(self, *args)

    def advance(self, *args):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _casadi.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _casadi.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _casadi.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _casadi.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

if __name__ != "casadi.casadi":
  raise Exception("""
            CasADi is not running from its package context.

            You probably specified the wrong casadi directory.

            When setting PYTHONPATH or sys.path.append,
            take care not to add a trailing '/casadi'.

        """)
import _casadi

try:
  from numpy import pi, inf
except:
  pass

arcsin = lambda x: _casadi.asin(x)
arccos = lambda x: _casadi.acos(x)
arctan = lambda x: _casadi.atan(x)
arctan2 = lambda x,y: _casadi.atan2(x, y)
arctanh = lambda x: _casadi.atanh(x)
arcsinh = lambda x: _casadi.asinh(x)
arccosh = lambda x: _casadi.acosh(x)

def veccat(*args): return _veccat(args)
def vertcat(*args): return _vertcat(args)
def horzcat(*args): return _horzcat(args)
def diagcat(*args): return _diagcat(args)

class NZproxy:
  def __init__(self,matrix):
    self.matrix = matrix

  def __getitem__(self,s):
    return self.matrix.get_nz(False, s)

  def __setitem__(self,s,val):
    return self.matrix.set_nz(val, False, s)

  def __len__(self):
    return self.matrix.nnz()

class PrintSharedObject(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSharedObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSharedObject, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintSharedObject self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintSharedObject___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSharedObject self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintSharedObject_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::SharedObject)> self) -> PrintSharedObject
        __init__(casadi::PrintableObject<(casadi::SharedObject)> self, PrintSharedObject other) -> PrintSharedObject
        """
        this = _casadi.new_PrintSharedObject(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintSharedObject
PrintSharedObject_swigregister = _casadi.PrintSharedObject_swigregister
PrintSharedObject_swigregister(PrintSharedObject)

class PrintSlice(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSlice, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSlice, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintSlice self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintSlice___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSlice self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintSlice_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::Slice)> self) -> PrintSlice
        __init__(casadi::PrintableObject<(casadi::Slice)> self, PrintSlice other) -> PrintSlice
        """
        this = _casadi.new_PrintSlice(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintSlice
PrintSlice_swigregister = _casadi.PrintSlice_swigregister
PrintSlice_swigregister(PrintSlice)

class PrintIM(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintIM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintIM, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintIM self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintIM___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintIM self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintIM_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(int)>)> self) -> PrintIM
        __init__(casadi::PrintableObject<(casadi::Matrix<(int)>)> self, PrintIM other) -> PrintIM
        """
        this = _casadi.new_PrintIM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintIM
PrintIM_swigregister = _casadi.PrintIM_swigregister
PrintIM_swigregister(PrintIM)

class PrintDM(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintDM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintDM, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintDM self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintDM___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintDM self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintDM_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(double)>)> self) -> PrintDM
        __init__(casadi::PrintableObject<(casadi::Matrix<(double)>)> self, PrintDM other) -> PrintDM
        """
        this = _casadi.new_PrintDM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintDM
PrintDM_swigregister = _casadi.PrintDM_swigregister
PrintDM_swigregister(PrintDM)

class PrintNlpBuilder(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintNlpBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintNlpBuilder, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintNlpBuilder self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintNlpBuilder___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintNlpBuilder self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintNlpBuilder_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::NlpBuilder)> self) -> PrintNlpBuilder
        __init__(casadi::PrintableObject<(casadi::NlpBuilder)> self, PrintNlpBuilder other) -> PrintNlpBuilder
        """
        this = _casadi.new_PrintNlpBuilder(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintNlpBuilder
PrintNlpBuilder_swigregister = _casadi.PrintNlpBuilder_swigregister
PrintNlpBuilder_swigregister(PrintNlpBuilder)

class PrintVariable(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintVariable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintVariable, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintVariable self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintVariable___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintVariable self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintVariable_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::Variable)> self) -> PrintVariable
        __init__(casadi::PrintableObject<(casadi::Variable)> self, PrintVariable other) -> PrintVariable
        """
        this = _casadi.new_PrintVariable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintVariable
PrintVariable_swigregister = _casadi.PrintVariable_swigregister
PrintVariable_swigregister(PrintVariable)

class PrintDaeBuilder(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintDaeBuilder, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintDaeBuilder, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintDaeBuilder self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintDaeBuilder___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintDaeBuilder self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintDaeBuilder_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::DaeBuilder)> self) -> PrintDaeBuilder
        __init__(casadi::PrintableObject<(casadi::DaeBuilder)> self, PrintDaeBuilder other) -> PrintDaeBuilder
        """
        this = _casadi.new_PrintDaeBuilder(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintDaeBuilder
PrintDaeBuilder_swigregister = _casadi.PrintDaeBuilder_swigregister
PrintDaeBuilder_swigregister(PrintDaeBuilder)

class SharedObject(PrintSharedObject):
    """
    SharedObject implements a reference counting framework similar for efficient
    and easily-maintained memory management.

    To use the class, both the SharedObject class (the public class), and the
    SharedObjectNode class (the internal class) must be inherited from. It can
    be done in two different files and together with memory management, this
    approach provides a clear distinction of which methods of the class are to
    be considered "public", i.e. methods for public use that can be considered
    to remain over time with small changes, and the internal memory.

    When interfacing a software, which typically includes including some header
    file, this is best done only in the file where the internal class is
    defined, to avoid polluting the global namespace and other side effects.

    The default constructor always means creating a null pointer to an internal
    class only. To allocate an internal class (this works only when the internal
    class isn't abstract), use the constructor with arguments.

    The copy constructor and the assignment operator perform shallow copies
    only, to make a deep copy you must use the clone method explicitly. This
    will give a shared pointer instance.

    In an inheritance hierarchy, you can cast down automatically, e.g. (
    SXFunction is a child class of Function): SXFunction derived(...); Function
    base = derived;

    To cast up, use the shared_cast template function, which works analogously
    to dynamic_cast, static_cast, const_cast etc, e.g.: SXFunction derived(...);
    Function base = derived; SXFunction derived_from_base =
    shared_cast<SXFunction>(base);

    A failed shared_cast will result in a null pointer (cf. dynamic_cast)

    Joel Andersson

    C++ includes: shared_object.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [PrintSharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SharedObject, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SharedObject, name)
    __repr__ = _swig_repr
    def printPtr(self, *args):
        """
        printPtr(SharedObject self)

        [INTERNAL]  Print the
        pointer to the internal class


        """
        return _casadi.SharedObject_printPtr(self, *args)

    def is_null(self, *args):
        """
        is_null(SharedObject self) -> bool

        Is a null pointer?


        """
        return _casadi.SharedObject_is_null(self, *args)

    def __hash__(self, *args):
        """
        __hash__(SharedObject self) -> size_t

        Returns a number that is unique for a given Node. If the Object does not
        point to any node, "0" is returned.


        """
        return _casadi.SharedObject___hash__(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::SharedObject self) -> SharedObject
        __init__(casadi::SharedObject self, SharedObject other) -> SharedObject
        """
        this = _casadi.new_SharedObject(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SharedObject
SharedObject_swigregister = _casadi.SharedObject_swigregister
SharedObject_swigregister(SharedObject)


def complement(*args):
  """
    complement(std::vector< int,std::allocator< int > > const & v, int size) -> std::vector< int,std::allocator< int > >

    Returns the list of all i in [0, size[ not found in supplied list.

    The supplied vector may contain duplicates and may be non-monotonous The
    supplied vector will be checked for bounds The result vector is guaranteed
    to be monotonously increasing


    """
  return _casadi.complement(*args)

def lookupvector(*args):
  """
    lookupvector(std::vector< int,std::allocator< int > > const & v, int size) -> std::vector< int,std::allocator< int > >

    Returns a vector for quickly looking up entries of supplied list.

    lookupvector[i]!=-1 <=> v contains i v[lookupvector[i]] == i <=> v contains
    i

    Duplicates are treated by looking up last occurrence


    """
  return _casadi.lookupvector(*args)
class WeakRef(SharedObject):
    """
    [INTERNAL]  Weak reference type A
    weak reference to a SharedObject.

    Joel Andersson

    C++ includes: weak_ref.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeakRef, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeakRef, name)
    __repr__ = _swig_repr
    def shared(self, *args):
        """
        shared(WeakRef self) -> SharedObject

        [INTERNAL]  Get a shared
        (owning) reference.


        """
        return _casadi.WeakRef_shared(self, *args)

    def alive(self, *args):
        """
        alive(WeakRef self) -> bool

        [INTERNAL]  Check if alive.


        """
        return _casadi.WeakRef_alive(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::WeakRef self, int dummy=0) -> WeakRef
        __init__(casadi::WeakRef self, SharedObject shared) -> WeakRef
        __init__(casadi::WeakRef self, WeakRef other) -> WeakRef

        >  WeakRef(int dummy=0)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Default constructor.

        >  WeakRef(SharedObject shared)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Construct from a shared object (also implicit type conversion)


        """
        this = _casadi.new_WeakRef(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_WeakRef
WeakRef_swigregister = _casadi.WeakRef_swigregister
WeakRef_swigregister(WeakRef)

SWIG_IND1 = _casadi.SWIG_IND1
class GenericType(_object):
    """
    Generic data type, can hold different types such as bool, int, string etc.

    Joel Andersson

    C++ includes: generic_type.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericType, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::GenericType self) -> GenericType
        __init__(casadi::GenericType self, GenericType other) -> GenericType
        """
        this = _casadi.new_GenericType(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenericType
GenericType_swigregister = _casadi.GenericType_swigregister
GenericType_swigregister(GenericType)

OP_ASSIGN = _casadi.OP_ASSIGN
OP_ADD = _casadi.OP_ADD
OP_SUB = _casadi.OP_SUB
OP_MUL = _casadi.OP_MUL
OP_DIV = _casadi.OP_DIV
OP_NEG = _casadi.OP_NEG
OP_EXP = _casadi.OP_EXP
OP_LOG = _casadi.OP_LOG
OP_POW = _casadi.OP_POW
OP_CONSTPOW = _casadi.OP_CONSTPOW
OP_SQRT = _casadi.OP_SQRT
OP_SQ = _casadi.OP_SQ
OP_TWICE = _casadi.OP_TWICE
OP_SIN = _casadi.OP_SIN
OP_COS = _casadi.OP_COS
OP_TAN = _casadi.OP_TAN
OP_ASIN = _casadi.OP_ASIN
OP_ACOS = _casadi.OP_ACOS
OP_ATAN = _casadi.OP_ATAN
OP_LT = _casadi.OP_LT
OP_LE = _casadi.OP_LE
OP_EQ = _casadi.OP_EQ
OP_NE = _casadi.OP_NE
OP_NOT = _casadi.OP_NOT
OP_AND = _casadi.OP_AND
OP_OR = _casadi.OP_OR
OP_FLOOR = _casadi.OP_FLOOR
OP_CEIL = _casadi.OP_CEIL
OP_FMOD = _casadi.OP_FMOD
OP_FABS = _casadi.OP_FABS
OP_SIGN = _casadi.OP_SIGN
OP_COPYSIGN = _casadi.OP_COPYSIGN
OP_IF_ELSE_ZERO = _casadi.OP_IF_ELSE_ZERO
OP_ERF = _casadi.OP_ERF
OP_FMIN = _casadi.OP_FMIN
OP_FMAX = _casadi.OP_FMAX
OP_INV = _casadi.OP_INV
OP_SINH = _casadi.OP_SINH
OP_COSH = _casadi.OP_COSH
OP_TANH = _casadi.OP_TANH
OP_ASINH = _casadi.OP_ASINH
OP_ACOSH = _casadi.OP_ACOSH
OP_ATANH = _casadi.OP_ATANH
OP_ATAN2 = _casadi.OP_ATAN2
OP_CONST = _casadi.OP_CONST
OP_INPUT = _casadi.OP_INPUT
OP_OUTPUT = _casadi.OP_OUTPUT
OP_PARAMETER = _casadi.OP_PARAMETER
OP_CALL = _casadi.OP_CALL
OP_FIND = _casadi.OP_FIND
OP_MAP = _casadi.OP_MAP
OP_MTIMES = _casadi.OP_MTIMES
OP_SOLVE = _casadi.OP_SOLVE
OP_TRANSPOSE = _casadi.OP_TRANSPOSE
OP_DETERMINANT = _casadi.OP_DETERMINANT
OP_INVERSE = _casadi.OP_INVERSE
OP_DOT = _casadi.OP_DOT
OP_BILIN = _casadi.OP_BILIN
OP_RANK1 = _casadi.OP_RANK1
OP_HORZCAT = _casadi.OP_HORZCAT
OP_VERTCAT = _casadi.OP_VERTCAT
OP_DIAGCAT = _casadi.OP_DIAGCAT
OP_HORZSPLIT = _casadi.OP_HORZSPLIT
OP_VERTSPLIT = _casadi.OP_VERTSPLIT
OP_DIAGSPLIT = _casadi.OP_DIAGSPLIT
OP_RESHAPE = _casadi.OP_RESHAPE
OP_SUBREF = _casadi.OP_SUBREF
OP_SUBASSIGN = _casadi.OP_SUBASSIGN
OP_GETNONZEROS = _casadi.OP_GETNONZEROS
OP_ADDNONZEROS = _casadi.OP_ADDNONZEROS
OP_SETNONZEROS = _casadi.OP_SETNONZEROS
OP_PROJECT = _casadi.OP_PROJECT
OP_ASSERTION = _casadi.OP_ASSERTION
OP_MONITOR = _casadi.OP_MONITOR
OP_NORM2 = _casadi.OP_NORM2
OP_NORM1 = _casadi.OP_NORM1
OP_NORMINF = _casadi.OP_NORMINF
OP_NORMF = _casadi.OP_NORMF
OP_HORZREPMAT = _casadi.OP_HORZREPMAT
OP_HORZREPSUM = _casadi.OP_HORZREPSUM
OP_ERFINV = _casadi.OP_ERFINV
OP_PRINTME = _casadi.OP_PRINTME
OP_LIFT = _casadi.OP_LIFT
class SparsityInterfaceCommon(_object):
    """Proxy of C++ casadi::SparsityInterfaceCommon class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparsityInterfaceCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SparsityInterfaceCommon, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterfaceCommon self) -> SparsityInterfaceCommon
        __init__(casadi::SparsityInterfaceCommon self, SparsityInterfaceCommon other) -> SparsityInterfaceCommon
        """
        this = _casadi.new_SparsityInterfaceCommon(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SparsityInterfaceCommon
SparsityInterfaceCommon_swigregister = _casadi.SparsityInterfaceCommon_swigregister
SparsityInterfaceCommon_swigregister(SparsityInterfaceCommon)

class SpSparsity(SparsityInterfaceCommon):
    """
    Sparsity interface class.

    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpSparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpSparsity, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterface<(casadi::Sparsity)> self) -> SpSparsity
        __init__(casadi::SparsityInterface<(casadi::Sparsity)> self, SpSparsity other) -> SpSparsity
        """
        this = _casadi.new_SpSparsity(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SpSparsity
SpSparsity_swigregister = _casadi.SpSparsity_swigregister
SpSparsity_swigregister(SpSparsity)

class Sparsity(SharedObject,SpSparsity):
    """
    General sparsity class.

    The storage format is a compressed column storage (CCS) format.  In this
    format, the structural non-zero elements are stored in column-major order,
    starting from the upper left corner of the matrix and ending in the lower
    right corner.

    In addition to the dimension ( size1(), size2()), (i.e. the number of rows
    and the number of columns respectively), there are also two vectors of
    integers:

    "colind" [length size2()+1], which contains the index to the first non-
    zero element on or after the corresponding column. All the non-zero elements
    of a particular i are thus the elements with index el that fulfills:
    colind[i] <= el < colind[i+1].

    "row" [same length as the number of non-zero elements, nnz()] The rows for
    each of the structural non-zeros.

    Note that with this format, it is cheap to loop over all the non-zero
    elements of a particular column, at constant time per element, but expensive
    to jump to access a location (i, j).

    If the matrix is dense, i.e. length(row) == size1()*size2(), the format
    reduces to standard dense column major format, which allows access to an
    arbitrary element in constant time.

    Since the object is reference counted (it inherits from SharedObject),
    several matrices are allowed to share the same sparsity pattern.

    The implementations of some methods of this class has been taken from the
    CSparse package and modified to use C++ standard library and CasADi data
    structures.

    See:   Matrix

    Joel Andersson

    C++ includes: sparsity.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject,SpSparsity]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sparsity, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject,SpSparsity]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Sparsity, name)
    __repr__ = _swig_repr
    def scalar(*args):
        """
        scalar(bool dense_scalar=True) -> Sparsity

        Create a scalar sparsity pattern.


        """
        return _casadi.Sparsity_scalar(*args)

    if _newclass:scalar = staticmethod(scalar)
    __swig_getmethods__["scalar"] = lambda x: scalar
    def dense(*args):
        """
        dense(int nrow, int ncol=1) -> Sparsity
        dense(std::pair< int,int > const & rc) -> Sparsity

        Create a dense rectangular sparsity pattern.


        """
        return _casadi.Sparsity_dense(*args)

    if _newclass:dense = staticmethod(dense)
    __swig_getmethods__["dense"] = lambda x: dense
    def unit(*args):
        """
        unit(int n, int el) -> Sparsity

        Create the sparsity pattern for a unit vector of length n and a nonzero on
        position el.


        """
        return _casadi.Sparsity_unit(*args)

    if _newclass:unit = staticmethod(unit)
    __swig_getmethods__["unit"] = lambda x: unit
    def upper(*args):
        """upper(int n) -> Sparsity"""
        return _casadi.Sparsity_upper(*args)

    if _newclass:upper = staticmethod(upper)
    __swig_getmethods__["upper"] = lambda x: upper
    def lower(*args):
        """lower(int n) -> Sparsity"""
        return _casadi.Sparsity_lower(*args)

    if _newclass:lower = staticmethod(lower)
    __swig_getmethods__["lower"] = lambda x: lower
    def diag(*args):
        """
        diag(int nrow) -> Sparsity
        diag(int nrow, int ncol) -> Sparsity
        diag(std::pair< int,int > const & rc) -> Sparsity

        Create diagonal sparsity pattern.


        """
        return _casadi.Sparsity_diag(*args)

    if _newclass:diag = staticmethod(diag)
    __swig_getmethods__["diag"] = lambda x: diag
    def band(*args):
        """band(int n, int p) -> Sparsity"""
        return _casadi.Sparsity_band(*args)

    if _newclass:band = staticmethod(band)
    __swig_getmethods__["band"] = lambda x: band
    def banded(*args):
        """banded(int n, int p) -> Sparsity"""
        return _casadi.Sparsity_banded(*args)

    if _newclass:banded = staticmethod(banded)
    __swig_getmethods__["banded"] = lambda x: banded
    def rowcol(*args):
        """
        rowcol(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            int nrow, int ncol) -> Sparsity
        """
        return _casadi.Sparsity_rowcol(*args)

    if _newclass:rowcol = staticmethod(rowcol)
    __swig_getmethods__["rowcol"] = lambda x: rowcol
    def triplet(*args):
        """
        triplet(int nrow, int ncol, std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            std::vector< int,std::allocator< int > > & mapping, 
            bool invert_mapping=False) -> Sparsity
        triplet(int nrow, int ncol, std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col) -> Sparsity
        """
        return _casadi.Sparsity_triplet(*args)

    if _newclass:triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet
    def compressed(*args):
        """
        compressed(std::vector< int,std::allocator< int > > const & v) -> Sparsity

        Create from a single vector containing the pattern in compressed column
        storage format: The format: The first two entries are the number of rows
        (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
        (colind). Note that the last element, colind[ncol], gives the number of
        nonzeros The last colind[ncol] entries are the row indices


        """
        return _casadi.Sparsity_compressed(*args)

    if _newclass:compressed = staticmethod(compressed)
    __swig_getmethods__["compressed"] = lambda x: compressed
    def sanity_check(self, *args):
        """
        sanity_check(Sparsity self, bool complete=False)

        Check if the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi.Sparsity_sanity_check(self, *args)

    def get_diag(self, *args):
        """
        get_diag(Sparsity self) -> Sparsity

        Get the diagonal of the matrix/create a diagonal matrix (mapping will
        contain the nonzero mapping) When the input is square, the diagonal elements
        are returned. If the input is vector-like, a diagonal matrix is constructed
        with it.


        """
        return _casadi.Sparsity_get_diag(self, *args)

    def compress(self, *args):
        """
        compress(Sparsity self) -> std::vector< int,std::allocator< int > >

        Compress a sparsity pattern.


        """
        return _casadi.Sparsity_compress(self, *args)

    def is_equal(self, *args):
        """
        is_equal(Sparsity self, Sparsity y) -> bool
        is_equal(Sparsity self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & colind, std::vector< int,std::allocator< int > > const & row) -> bool
        """
        return _casadi.Sparsity_is_equal(self, *args)

    def __eq__(self, *args):
        """__eq__(Sparsity self, Sparsity y) -> bool"""
        return _casadi.Sparsity___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Sparsity self, Sparsity y) -> bool"""
        return _casadi.Sparsity___ne__(self, *args)

    def size1(self, *args):
        """
        size1(Sparsity self) -> int

        Get the number of rows.


        """
        return _casadi.Sparsity_size1(self, *args)

    def size2(self, *args):
        """
        size2(Sparsity self) -> int

        Get the number of columns.


        """
        return _casadi.Sparsity_size2(self, *args)

    def numel(self, *args):
        """
        numel(Sparsity self) -> int

        The total number of elements, including structural zeros, i.e.
        size2()*size1()

        See:   nnz()


        """
        return _casadi.Sparsity_numel(self, *args)

    def is_empty(self, *args):
        """
        is_empty(Sparsity self, bool both=False) -> bool

        Check if the sparsity is empty.

        A sparsity is considered empty if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi.Sparsity_is_empty(self, *args)

    def nnz(self, *args):
        """
        nnz(Sparsity self) -> int

        Get the number of (structural) non-zeros.

        See:   numel()


        """
        return _casadi.Sparsity_nnz(self, *args)

    def nnz_upper(self, *args):
        """
        nnz_upper(Sparsity self, bool strictly=False) -> int

        Number of non-zeros in the upper triangular half, i.e. the number of
        elements (i, j) with j>=i.


        """
        return _casadi.Sparsity_nnz_upper(self, *args)

    def nnz_lower(self, *args):
        """
        nnz_lower(Sparsity self, bool strictly=False) -> int

        Number of non-zeros in the lower triangular half, i.e. the number of
        elements (i, j) with j<=i.


        """
        return _casadi.Sparsity_nnz_lower(self, *args)

    def nnz_diag(self, *args):
        """
        nnz_diag(Sparsity self) -> int

        Number of non-zeros on the diagonal, i.e. the number of elements (i, j) with
        j==i.


        """
        return _casadi.Sparsity_nnz_diag(self, *args)

    def bw_upper(self, *args):
        """
        bw_upper(Sparsity self) -> int

        Upper half-bandwidth.


        """
        return _casadi.Sparsity_bw_upper(self, *args)

    def bw_lower(self, *args):
        """
        bw_lower(Sparsity self) -> int

        Lower half-bandwidth.


        """
        return _casadi.Sparsity_bw_lower(self, *args)

    def size(self, *args):
        """
        size(Sparsity self) -> std::pair< int,int >
        size(Sparsity self, int axis) -> int

        >  (int,int) Sparsity.size() const 
        ------------------------------------------------------------------------

        Get the shape.

        >  int Sparsity.size(int axis) const 
        ------------------------------------------------------------------------

        Get the size along a particular dimensions.


        """
        return _casadi.Sparsity_size(self, *args)

    def colind(self, *args):
        """
        colind(Sparsity self) -> std::vector< int,std::allocator< int > >
        colind(Sparsity self, int cc) -> int

        Get a reference to the colindex of column cc (see class description)


        """
        return _casadi.Sparsity_colind(self, *args)

    def row(self, *args):
        """
        row(Sparsity self) -> std::vector< int,std::allocator< int > >
        row(Sparsity self, int el) -> int

        Get the row of a non-zero element.


        """
        return _casadi.Sparsity_row(self, *args)

    def get_col(self, *args):
        """
        get_col(Sparsity self) -> std::vector< int,std::allocator< int > >

        Get the column for each non-zero entry Together with the row-vector, this
        vector gives the sparsity of the matrix in sparse triplet format, i.e. the
        column and row for each non-zero elements.


        """
        return _casadi.Sparsity_get_col(self, *args)

    def resize(self, *args):
        """
        resize(Sparsity self, int nrow, int ncol)

        Resize.


        """
        return _casadi.Sparsity_resize(self, *args)

    def add_nz(self, *args):
        """
        add_nz(Sparsity self, int rr, int cc) -> int

        Get the index of a non-zero element Add the element if it does not exist and
        copy object if it's not unique.


        """
        return _casadi.Sparsity_add_nz(self, *args)

    def has_nz(self, *args):
        """
        has_nz(Sparsity self, int rr, int cc) -> bool

        Returns true if the pattern has a non-zero at location rr, cc.


        """
        return _casadi.Sparsity_has_nz(self, *args)

    def get_nz(self, *args):
        """
        get_nz(Sparsity self, int rr, int cc) -> int
        get_nz(Sparsity self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc) -> std::vector< int,std::allocator< int > >
        get_nz(Sparsity self, std::vector< int,std::allocator< int > > & INOUT)

        >  int Sparsity.get_nz(int rr, int cc) const 
        ------------------------------------------------------------------------

        Get the index of an existing non-zero element return -1 if the element does
        not exist.

        >  [int] Sparsity.get_nz([int ] rr, [int ] cc) const 
        ------------------------------------------------------------------------

        Get a set of non-zero element return -1 if the element does not exist.

        >  void Sparsity.get_nz([int ] INOUT) const 
        ------------------------------------------------------------------------

        Get the nonzero index for a set of elements The index vector is used both
        for input and outputs and must be sorted by increasing nonzero index, i.e.
        column-wise. Elements not found in the sparsity pattern are set to -1.


        """
        return _casadi.Sparsity_get_nz(self, *args)

    def get_lower(self, *args):
        """
        get_lower(Sparsity self) -> std::vector< int,std::allocator< int > >

        Get nonzeros in lower triangular part.


        """
        return _casadi.Sparsity_get_lower(self, *args)

    def get_upper(self, *args):
        """
        get_upper(Sparsity self) -> std::vector< int,std::allocator< int > >

        Get nonzeros in upper triangular part.


        """
        return _casadi.Sparsity_get_upper(self, *args)

    def get_ccs(self, *args):
        """
        get_ccs(Sparsity self)

        Get the sparsity in compressed column storage (CCS) format.


        """
        return _casadi.Sparsity_get_ccs(self, *args)

    def get_crs(self, *args):
        """
        get_crs(Sparsity self)

        Get the sparsity in compressed row storage (CRS) format.


        """
        return _casadi.Sparsity_get_crs(self, *args)

    def get_triplet(self, *args):
        """
        get_triplet(Sparsity self)

        Get the sparsity in sparse triplet format.


        """
        return _casadi.Sparsity_get_triplet(self, *args)

    def sub(self, *args):
        """
        sub(Sparsity self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False) -> Sparsity
        sub(Sparsity self, std::vector< int,std::allocator< int > > const & rr, Sparsity sp, bool ind1=False) -> Sparsity

        >  Sparsity Sparsity.sub([int ] rr, [int ] cc,[int ] output_mapping, bool ind1=false) const 
        ------------------------------------------------------------------------

        Get a submatrix.

        Returns the sparsity of the submatrix, with a mapping such that submatrix[k]
        = originalmatrix[mapping[k]]

        >  Sparsity Sparsity.sub([int ] rr, Sparsity sp,[int ] output_mapping, bool ind1=false) const 
        ------------------------------------------------------------------------

        Get a set of elements.

        Returns the sparsity of the corresponding elements, with a mapping such that
        submatrix[k] = originalmatrix[mapping[k]]


        """
        return _casadi.Sparsity_sub(self, *args)

    def transpose(self, *args):
        """
        transpose(Sparsity self, std::vector< int,std::allocator< int > > & mapping, bool invert_mapping=False) -> Sparsity

        Transpose the matrix and get the reordering of the non-zero entries.

        Parameters:
        -----------

        mapping:  the non-zeros of the original matrix for each non-zero of the new
        matrix


        """
        return _casadi.Sparsity_transpose(self, *args)

    def is_transpose(self, *args):
        """
        is_transpose(Sparsity self, Sparsity y) -> bool

        Check if the sparsity is the transpose of another.


        """
        return _casadi.Sparsity_is_transpose(self, *args)

    def isReshape(self, *args):
        """
        isReshape(Sparsity self, Sparsity y) -> bool

        Check if the sparsity is a reshape of another.


        """
        return _casadi.Sparsity_isReshape(self, *args)

    def combine(self, *args):
        """
        combine(Sparsity self, Sparsity y, bool f0x_is_zero, bool fx0_is_zero) -> Sparsity

        Combine two sparsity patterns Returns the new sparsity pattern as well as a
        mapping with the same length as the number of non-zero elements The mapping
        matrix contains the arguments for each nonzero, the first bit indicates if
        the first argument is nonzero, the second bit indicates if the second
        argument is nonzero (note that none of, one of or both of the arguments can
        be nonzero)


        """
        return _casadi.Sparsity_combine(self, *args)

    def unite(self, *args):
        """
        unite(Sparsity self, Sparsity y) -> Sparsity

        Union of two sparsity patterns.


        """
        return _casadi.Sparsity_unite(self, *args)

    def __add__(self, *args):
        """__add__(Sparsity self, Sparsity b) -> Sparsity"""
        return _casadi.Sparsity___add__(self, *args)

    def intersect(self, *args):
        """
        intersect(Sparsity self, Sparsity y) -> Sparsity

        Intersection of two sparsity patterns Returns the new sparsity pattern as
        well as a mapping with the same length as the number of non-zero elements
        The value is 1 if the non-zero comes from the first (i.e. this) object, 2 if
        it is from the second and 3 (i.e. 1 | 2) if from both.


        """
        return _casadi.Sparsity_intersect(self, *args)

    def __mul__(self, *args):
        """__mul__(Sparsity self, Sparsity b) -> Sparsity"""
        return _casadi.Sparsity___mul__(self, *args)

    def pattern_inverse(self, *args):
        """
        pattern_inverse(Sparsity self) -> Sparsity

        Take the inverse of a sparsity pattern; flip zeros and non-zeros.


        """
        return _casadi.Sparsity_pattern_inverse(self, *args)

    def enlarge(self, *args):
        """
        enlarge(Sparsity self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)

        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.

        For the matrices A to B A(m, n) length(jj)=m , length(ii)=n B(nrow, ncol)

        A=enlarge(m, n, ii, jj) makes sure that

        B[jj, ii] == A


        """
        return _casadi.Sparsity_enlarge(self, *args)

    def enlargeRows(self, *args):
        """
        enlargeRows(Sparsity self, int nrow, std::vector< int,std::allocator< int > > const & rr, bool ind1=False)

        Enlarge the matrix along the first dimension (i.e. insert rows)


        """
        return _casadi.Sparsity_enlargeRows(self, *args)

    def enlargeColumns(self, *args):
        """
        enlargeColumns(Sparsity self, int ncol, std::vector< int,std::allocator< int > > const & cc, bool ind1=False)

        Enlarge the matrix along the second dimension (i.e. insert columns)


        """
        return _casadi.Sparsity_enlargeColumns(self, *args)

    def makeDense(self, *args):
        """
        makeDense(Sparsity self, std::vector< int,std::allocator< int > > & mapping) -> Sparsity

        Make a patten dense.


        """
        return _casadi.Sparsity_makeDense(self, *args)

    def erase(self, *args):
        """
        erase(Sparsity self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False) -> std::vector< int,std::allocator< int > >
        erase(Sparsity self, std::vector< int,std::allocator< int > > const & rr, bool ind1=False) -> std::vector< int,std::allocator< int > >

        >  [int] Sparsity.erase([int ] rr, [int ] cc, bool ind1=false)
        ------------------------------------------------------------------------

        Erase rows and/or columns of a matrix.

        >  [int] Sparsity.erase([int ] rr, bool ind1=false)
        ------------------------------------------------------------------------

        Erase elements of a matrix.


        """
        return _casadi.Sparsity_erase(self, *args)

    def append(self, *args):
        """
        append(Sparsity self, Sparsity sp)

        Append another sparsity patten vertically (NOTE: only efficient if vector)


        """
        return _casadi.Sparsity_append(self, *args)

    def appendColumns(self, *args):
        """
        appendColumns(Sparsity self, Sparsity sp)

        Append another sparsity patten horizontally.


        """
        return _casadi.Sparsity_appendColumns(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(Sparsity self, bool scalar_and_dense=False) -> bool

        Is scalar?


        """
        return _casadi.Sparsity_is_scalar(self, *args)

    def is_dense(self, *args):
        """
        is_dense(Sparsity self) -> bool

        Is dense?


        """
        return _casadi.Sparsity_is_dense(self, *args)

    def is_row(self, *args):
        """
        is_row(Sparsity self) -> bool

        Check if the pattern is a row vector (i.e. size1()==1)


        """
        return _casadi.Sparsity_is_row(self, *args)

    def is_column(self, *args):
        """
        is_column(Sparsity self) -> bool

        Check if the pattern is a column vector (i.e. size2()==1)


        """
        return _casadi.Sparsity_is_column(self, *args)

    def is_vector(self, *args):
        """
        is_vector(Sparsity self) -> bool

        Check if the pattern is a row or column vector.


        """
        return _casadi.Sparsity_is_vector(self, *args)

    def is_diag(self, *args):
        """
        is_diag(Sparsity self) -> bool

        Is diagonal?


        """
        return _casadi.Sparsity_is_diag(self, *args)

    def is_square(self, *args):
        """
        is_square(Sparsity self) -> bool

        Is square?


        """
        return _casadi.Sparsity_is_square(self, *args)

    def is_symmetric(self, *args):
        """
        is_symmetric(Sparsity self) -> bool

        Is symmetric?


        """
        return _casadi.Sparsity_is_symmetric(self, *args)

    def is_triu(self, *args):
        """
        is_triu(Sparsity self) -> bool

        Is upper triangular?


        """
        return _casadi.Sparsity_is_triu(self, *args)

    def is_tril(self, *args):
        """
        is_tril(Sparsity self) -> bool

        Is lower triangular?


        """
        return _casadi.Sparsity_is_tril(self, *args)

    def is_singular(self, *args):
        """
        is_singular(Sparsity self) -> bool

        Check whether the sparsity-pattern indicates structural singularity.


        """
        return _casadi.Sparsity_is_singular(self, *args)

    def rowsSequential(self, *args):
        """
        rowsSequential(Sparsity self, bool strictly=True) -> bool

        Do the rows appear sequentially on each column.

        Parameters:
        -----------

        strictly:  if true, then do not allow multiple entries


        """
        return _casadi.Sparsity_rowsSequential(self, *args)

    def removeDuplicates(self, *args):
        """
        removeDuplicates(Sparsity self, std::vector< int,std::allocator< int > > & mapping)

        Remove duplicate entries.

        The same indices will be removed from the mapping vector, which must have
        the same length as the number of nonzeros


        """
        return _casadi.Sparsity_removeDuplicates(self, *args)

    def etree(self, *args):
        """
        etree(Sparsity self, bool ata=False) -> std::vector< int,std::allocator< int > >

        Calculate the elimination tree See Direct Methods for Sparse Linear Systems
        by Davis (2006). If the parameter ata is false, the algorithm is equivalent
        to MATLAB's etree(A), except that the indices are zero- based. If ata is
        true, the algorithm is equivalent to MATLAB's etree(A, 'col').


        """
        return _casadi.Sparsity_etree(self, *args)

    def dfs(self, *args):
        """
        dfs(Sparsity self, int j, int top, std::vector< int,std::allocator< int > > & xi, std::vector< int,std::allocator< int > > & pstack, 
            std::vector< int,std::allocator< int > > const & pinv, 
            std::vector< bool,std::allocator< bool > > & marked) -> int

        Depth-first search on the adjacency graph of the sparsity See Direct Methods
        for Sparse Linear Systems by Davis (2006).


        """
        return _casadi.Sparsity_dfs(self, *args)

    def scc(self, *args):
        """
        scc(Sparsity self) -> int

        Find the strongly connected components of the bigraph defined by the
        sparsity pattern of a square matrix.

        See Direct Methods for Sparse Linear Systems by Davis (2006). Returns:
        Number of components

        Offset for each components (length: 1 + number of components)

        Indices for each components, component i has indices index[offset[i]], ...,
        index[offset[i+1]]

        In the case that the matrix is symmetric, the result has a particular
        interpretation: Given a symmetric matrix A and n = A.scc(p, r)

        => A[p, p] will appear block-diagonal with n blocks and with the indices of
        the block boundaries to be found in r.


        """
        return _casadi.Sparsity_scc(self, *args)

    def btf(self, *args):
        """
        btf(Sparsity self, int seed=0) -> int

        Calculate the block triangular form (BTF) See Direct Methods for Sparse
        Linear Systems by Davis (2006).

        The function computes the Dulmage-Mendelsohn decomposition, which allows you
        to reorder the rows and columns of a matrix to bring it into block
        triangular form (BTF).

        It will not consider the distance of off-diagonal elements to the diagonal:
        there is no guarantee you will get a block-diagonal matrix if you supply a
        randomly permuted block-diagonal matrix.

        If your matrix is symmetrical, this method is of limited use; permutation
        can make it non-symmetric.

        See:   scc


        """
        return _casadi.Sparsity_btf(self, *args)

    def find(self, *args):
        """
        find(Sparsity self, bool ind1=False) -> std::vector< int,std::allocator< int > >

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B


        """
        return _casadi.Sparsity_find(self, *args)

    def uni_coloring(self, *args):
        """
        uni_coloring(Sparsity self, Sparsity AT=casadi::Sparsity(), int cutoff=std::numeric_limits< int >::max()) -> Sparsity

        Perform a unidirectional coloring: A greedy distance-2 coloring algorithm
        (Algorithm 3.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN)


        """
        return _casadi.Sparsity_uni_coloring(self, *args)

    def star_coloring(self, *args):
        """
        star_coloring(Sparsity self, int ordering=1, int cutoff=std::numeric_limits< int >::max()) -> Sparsity

        Perform a star coloring of a symmetric matrix: A greedy distance-2 coloring
        algorithm Algorithm 4.1 in What Color Is Your Jacobian? Graph Coloring for
        Computing Derivatives A. H. GEBREMEDHIN, F. MANNE, A. POTHEN SIAM Rev.,
        47(4), 629705 (2006)

        Ordering options: None (0), largest first (1)


        """
        return _casadi.Sparsity_star_coloring(self, *args)

    def star_coloring2(self, *args):
        """
        star_coloring2(Sparsity self, int ordering=1, int cutoff=std::numeric_limits< int >::max()) -> Sparsity

        Perform a star coloring of a symmetric matrix: A new greedy distance-2
        coloring algorithm Algorithm 4.1 in NEW ACYCLIC AND STAR COLORING ALGORITHMS
        WITH APPLICATION TO COMPUTING HESSIANS A. H. GEBREMEDHIN, A. TARAFDAR, F.
        MANNE, A. POTHEN SIAM J. SCI. COMPUT. Vol. 29, No. 3, pp. 10421072 (2007)

        Ordering options: None (0), largest first (1)


        """
        return _casadi.Sparsity_star_coloring2(self, *args)

    def largest_first(self, *args):
        """
        largest_first(Sparsity self) -> std::vector< int,std::allocator< int > >

        Order the columns by decreasing degree.


        """
        return _casadi.Sparsity_largest_first(self, *args)

    def pmult(self, *args):
        """
        pmult(Sparsity self, std::vector< int,std::allocator< int > > const & p, bool permute_rows=True, bool permute_columns=True, 
            bool invert_permutation=False) -> Sparsity

        Permute rows and/or columns Multiply the sparsity with a permutation matrix
        from the left and/or from the right P * A * trans(P), A * trans(P) or A *
        trans(P) with P defined by an index vector containing the row for each col.
        As an alternative, P can be transposed (inverted).


        """
        return _casadi.Sparsity_pmult(self, *args)

    def dim(self, *args):
        """
        dim(Sparsity self) -> std::string

        Get the dimension as a string.


        """
        return _casadi.Sparsity_dim(self, *args)

    def spy(self, *args):
        """
        spy(Sparsity self)

        Print a textual representation of sparsity.


        """
        return _casadi.Sparsity_spy(self, *args)

    def spy_matlab(self, *args):
        """
        spy_matlab(Sparsity self, std::string const & mfile)

        Generate a script for Matlab or Octave which visualizes the sparsity using
        the spy command.


        """
        return _casadi.Sparsity_spy_matlab(self, *args)

    def print_compact(self, *args):
        """
        print_compact(Sparsity self)

        Print a compact description of the sparsity pattern.


        """
        return _casadi.Sparsity_print_compact(self, *args)

    def hash(self, *args):
        """hash(Sparsity self) -> std::size_t"""
        return _casadi.Sparsity_hash(self, *args)

    def test_cast(*args):
        """test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi.Sparsity_test_cast(*args)

    if _newclass:test_cast = staticmethod(test_cast)
    __swig_getmethods__["test_cast"] = lambda x: test_cast
    def __setstate__(self, state):
        if state:
          self.__init__(state["nrow"],state["ncol"],state["colind"],state["row"])
        else:
          self.__init__()

    def __getstate__(self):
        if self.is_null(): return {}
        return {"nrow": self.size1(), "ncol": self.size2(), "colind": numpy.array(self.colind(),dtype=int), "row": numpy.array(self.row(),dtype=int)}

    @property
    def shape(self):
        return (self.size1(),self.size2())

    @property
    def T(self):
        return _casadi.transpose(self)

    def __array__(self,*args,**kwargs):
        return DM.ones(self).full()

    def __init__(self, *args): 
        """
        __init__(casadi::Sparsity self, int dummy=0) -> Sparsity
        __init__(casadi::Sparsity self, int nrow, int ncol) -> Sparsity
        __init__(casadi::Sparsity self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & colind, std::vector< int,std::allocator< int > > const & row) -> Sparsity
        __init__(casadi::Sparsity self, Sparsity other) -> Sparsity

        >  Sparsity(int dummy=0)
        ------------------------------------------------------------------------

        Default constructor.

        >  Sparsity(int nrow, int ncol)
        ------------------------------------------------------------------------

        Pattern with all structural zeros.

        >  Sparsity(int nrow, int ncol, [int ] colind, [int ] row)
        ------------------------------------------------------------------------

        Construct from sparsity pattern vectors given in compressed column storage
        format.


        """
        this = _casadi.new_Sparsity(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_Sparsity
Sparsity_swigregister = _casadi.Sparsity_swigregister
Sparsity_swigregister(Sparsity)

def Sparsity_scalar(*args):
  """
    Sparsity_scalar(bool dense_scalar=True) -> Sparsity

    Create a scalar sparsity pattern.


    """
  return _casadi.Sparsity_scalar(*args)

def Sparsity_dense(*args):
  """
    dense(int nrow, int ncol=1) -> Sparsity
    Sparsity_dense(std::pair< int,int > const & rc) -> Sparsity

    Create a dense rectangular sparsity pattern.


    """
  return _casadi.Sparsity_dense(*args)

def Sparsity_unit(*args):
  """
    Sparsity_unit(int n, int el) -> Sparsity

    Create the sparsity pattern for a unit vector of length n and a nonzero on
    position el.


    """
  return _casadi.Sparsity_unit(*args)

def Sparsity_upper(*args):
  """Sparsity_upper(int n) -> Sparsity"""
  return _casadi.Sparsity_upper(*args)

def Sparsity_lower(*args):
  """Sparsity_lower(int n) -> Sparsity"""
  return _casadi.Sparsity_lower(*args)

def Sparsity_diag(*args):
  """
    diag(int nrow) -> Sparsity
    diag(int nrow, int ncol) -> Sparsity
    Sparsity_diag(std::pair< int,int > const & rc) -> Sparsity

    Create diagonal sparsity pattern.


    """
  return _casadi.Sparsity_diag(*args)

def Sparsity_band(*args):
  """Sparsity_band(int n, int p) -> Sparsity"""
  return _casadi.Sparsity_band(*args)

def Sparsity_banded(*args):
  """Sparsity_banded(int n, int p) -> Sparsity"""
  return _casadi.Sparsity_banded(*args)

def Sparsity_rowcol(*args):
  """
    Sparsity_rowcol(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        int nrow, int ncol) -> Sparsity
    """
  return _casadi.Sparsity_rowcol(*args)

def Sparsity_triplet(*args):
  """
    triplet(int nrow, int ncol, std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        std::vector< int,std::allocator< int > > & mapping, 
        bool invert_mapping=False) -> Sparsity
    Sparsity_triplet(int nrow, int ncol, std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col) -> Sparsity
    """
  return _casadi.Sparsity_triplet(*args)

def Sparsity_compressed(*args):
  """
    Sparsity_compressed(std::vector< int,std::allocator< int > > const & v) -> Sparsity

    Create from a single vector containing the pattern in compressed column
    storage format: The format: The first two entries are the number of rows
    (nrow) and columns (ncol) The next ncol+1 entries are the column offsets
    (colind). Note that the last element, colind[ncol], gives the number of
    nonzeros The last colind[ncol] entries are the row indices


    """
  return _casadi.Sparsity_compressed(*args)

def Sparsity_test_cast(*args):
  """Sparsity_test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
  return _casadi.Sparsity_test_cast(*args)


def hash_combine(*args):
  """
    hash_combine(std::size_t & seed, int const * v, int sz)
    hash_combine(std::size_t & seed, std::vector< int,std::allocator< int > > const & v)

    >  void hash_combine(std.size_t &seed, T v)

    >  void hash_combine(std.size_t &seed, [int ] v)
    ------------------------------------------------------------------------

    Generate a hash value incrementally (function taken from boost)

    >  void hash_combine(std.size_t &seed, const int *v, int sz)
    ------------------------------------------------------------------------

    Generate a hash value incrementally, array.


    """
  return _casadi.hash_combine(*args)

def hash_sparsity(*args):
  """
    hash_sparsity(int nrow, int ncol, std::vector< int,std::allocator< int > > const & colind, std::vector< int,std::allocator< int > > const & row) -> std::size_t
    hash_sparsity(int nrow, int ncol, int const * colind, int const * row) -> std::size_t

    >  std.size_t hash_sparsity(int nrow, int ncol, [int ] colind, [int ] row)
    ------------------------------------------------------------------------

    Hash a sparsity pattern.


    """
  return _casadi.hash_sparsity(*args)
class Slice(PrintSlice):
    """
    Class representing a Slice.

    Note that Python or Octave do not need to use this class. They can just use
    slicing utility from the host language ( M[0:6] in Python, M(1:7) )

    C++ includes: slice.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [PrintSlice]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Slice, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintSlice]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Slice, name)
    __repr__ = _swig_repr
    __swig_getmethods__["start"] = _casadi.Slice_start_get
    if _newclass:start = _swig_property(_casadi.Slice_start_get)
    __swig_getmethods__["stop"] = _casadi.Slice_stop_get
    if _newclass:stop = _swig_property(_casadi.Slice_stop_get)
    __swig_getmethods__["step"] = _casadi.Slice_step_get
    if _newclass:step = _swig_property(_casadi.Slice_step_get)
    def all(self, *args):
        """
        all(Slice self, int len, bool ind1=False) -> std::vector< int,std::allocator< int > >
        all(Slice self, Slice outer, int len) -> std::vector< int,std::allocator< int > >

        >  [int] Slice.all(int len, bool ind1=false) const 
        ------------------------------------------------------------------------

        Get a vector of indices.

        >  [int] Slice.all(Slice outer, int len) const 
        ------------------------------------------------------------------------

        Get a vector of indices (nested slice)


        """
        return _casadi.Slice_all(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(Slice self, int len) -> bool

        Is the slice a scalar.


        """
        return _casadi.Slice_is_scalar(self, *args)

    def scalar(self, *args):
        """
        scalar(Slice self, int len) -> int

        Get scalar (if is_scalar)


        """
        return _casadi.Slice_scalar(self, *args)

    def __eq__(self, *args):
        """__eq__(Slice self, Slice other) -> bool"""
        return _casadi.Slice___eq__(self, *args)

    def __ne__(self, *args):
        """__ne__(Slice self, Slice other) -> bool"""
        return _casadi.Slice___ne__(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::Slice self) -> Slice
        __init__(casadi::Slice self, int i, bool ind1=False) -> Slice
        __init__(casadi::Slice self, int start, int stop, int step=1) -> Slice
        __init__(casadi::Slice self, Slice other) -> Slice

        >  Slice()
        ------------------------------------------------------------------------

        Default constructor - all elements.

        >  Slice(int i, bool ind1=false)
        ------------------------------------------------------------------------

        A single element (explicit to avoid ambiguity with IM overload.

        >  Slice(int start, int stop, int step=1)
        ------------------------------------------------------------------------

        A slice.


        """
        this = _casadi.new_Slice(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_Slice
Slice_swigregister = _casadi.Slice_swigregister
Slice_swigregister(Slice)


def to_slice2(*args):
  """
    to_slice2(std::vector< int,std::allocator< int > > const & v) -> std::pair< casadi::Slice,casadi::Slice >

    Construct nested slices from an index vector (requires is_slice2(v) to be
    true)


    """
  return _casadi.to_slice2(*args)

def is_slice2(*args):
  """
    is_slice2(std::vector< int,std::allocator< int > > const & v) -> bool

    Check if an index vector can be represented more efficiently as two nested
    slices.


    """
  return _casadi.is_slice2(*args)
class SpIM(SparsityInterfaceCommon):
    """
    Sparsity interface class.

    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpIM, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpIM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterface<(casadi::Matrix<(int)>)> self) -> SpIM
        __init__(casadi::SparsityInterface<(casadi::Matrix<(int)>)> self, SpIM other) -> SpIM
        """
        this = _casadi.new_SpIM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SpIM
SpIM_swigregister = _casadi.SpIM_swigregister
SpIM_swigregister(SpIM)

class SpDM(SparsityInterfaceCommon):
    """
    Sparsity interface class.

    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpDM, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpDM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterface<(casadi::Matrix<(double)>)> self) -> SpDM
        __init__(casadi::SparsityInterface<(casadi::Matrix<(double)>)> self, SpDM other) -> SpDM
        """
        this = _casadi.new_SpDM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SpDM
SpDM_swigregister = _casadi.SpDM_swigregister
SpDM_swigregister(SpDM)

class SpSX(SparsityInterfaceCommon):
    """
    Sparsity interface class.

    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpSX, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpSX, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterface<(casadi::Matrix<(casadi::SXElem)>)> self) -> SpSX
        __init__(casadi::SparsityInterface<(casadi::Matrix<(casadi::SXElem)>)> self, SpSX other) -> SpSX
        """
        this = _casadi.new_SpSX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SpSX
SpSX_swigregister = _casadi.SpSX_swigregister
SpSX_swigregister(SpSX)

class SpMX(SparsityInterfaceCommon):
    """
    Sparsity interface class.

    This is a common base class for GenericMatrix (i.e. MX and Matrix<>) and
    Sparsity, introducing a uniform syntax and implementing common functionality
    using the curiously recurring template pattern (CRTP) idiom. Joel Andersson

    C++ includes: sparsity_interface.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SpMX, name, value)
    __swig_getmethods__ = {}
    for _s in [SparsityInterfaceCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SpMX, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SparsityInterface<(casadi::MX)> self) -> SpMX
        __init__(casadi::SparsityInterface<(casadi::MX)> self, SpMX other) -> SpMX
        """
        this = _casadi.new_SpMX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SpMX
SpMX_swigregister = _casadi.SpMX_swigregister
SpMX_swigregister(SpMX)

class GenericMatrixCommon(_object):
    """Proxy of C++ casadi::GenericMatrixCommon class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericMatrixCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericMatrixCommon, name)
    __repr__ = _swig_repr
    def __mldivide__(x, y): return _casadi.mldivide(x, y)
    def __rmldivide__(y, x): return _casadi.mldivide(x, y)
    def __mrdivide__(x, y): return _casadi.mrdivide(x, y)
    def __rmrdivide__(y, x): return _casadi.mrdivide(x, y)
    def __mpower__(x, y): return _casadi.mpower(x, y)
    def __rmpower__(y, x): return _casadi.mpower(x, y)

    def __init__(self, *args): 
        """
        __init__(casadi::GenericMatrixCommon self) -> GenericMatrixCommon
        __init__(casadi::GenericMatrixCommon self, GenericMatrixCommon other) -> GenericMatrixCommon
        """
        this = _casadi.new_GenericMatrixCommon(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenericMatrixCommon
GenericMatrixCommon_swigregister = _casadi.GenericMatrixCommon_swigregister
GenericMatrixCommon_swigregister(GenericMatrixCommon)

class GenIM(GenericMatrixCommon,SpIM):
    """
    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon,SpIM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenIM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon,SpIM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenIM, name)
    __repr__ = _swig_repr
    def nnz(self, *args):
        """
        nnz(GenIM self) -> int

        Get the number of (structural) non-zero elements.


        """
        return _casadi.GenIM_nnz(self, *args)

    def nnz_lower(self, *args):
        """
        nnz_lower(GenIM self) -> int

        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi.GenIM_nnz_lower(self, *args)

    def nnz_upper(self, *args):
        """
        nnz_upper(GenIM self) -> int

        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi.GenIM_nnz_upper(self, *args)

    def nnz_diag(self, *args):
        """
        nnz_diag(GenIM self) -> int

        Get get the number of non-zeros on the diagonal.


        """
        return _casadi.GenIM_nnz_diag(self, *args)

    def numel(self, *args):
        """
        numel(GenIM self) -> int
        numel(GenIM self, int i) -> int

        >  int MatType .numel() const 
        ------------------------------------------------------------------------

        Get the number of elements.

        >  int MatType .numel(int i) const 
        ------------------------------------------------------------------------

        Get the number of elements in slice (cf. MATLAB)


        """
        return _casadi.GenIM_numel(self, *args)

    def size1(self, *args):
        """
        size1(GenIM self) -> int

        Get the first dimension (i.e. number of rows)


        """
        return _casadi.GenIM_size1(self, *args)

    def size2(self, *args):
        """
        size2(GenIM self) -> int

        Get the second dimension (i.e. number of columns)


        """
        return _casadi.GenIM_size2(self, *args)

    def dim(self, *args):
        """
        dim(GenIM self) -> std::string

        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi.GenIM_dim(self, *args)

    def size(self, *args):
        """
        size(GenIM self) -> std::pair< int,int >
        size(GenIM self, int axis) -> int

        >  (int,int) MatType .size() const 
        ------------------------------------------------------------------------

        Get the shape.

        >  int MatType .size(int axis) const 
        ------------------------------------------------------------------------

        Get the size along a particular dimensions.


        """
        return _casadi.GenIM_size(self, *args)

    def is_empty(self, *args):
        """
        is_empty(GenIM self, bool both=False) -> bool

        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi.GenIM_is_empty(self, *args)

    def is_dense(self, *args):
        """
        is_dense(GenIM self) -> bool

        Check if the matrix expression is dense.


        """
        return _casadi.GenIM_is_dense(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(GenIM self, bool scalar_and_dense=False) -> bool

        Check if the matrix expression is scalar.


        """
        return _casadi.GenIM_is_scalar(self, *args)

    def is_square(self, *args):
        """
        is_square(GenIM self) -> bool

        Check if the matrix expression is square.


        """
        return _casadi.GenIM_is_square(self, *args)

    def is_vector(self, *args):
        """
        is_vector(GenIM self) -> bool

        Check if the matrix is a row or column vector.


        """
        return _casadi.GenIM_is_vector(self, *args)

    def is_row(self, *args):
        """
        is_row(GenIM self) -> bool

        Check if the matrix is a row vector (i.e. size1()==1)


        """
        return _casadi.GenIM_is_row(self, *args)

    def is_column(self, *args):
        """
        is_column(GenIM self) -> bool

        Check if the matrix is a column vector (i.e. size2()==1)


        """
        return _casadi.GenIM_is_column(self, *args)

    def is_triu(self, *args):
        """
        is_triu(GenIM self) -> bool

        Check if the matrix is upper triangular.


        """
        return _casadi.GenIM_is_triu(self, *args)

    def is_tril(self, *args):
        """
        is_tril(GenIM self) -> bool

        Check if the matrix is lower triangular.


        """
        return _casadi.GenIM_is_tril(self, *args)

    def row(self, *args):
        """
        row(GenIM self) -> std::vector< int,std::allocator< int > >
        row(GenIM self, int el) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenIM_row(self, *args)

    def colind(self, *args):
        """
        colind(GenIM self) -> std::vector< int,std::allocator< int > >
        colind(GenIM self, int col) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenIM_colind(self, *args)

    def find(self, *args):
        """
        find(GenIM self, bool ind1=False) -> std::vector< int,std::allocator< int > >

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B


        """
        return _casadi.GenIM_find(self, *args)

    def sparsity(self, *args):
        """
        sparsity(GenIM self) -> Sparsity

        Get the sparsity pattern.


        """
        return _casadi.GenIM_sparsity(self, *args)

    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> IM
        sym(std::string const & name, std::pair< int,int > const & rc) -> IM
        sym(std::string const & name, Sparsity sp) -> IM
        sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
        sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
        sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >

        >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType MatType .sym(str name, (int,int) rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType MatType .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.

        >  SX SX .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.GenIM_sym(*args)

    if _newclass:sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym
    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> IM
        zeros(Sparsity sp) -> IM
        zeros(std::pair< int,int > const & rc) -> IM

        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi.GenIM_zeros(*args)

    if _newclass:zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros
    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> IM
        ones(Sparsity sp) -> IM
        ones(std::pair< int,int > const & rc) -> IM

        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi.GenIM_ones(*args)

    if _newclass:ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones
    def __init__(self, *args): 
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(int)>)> self) -> GenIM
        __init__(casadi::GenericMatrix<(casadi::Matrix<(int)>)> self, GenIM other) -> GenIM
        """
        this = _casadi.new_GenIM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenIM
GenIM_swigregister = _casadi.GenIM_swigregister
GenIM_swigregister(GenIM)

def GenIM_sym(*args):
  """
    sym(std::string const & name, int nrow=1, int ncol=1) -> IM
    sym(std::string const & name, std::pair< int,int > const & rc) -> IM
    sym(std::string const & name, Sparsity sp) -> IM
    sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >
    GenIM_sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >

    >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType MatType .sym(str name, (int,int) rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType MatType .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.

    >  SX SX .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
  return _casadi.GenIM_sym(*args)

def GenIM_zeros(*args):
  """
    zeros(int nrow=1, int ncol=1) -> IM
    zeros(Sparsity sp) -> IM
    GenIM_zeros(std::pair< int,int > const & rc) -> IM

    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
  return _casadi.GenIM_zeros(*args)

def GenIM_ones(*args):
  """
    ones(int nrow=1, int ncol=1) -> IM
    ones(Sparsity sp) -> IM
    GenIM_ones(std::pair< int,int > const & rc) -> IM

    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
  return _casadi.GenIM_ones(*args)

class GenDM(GenericMatrixCommon,SpDM):
    """
    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon,SpDM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenDM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon,SpDM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenDM, name)
    __repr__ = _swig_repr
    def nnz(self, *args):
        """
        nnz(GenDM self) -> int

        Get the number of (structural) non-zero elements.


        """
        return _casadi.GenDM_nnz(self, *args)

    def nnz_lower(self, *args):
        """
        nnz_lower(GenDM self) -> int

        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi.GenDM_nnz_lower(self, *args)

    def nnz_upper(self, *args):
        """
        nnz_upper(GenDM self) -> int

        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi.GenDM_nnz_upper(self, *args)

    def nnz_diag(self, *args):
        """
        nnz_diag(GenDM self) -> int

        Get get the number of non-zeros on the diagonal.


        """
        return _casadi.GenDM_nnz_diag(self, *args)

    def numel(self, *args):
        """
        numel(GenDM self) -> int
        numel(GenDM self, int i) -> int

        >  int MatType .numel() const 
        ------------------------------------------------------------------------

        Get the number of elements.

        >  int MatType .numel(int i) const 
        ------------------------------------------------------------------------

        Get the number of elements in slice (cf. MATLAB)


        """
        return _casadi.GenDM_numel(self, *args)

    def size1(self, *args):
        """
        size1(GenDM self) -> int

        Get the first dimension (i.e. number of rows)


        """
        return _casadi.GenDM_size1(self, *args)

    def size2(self, *args):
        """
        size2(GenDM self) -> int

        Get the second dimension (i.e. number of columns)


        """
        return _casadi.GenDM_size2(self, *args)

    def dim(self, *args):
        """
        dim(GenDM self) -> std::string

        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi.GenDM_dim(self, *args)

    def size(self, *args):
        """
        size(GenDM self) -> std::pair< int,int >
        size(GenDM self, int axis) -> int

        >  (int,int) MatType .size() const 
        ------------------------------------------------------------------------

        Get the shape.

        >  int MatType .size(int axis) const 
        ------------------------------------------------------------------------

        Get the size along a particular dimensions.


        """
        return _casadi.GenDM_size(self, *args)

    def is_empty(self, *args):
        """
        is_empty(GenDM self, bool both=False) -> bool

        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi.GenDM_is_empty(self, *args)

    def is_dense(self, *args):
        """
        is_dense(GenDM self) -> bool

        Check if the matrix expression is dense.


        """
        return _casadi.GenDM_is_dense(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(GenDM self, bool scalar_and_dense=False) -> bool

        Check if the matrix expression is scalar.


        """
        return _casadi.GenDM_is_scalar(self, *args)

    def is_square(self, *args):
        """
        is_square(GenDM self) -> bool

        Check if the matrix expression is square.


        """
        return _casadi.GenDM_is_square(self, *args)

    def is_vector(self, *args):
        """
        is_vector(GenDM self) -> bool

        Check if the matrix is a row or column vector.


        """
        return _casadi.GenDM_is_vector(self, *args)

    def is_row(self, *args):
        """
        is_row(GenDM self) -> bool

        Check if the matrix is a row vector (i.e. size1()==1)


        """
        return _casadi.GenDM_is_row(self, *args)

    def is_column(self, *args):
        """
        is_column(GenDM self) -> bool

        Check if the matrix is a column vector (i.e. size2()==1)


        """
        return _casadi.GenDM_is_column(self, *args)

    def is_triu(self, *args):
        """
        is_triu(GenDM self) -> bool

        Check if the matrix is upper triangular.


        """
        return _casadi.GenDM_is_triu(self, *args)

    def is_tril(self, *args):
        """
        is_tril(GenDM self) -> bool

        Check if the matrix is lower triangular.


        """
        return _casadi.GenDM_is_tril(self, *args)

    def row(self, *args):
        """
        row(GenDM self) -> std::vector< int,std::allocator< int > >
        row(GenDM self, int el) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenDM_row(self, *args)

    def colind(self, *args):
        """
        colind(GenDM self) -> std::vector< int,std::allocator< int > >
        colind(GenDM self, int col) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenDM_colind(self, *args)

    def find(self, *args):
        """
        find(GenDM self, bool ind1=False) -> std::vector< int,std::allocator< int > >

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B


        """
        return _casadi.GenDM_find(self, *args)

    def sparsity(self, *args):
        """
        sparsity(GenDM self) -> Sparsity

        Get the sparsity pattern.


        """
        return _casadi.GenDM_sparsity(self, *args)

    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> DM
        sym(std::string const & name, std::pair< int,int > const & rc) -> DM
        sym(std::string const & name, Sparsity sp) -> DM
        sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
        sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
        sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >

        >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType MatType .sym(str name, (int,int) rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType MatType .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.

        >  SX SX .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.GenDM_sym(*args)

    if _newclass:sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym
    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> DM
        zeros(Sparsity sp) -> DM
        zeros(std::pair< int,int > const & rc) -> DM

        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi.GenDM_zeros(*args)

    if _newclass:zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros
    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> DM
        ones(Sparsity sp) -> DM
        ones(std::pair< int,int > const & rc) -> DM

        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi.GenDM_ones(*args)

    if _newclass:ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones
    def __init__(self, *args): 
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(double)>)> self) -> GenDM
        __init__(casadi::GenericMatrix<(casadi::Matrix<(double)>)> self, GenDM other) -> GenDM
        """
        this = _casadi.new_GenDM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenDM
GenDM_swigregister = _casadi.GenDM_swigregister
GenDM_swigregister(GenDM)

def GenDM_sym(*args):
  """
    sym(std::string const & name, int nrow=1, int ncol=1) -> DM
    sym(std::string const & name, std::pair< int,int > const & rc) -> DM
    sym(std::string const & name, Sparsity sp) -> DM
    sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >
    GenDM_sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >

    >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType MatType .sym(str name, (int,int) rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType MatType .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.

    >  SX SX .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
  return _casadi.GenDM_sym(*args)

def GenDM_zeros(*args):
  """
    zeros(int nrow=1, int ncol=1) -> DM
    zeros(Sparsity sp) -> DM
    GenDM_zeros(std::pair< int,int > const & rc) -> DM

    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
  return _casadi.GenDM_zeros(*args)

def GenDM_ones(*args):
  """
    ones(int nrow=1, int ncol=1) -> DM
    ones(Sparsity sp) -> DM
    GenDM_ones(std::pair< int,int > const & rc) -> DM

    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
  return _casadi.GenDM_ones(*args)

class GenSX(GenericMatrixCommon,SpSX):
    """
    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon,SpSX]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenSX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon,SpSX]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenSX, name)
    __repr__ = _swig_repr
    def nnz(self, *args):
        """
        nnz(GenSX self) -> int

        Get the number of (structural) non-zero elements.


        """
        return _casadi.GenSX_nnz(self, *args)

    def nnz_lower(self, *args):
        """
        nnz_lower(GenSX self) -> int

        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi.GenSX_nnz_lower(self, *args)

    def nnz_upper(self, *args):
        """
        nnz_upper(GenSX self) -> int

        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi.GenSX_nnz_upper(self, *args)

    def nnz_diag(self, *args):
        """
        nnz_diag(GenSX self) -> int

        Get get the number of non-zeros on the diagonal.


        """
        return _casadi.GenSX_nnz_diag(self, *args)

    def numel(self, *args):
        """
        numel(GenSX self) -> int
        numel(GenSX self, int i) -> int

        >  int MatType .numel() const 
        ------------------------------------------------------------------------

        Get the number of elements.

        >  int MatType .numel(int i) const 
        ------------------------------------------------------------------------

        Get the number of elements in slice (cf. MATLAB)


        """
        return _casadi.GenSX_numel(self, *args)

    def size1(self, *args):
        """
        size1(GenSX self) -> int

        Get the first dimension (i.e. number of rows)


        """
        return _casadi.GenSX_size1(self, *args)

    def size2(self, *args):
        """
        size2(GenSX self) -> int

        Get the second dimension (i.e. number of columns)


        """
        return _casadi.GenSX_size2(self, *args)

    def dim(self, *args):
        """
        dim(GenSX self) -> std::string

        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi.GenSX_dim(self, *args)

    def size(self, *args):
        """
        size(GenSX self) -> std::pair< int,int >
        size(GenSX self, int axis) -> int

        >  (int,int) MatType .size() const 
        ------------------------------------------------------------------------

        Get the shape.

        >  int MatType .size(int axis) const 
        ------------------------------------------------------------------------

        Get the size along a particular dimensions.


        """
        return _casadi.GenSX_size(self, *args)

    def is_empty(self, *args):
        """
        is_empty(GenSX self, bool both=False) -> bool

        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi.GenSX_is_empty(self, *args)

    def is_dense(self, *args):
        """
        is_dense(GenSX self) -> bool

        Check if the matrix expression is dense.


        """
        return _casadi.GenSX_is_dense(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(GenSX self, bool scalar_and_dense=False) -> bool

        Check if the matrix expression is scalar.


        """
        return _casadi.GenSX_is_scalar(self, *args)

    def is_square(self, *args):
        """
        is_square(GenSX self) -> bool

        Check if the matrix expression is square.


        """
        return _casadi.GenSX_is_square(self, *args)

    def is_vector(self, *args):
        """
        is_vector(GenSX self) -> bool

        Check if the matrix is a row or column vector.


        """
        return _casadi.GenSX_is_vector(self, *args)

    def is_row(self, *args):
        """
        is_row(GenSX self) -> bool

        Check if the matrix is a row vector (i.e. size1()==1)


        """
        return _casadi.GenSX_is_row(self, *args)

    def is_column(self, *args):
        """
        is_column(GenSX self) -> bool

        Check if the matrix is a column vector (i.e. size2()==1)


        """
        return _casadi.GenSX_is_column(self, *args)

    def is_triu(self, *args):
        """
        is_triu(GenSX self) -> bool

        Check if the matrix is upper triangular.


        """
        return _casadi.GenSX_is_triu(self, *args)

    def is_tril(self, *args):
        """
        is_tril(GenSX self) -> bool

        Check if the matrix is lower triangular.


        """
        return _casadi.GenSX_is_tril(self, *args)

    def row(self, *args):
        """
        row(GenSX self) -> std::vector< int,std::allocator< int > >
        row(GenSX self, int el) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenSX_row(self, *args)

    def colind(self, *args):
        """
        colind(GenSX self) -> std::vector< int,std::allocator< int > >
        colind(GenSX self, int col) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenSX_colind(self, *args)

    def find(self, *args):
        """
        find(GenSX self, bool ind1=False) -> std::vector< int,std::allocator< int > >

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B


        """
        return _casadi.GenSX_find(self, *args)

    def sparsity(self, *args):
        """
        sparsity(GenSX self) -> Sparsity

        Get the sparsity pattern.


        """
        return _casadi.GenSX_sparsity(self, *args)

    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> SX
        sym(std::string const & name, std::pair< int,int > const & rc) -> SX
        sym(std::string const & name, Sparsity sp) -> SX
        sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
        sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
        sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >

        >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType MatType .sym(str name, (int,int) rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType MatType .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.

        >  SX SX .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.GenSX_sym(*args)

    if _newclass:sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym
    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> SX
        zeros(Sparsity sp) -> SX
        zeros(std::pair< int,int > const & rc) -> SX

        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi.GenSX_zeros(*args)

    if _newclass:zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros
    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> SX
        ones(Sparsity sp) -> SX
        ones(std::pair< int,int > const & rc) -> SX

        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi.GenSX_ones(*args)

    if _newclass:ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones
    def __init__(self, *args): 
        """
        __init__(casadi::GenericMatrix<(casadi::Matrix<(casadi::SXElem)>)> self) -> GenSX
        __init__(casadi::GenericMatrix<(casadi::Matrix<(casadi::SXElem)>)> self, GenSX other) -> GenSX
        """
        this = _casadi.new_GenSX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenSX
GenSX_swigregister = _casadi.GenSX_swigregister
GenSX_swigregister(GenSX)

def GenSX_sym(*args):
  """
    sym(std::string const & name, int nrow=1, int ncol=1) -> SX
    sym(std::string const & name, std::pair< int,int > const & rc) -> SX
    sym(std::string const & name, Sparsity sp) -> SX
    sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >
    GenSX_sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >

    >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType MatType .sym(str name, (int,int) rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType MatType .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.

    >  SX SX .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
  return _casadi.GenSX_sym(*args)

def GenSX_zeros(*args):
  """
    zeros(int nrow=1, int ncol=1) -> SX
    zeros(Sparsity sp) -> SX
    GenSX_zeros(std::pair< int,int > const & rc) -> SX

    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
  return _casadi.GenSX_zeros(*args)

def GenSX_ones(*args):
  """
    ones(int nrow=1, int ncol=1) -> SX
    ones(Sparsity sp) -> SX
    GenSX_ones(std::pair< int,int > const & rc) -> SX

    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
  return _casadi.GenSX_ones(*args)

class GenMX(GenericMatrixCommon,SpMX):
    """
    Matrix base class.

    This is a common base class for MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom.  The class is designed with the idea that
    "everything is a matrix", that is, also scalars and vectors. This
    philosophy makes it easy to use and to interface in particularly with Python
    and Matlab/Octave.  The syntax tries to stay as close as possible to the
    ublas syntax when it comes to vector/matrix operations.  Index starts with
    0. Index vec happens as follows: (rr, cc) -> k = rr+cc*size1() Vectors are
    column vectors.  The storage format is Compressed Column Storage (CCS),
    similar to that used for sparse matrices in Matlab, but unlike this format,
    we do allow for elements to be structurally non-zero but numerically zero.
    The sparsity pattern, which is reference counted and cached, can be accessed
    with Sparsity& sparsity() Joel Andersson

    C++ includes: generic_matrix.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericMatrixCommon,SpMX]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenMX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericMatrixCommon,SpMX]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GenMX, name)
    __repr__ = _swig_repr
    def nnz(self, *args):
        """
        nnz(GenMX self) -> int

        Get the number of (structural) non-zero elements.


        """
        return _casadi.GenMX_nnz(self, *args)

    def nnz_lower(self, *args):
        """
        nnz_lower(GenMX self) -> int

        Get the number of non-zeros in the lower triangular half.


        """
        return _casadi.GenMX_nnz_lower(self, *args)

    def nnz_upper(self, *args):
        """
        nnz_upper(GenMX self) -> int

        Get the number of non-zeros in the upper triangular half.


        """
        return _casadi.GenMX_nnz_upper(self, *args)

    def nnz_diag(self, *args):
        """
        nnz_diag(GenMX self) -> int

        Get get the number of non-zeros on the diagonal.


        """
        return _casadi.GenMX_nnz_diag(self, *args)

    def numel(self, *args):
        """
        numel(GenMX self) -> int
        numel(GenMX self, int i) -> int

        >  int MatType .numel() const 
        ------------------------------------------------------------------------

        Get the number of elements.

        >  int MatType .numel(int i) const 
        ------------------------------------------------------------------------

        Get the number of elements in slice (cf. MATLAB)


        """
        return _casadi.GenMX_numel(self, *args)

    def size1(self, *args):
        """
        size1(GenMX self) -> int

        Get the first dimension (i.e. number of rows)


        """
        return _casadi.GenMX_size1(self, *args)

    def size2(self, *args):
        """
        size2(GenMX self) -> int

        Get the second dimension (i.e. number of columns)


        """
        return _casadi.GenMX_size2(self, *args)

    def dim(self, *args):
        """
        dim(GenMX self) -> std::string

        Get string representation of dimensions. The representation is (nrow x ncol
        = numel | size)


        """
        return _casadi.GenMX_dim(self, *args)

    def size(self, *args):
        """
        size(GenMX self) -> std::pair< int,int >
        size(GenMX self, int axis) -> int

        >  (int,int) MatType .size() const 
        ------------------------------------------------------------------------

        Get the shape.

        >  int MatType .size(int axis) const 
        ------------------------------------------------------------------------

        Get the size along a particular dimensions.


        """
        return _casadi.GenMX_size(self, *args)

    def is_empty(self, *args):
        """
        is_empty(GenMX self, bool both=False) -> bool

        Check if the sparsity is empty, i.e. if one of the dimensions is zero (or
        optionally both dimensions)


        """
        return _casadi.GenMX_is_empty(self, *args)

    def is_dense(self, *args):
        """
        is_dense(GenMX self) -> bool

        Check if the matrix expression is dense.


        """
        return _casadi.GenMX_is_dense(self, *args)

    def is_scalar(self, *args):
        """
        is_scalar(GenMX self, bool scalar_and_dense=False) -> bool

        Check if the matrix expression is scalar.


        """
        return _casadi.GenMX_is_scalar(self, *args)

    def is_square(self, *args):
        """
        is_square(GenMX self) -> bool

        Check if the matrix expression is square.


        """
        return _casadi.GenMX_is_square(self, *args)

    def is_vector(self, *args):
        """
        is_vector(GenMX self) -> bool

        Check if the matrix is a row or column vector.


        """
        return _casadi.GenMX_is_vector(self, *args)

    def is_row(self, *args):
        """
        is_row(GenMX self) -> bool

        Check if the matrix is a row vector (i.e. size1()==1)


        """
        return _casadi.GenMX_is_row(self, *args)

    def is_column(self, *args):
        """
        is_column(GenMX self) -> bool

        Check if the matrix is a column vector (i.e. size2()==1)


        """
        return _casadi.GenMX_is_column(self, *args)

    def is_triu(self, *args):
        """
        is_triu(GenMX self) -> bool

        Check if the matrix is upper triangular.


        """
        return _casadi.GenMX_is_triu(self, *args)

    def is_tril(self, *args):
        """
        is_tril(GenMX self) -> bool

        Check if the matrix is lower triangular.


        """
        return _casadi.GenMX_is_tril(self, *args)

    def row(self, *args):
        """
        row(GenMX self) -> std::vector< int,std::allocator< int > >
        row(GenMX self, int el) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenMX_row(self, *args)

    def colind(self, *args):
        """
        colind(GenMX self) -> std::vector< int,std::allocator< int > >
        colind(GenMX self, int col) -> int

        Get the sparsity pattern. See the Sparsity class for details.


        """
        return _casadi.GenMX_colind(self, *args)

    def find(self, *args):
        """
        find(GenMX self, bool ind1=False) -> std::vector< int,std::allocator< int > >

        Get the location of all non-zero elements as they would appear in a Dense
        matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-
        zeros.

        k = A.find() A[k] will contain the elements of A that are non-zero in B


        """
        return _casadi.GenMX_find(self, *args)

    def sparsity(self, *args):
        """
        sparsity(GenMX self) -> Sparsity

        Get the sparsity pattern.


        """
        return _casadi.GenMX_sparsity(self, *args)

    def sym(*args):
        """
        sym(std::string const & name, int nrow=1, int ncol=1) -> MX
        sym(std::string const & name, std::pair< int,int > const & rc) -> MX
        sym(std::string const & name, Sparsity sp) -> MX
        sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
        sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
        sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >
        sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >

        >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
        ------------------------------------------------------------------------

        Create an nrow-by-ncol symbolic primitive.

        >  static MatType MatType .sym(str name, (int,int) rc)
        ------------------------------------------------------------------------

        Construct a symbolic primitive with given dimensions.

        >  MatType MatType .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------

        Create symbolic primitive with a given sparsity pattern.

        >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with with matrices with symbolic primitives of
        given sparsity.

        >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
        ------------------------------------------------------------------------

        Create a vector of length p with nrow-by-ncol symbolic primitives.

        >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with symbolic primitives
        with given sparsity.

        >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
        ------------------------------------------------------------------------

        Create a vector of length r of vectors of length p with nrow-by-ncol
        symbolic primitives.

        >  SX SX .sym(str name, Sparsity sp)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.GenMX_sym(*args)

    if _newclass:sym = staticmethod(sym)
    __swig_getmethods__["sym"] = lambda x: sym
    def zeros(*args):
        """
        zeros(int nrow=1, int ncol=1) -> MX
        zeros(Sparsity sp) -> MX
        zeros(std::pair< int,int > const & rc) -> MX

        Create a dense matrix or a matrix with specified sparsity with all entries
        zero.


        """
        return _casadi.GenMX_zeros(*args)

    if _newclass:zeros = staticmethod(zeros)
    __swig_getmethods__["zeros"] = lambda x: zeros
    def ones(*args):
        """
        ones(int nrow=1, int ncol=1) -> MX
        ones(Sparsity sp) -> MX
        ones(std::pair< int,int > const & rc) -> MX

        Create a dense matrix or a matrix with specified sparsity with all entries
        one.


        """
        return _casadi.GenMX_ones(*args)

    if _newclass:ones = staticmethod(ones)
    __swig_getmethods__["ones"] = lambda x: ones
    def __init__(self, *args): 
        """
        __init__(casadi::GenericMatrix<(casadi::MX)> self) -> GenMX
        __init__(casadi::GenericMatrix<(casadi::MX)> self, GenMX other) -> GenMX
        """
        this = _casadi.new_GenMX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenMX
GenMX_swigregister = _casadi.GenMX_swigregister
GenMX_swigregister(GenMX)

def GenMX_sym(*args):
  """
    sym(std::string const & name, int nrow=1, int ncol=1) -> MX
    sym(std::string const & name, std::pair< int,int > const & rc) -> MX
    sym(std::string const & name, Sparsity sp) -> MX
    sym(std::string const & name, Sparsity sp, int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    sym(std::string const & name, int nrow, int ncol, int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    sym(std::string const & name, Sparsity sp, int p, int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >
    GenMX_sym(std::string const & name, int nrow, int ncol, int p, int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >

    >  static MatType MatType .sym(str name, int nrow=1, int ncol=1)
    ------------------------------------------------------------------------

    Create an nrow-by-ncol symbolic primitive.

    >  static MatType MatType .sym(str name, (int,int) rc)
    ------------------------------------------------------------------------

    Construct a symbolic primitive with given dimensions.

    >  MatType MatType .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------

    Create symbolic primitive with a given sparsity pattern.

    >  [MatType ] MatType .sym(str name, Sparsity sp, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with with matrices with symbolic primitives of
    given sparsity.

    >  static[MatType ] MatType .sym(str name, int nrow, int ncol, int p)
    ------------------------------------------------------------------------

    Create a vector of length p with nrow-by-ncol symbolic primitives.

    >  [[MatType ] ] MatType .sym(str name, Sparsity sp, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with symbolic primitives
    with given sparsity.

    >  static[[MatType] ] MatType .sym(str name, int nrow, int ncol, int p, int r)
    ------------------------------------------------------------------------

    Create a vector of length r of vectors of length p with nrow-by-ncol
    symbolic primitives.

    >  SX SX .sym(str name, Sparsity sp)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
  return _casadi.GenMX_sym(*args)

def GenMX_zeros(*args):
  """
    zeros(int nrow=1, int ncol=1) -> MX
    zeros(Sparsity sp) -> MX
    GenMX_zeros(std::pair< int,int > const & rc) -> MX

    Create a dense matrix or a matrix with specified sparsity with all entries
    zero.


    """
  return _casadi.GenMX_zeros(*args)

def GenMX_ones(*args):
  """
    ones(int nrow=1, int ncol=1) -> MX
    ones(Sparsity sp) -> MX
    GenMX_ones(std::pair< int,int > const & rc) -> MX

    Create a dense matrix or a matrix with specified sparsity with all entries
    one.


    """
  return _casadi.GenMX_ones(*args)

class GenericExpressionCommon(_object):
    """Proxy of C++ casadi::GenericExpressionCommon class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GenericExpressionCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GenericExpressionCommon, name)
    __repr__ = _swig_repr
    def __add__(x, y): return _casadi.plus(x, y)
    def __radd__(x, y): return _casadi.plus(y, x)
    def __sub__(x, y): return _casadi.minus(x, y)
    def __rsub__(x, y): return _casadi.minus(y, x)
    def __mul__(x, y): return _casadi.times(x, y)
    def __rmul__(x, y): return _casadi.times(y, x)
    def __div__(x, y): return _casadi.rdivide(x, y)
    def __rdiv__(x, y): return _casadi.rdivide(y, x)
    def __truediv__(x, y): return _casadi.rdivide(x, y)
    def __rtruediv__(x, y): return _casadi.rdivide(y, x)
    def __lt__(x, y): return _casadi.lt(x, y)
    def __rlt__(x, y): return _casadi.lt(y, x)
    def __le__(x, y): return _casadi.le(x, y)
    def __rle__(x, y): return _casadi.le(y, x)
    def __gt__(x, y): return _casadi.lt(y, x)
    def __rgt__(x, y): return _casadi.lt(x, y)
    def __ge__(x, y): return _casadi.le(y, x)
    def __rge__(x, y): return _casadi.le(x, y)
    def __eq__(x, y): return _casadi.eq(x, y)
    def __req__(x, y): return _casadi.eq(y, x)
    def __ne__(x, y): return _casadi.ne(x, y)
    def __rne__(x, y): return _casadi.ne(y, x)
    def __pow__(x, n): return _casadi.power(x, n)
    def __rpow__(n, x): return _casadi.power(x, n)
    def __arctan2__(x, y): return _casadi.atan2(x, y)
    def __rarctan2__(y, x): return _casadi.atan2(x, y)
    def fmin(x, y): return _casadi.fmin(x, y)
    def fmax(x, y): return _casadi.fmax(x, y)
    def __fmin__(x, y): return _casadi.fmin(x, y)
    def __rfmin__(y, x): return _casadi.fmin(x, y)
    def __fmax__(x, y): return _casadi.fmax(x, y)
    def __rfmax__(y, x): return _casadi.fmax(x, y)
    def logic_and(x, y): return _casadi.logic_and(x, y)
    def logic_or(x, y): return _casadi.logic_or(x, y)
    def fabs(x): return _casadi.fabs(x)
    def sqrt(x): return _casadi.sqrt(x)
    def sin(x): return _casadi.sin(x)
    def cos(x): return _casadi.cos(x)
    def tan(x): return _casadi.tan(x)
    def arcsin(x): return _casadi.asin(x)
    def arccos(x): return _casadi.acos(x)
    def arctan(x): return _casadi.atan(x)
    def sinh(x): return _casadi.sinh(x)
    def cosh(x): return _casadi.cosh(x)
    def tanh(x): return _casadi.tanh(x)
    def arcsinh(x): return _casadi.asinh(x)
    def arccosh(x): return _casadi.acosh(x)
    def arctanh(x): return _casadi.atanh(x)
    def exp(x): return _casadi.exp(x)
    def log(x): return _casadi.log(x)
    def log10(x): return _casadi.log10(x)
    def floor(x): return _casadi.floor(x)
    def ceil(x): return _casadi.ceil(x)
    def erf(x): return _casadi.erf(x)
    def sign(x): return _casadi.sign(x)
    def fmod(x, y): return _casadi.mod(x, y)
    def __copysign__(x, y): return _casadi.copysign(x, y)
    def __rcopysign__(y, x): return _casadi.copysign(x, y)
    def copysign(x, y): return _casadi.copysign(x, y)
    def rcopysign(y, x): return _casadi.copysign(x, y)
    def __constpow__(x, y): return _casadi.constpow(x, y)
    def __rconstpow__(y, x): return _casadi.constpow(x, y)
    def constpow(x, y): return _casadi.constpow(x, y)
    def rconstpow(y, x): return _casadi.constpow(x, y)

    def __init__(self, *args): 
        """
        __init__(casadi::GenericExpressionCommon self) -> GenericExpressionCommon
        __init__(casadi::GenericExpressionCommon self, GenericExpressionCommon other) -> GenericExpressionCommon
        """
        this = _casadi.new_GenericExpressionCommon(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GenericExpressionCommon
GenericExpressionCommon_swigregister = _casadi.GenericExpressionCommon_swigregister
GenericExpressionCommon_swigregister(GenericExpressionCommon)

class ExpIM(GenericExpressionCommon):
    """
    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpIM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpIM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(int)>)> self) -> ExpIM
        __init__(casadi::GenericExpression<(casadi::Matrix<(int)>)> self, ExpIM other) -> ExpIM
        """
        this = _casadi.new_ExpIM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_ExpIM
ExpIM_swigregister = _casadi.ExpIM_swigregister
ExpIM_swigregister(ExpIM)

class ExpDM(GenericExpressionCommon):
    """
    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpDM, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpDM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(double)>)> self) -> ExpDM
        __init__(casadi::GenericExpression<(casadi::Matrix<(double)>)> self, ExpDM other) -> ExpDM
        """
        this = _casadi.new_ExpDM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_ExpDM
ExpDM_swigregister = _casadi.ExpDM_swigregister
ExpDM_swigregister(ExpDM)

class ExpSX(GenericExpressionCommon):
    """
    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpSX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpSX, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::GenericExpression<(casadi::Matrix<(casadi::SXElem)>)> self) -> ExpSX
        __init__(casadi::GenericExpression<(casadi::Matrix<(casadi::SXElem)>)> self, ExpSX other) -> ExpSX
        """
        this = _casadi.new_ExpSX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_ExpSX
ExpSX_swigregister = _casadi.ExpSX_swigregister
ExpSX_swigregister(ExpSX)

class ExpMX(GenericExpressionCommon):
    """
    Expression interface.

    This is a common base class for SX, MX and Matrix<>, introducing a uniform
    syntax and implementing common functionality using the curiously recurring
    template pattern (CRTP) idiom. Joel Andersson

    C++ includes: generic_expression.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExpMX, name, value)
    __swig_getmethods__ = {}
    for _s in [GenericExpressionCommon]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExpMX, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::GenericExpression<(casadi::MX)> self) -> ExpMX
        __init__(casadi::GenericExpression<(casadi::MX)> self, ExpMX other) -> ExpMX
        """
        this = _casadi.new_ExpMX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_ExpMX
ExpMX_swigregister = _casadi.ExpMX_swigregister
ExpMX_swigregister(ExpMX)

IS_GLOBAL = _casadi.IS_GLOBAL
IS_MEMBER = _casadi.IS_MEMBER
IS_SPARSITY = _casadi.IS_SPARSITY
IS_DMATRIX = _casadi.IS_DMATRIX
IS_IMATRIX = _casadi.IS_IMATRIX
IS_SX = _casadi.IS_SX
IS_MX = _casadi.IS_MX
IS_DOUBLE = _casadi.IS_DOUBLE
class PrintSX(_object):
    """
    Base class for objects that have a natural string representation.

    Joel Andersson

    C++ includes: printable_object.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrintSX, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrintSX, name)
    __repr__ = _swig_repr
    def __str__(self, *args):
        """
        __str__(PrintSX self) -> std::string

        Return a string with a description (for SWIG)


        """
        return _casadi.PrintSX___str__(self, *args)

    def getRepresentation(self, *args):
        """
        getRepresentation(PrintSX self) -> std::string

        Return a string with a representation (for SWIG)


        """
        return _casadi.PrintSX_getRepresentation(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::PrintableObject<(casadi::Matrix<(casadi::SXElem)>)> self) -> PrintSX
        __init__(casadi::PrintableObject<(casadi::Matrix<(casadi::SXElem)>)> self, PrintSX other) -> PrintSX
        """
        this = _casadi.new_PrintSX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_PrintSX
PrintSX_swigregister = _casadi.PrintSX_swigregister
PrintSX_swigregister(PrintSX)

class MatrixCommon(_object):
    """Proxy of C++ casadi::MatrixCommon class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixCommon, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixCommon, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::MatrixCommon self) -> MatrixCommon
        __init__(casadi::MatrixCommon self, MatrixCommon other) -> MatrixCommon
        """
        this = _casadi.new_MatrixCommon(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_MatrixCommon
MatrixCommon_swigregister = _casadi.MatrixCommon_swigregister
MatrixCommon_swigregister(MatrixCommon)


def is_slice(*args):
  """
    is_slice(std::vector< int,std::allocator< int > > const & v, bool ind1=False) -> bool
    is_slice(IM x, bool ind1=False) -> bool

    >  bool is_slice(IM x, bool ind1=false)
    ------------------------------------------------------------------------

    Is the IM a Slice.

    >  bool is_slice([int ] v, bool ind1=false)
    ------------------------------------------------------------------------

    Check if an index vector can be represented more efficiently as a slice.


    """
  return _casadi.is_slice(*args)

def to_slice(*args):
  """
    to_slice(std::vector< int,std::allocator< int > > const & v, bool ind1=False) -> Slice
    to_slice(IM x, bool ind1=False) -> Slice

    >  Slice to_slice(IM x, bool ind1=false)
    ------------------------------------------------------------------------

    Convert IM to Slice.

    >  Slice to_slice([int ] v, bool ind1=false)
    ------------------------------------------------------------------------

    Construct from an index vector (requires is_slice(v) to be true)


    """
  return _casadi.to_slice(*args)
class DM(MatrixCommon,ExpDM,GenDM,PrintDM):
    """
    Sparse matrix class. SX and DM are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [MatrixCommon,ExpDM,GenDM,PrintDM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DM, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon,ExpDM,GenDM,PrintDM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DM, name)
    __repr__ = _swig_repr
    def sanity_check(self, *args):
        """
        sanity_check(DM self, bool complete=False)

        Check if the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi.DM_sanity_check(self, *args)

    def has_nz(self, *args):
        """
        has_nz(DM self, int rr, int cc) -> bool

        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi.DM_has_nz(self, *args)

    def __nonzero__(self, *args):
        """
        __nonzero__(DM self) -> bool

        >  bool array(Scalar) .__nonzero__() const 
        ------------------------------------------------------------------------

        Returns the truth value of a Matrix.

        >  bool SX.__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.DM___nonzero__(self, *args)

    def get(self, *args):
        """
        get(DM self, bool ind1, Slice rr)
        get(DM self, bool ind1, IM rr)
        get(DM self, bool ind1, Sparsity sp)
        get(DM self, bool ind1, Slice rr, Slice cc)
        get(DM self, bool ind1, Slice rr, IM cc)
        get(DM self, bool ind1, IM rr, Slice cc)
        get(DM self, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Sparsity sp) const 
        ------------------------------------------------------------------------

        Get a submatrix, single argument

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, IM cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, IM cc) const 
        ------------------------------------------------------------------------

        Get a submatrix, two arguments


        """
        return _casadi.DM_get(self, *args)

    def set(self, *args):
        """
        set(DM self, DM m, bool ind1, Slice rr)
        set(DM self, DM m, bool ind1, IM rr)
        set(DM self, DM m, bool ind1, Sparsity sp)
        set(DM self, DM m, bool ind1, Slice rr, Slice cc)
        set(DM self, DM m, bool ind1, Slice rr, IM cc)
        set(DM self, DM m, bool ind1, IM rr, Slice cc)
        set(DM self, DM m, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Sparsity sp)
        ------------------------------------------------------------------------

        Set a submatrix, single argument

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, IM cc)
        ------------------------------------------------------------------------

        Set a submatrix, two arguments


        """
        return _casadi.DM_set(self, *args)

    def get_nz(self, *args):
        """
        get_nz(DM self, bool ind1, Slice k)
        get_nz(DM self, bool ind1, IM k)

        Get a set of nonzeros


        """
        return _casadi.DM_get_nz(self, *args)

    def set_nz(self, *args):
        """
        set_nz(DM self, DM m, bool ind1, Slice k)
        set_nz(DM self, DM m, bool ind1, IM k)

        Set a set of nonzeros


        """
        return _casadi.DM_set_nz(self, *args)

    def __pos__(self, *args):
        """__pos__(DM self) -> DM"""
        return _casadi.DM___pos__(self, *args)

    def __neg__(self, *args):
        """__neg__(DM self) -> DM"""
        return _casadi.DM___neg__(self, *args)

    def binary(*args):
        """
        binary(int op, DM x, DM y) -> DM

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.DM_binary(*args)

    if _newclass:binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary
    def unary(*args):
        """
        unary(int op, DM x) -> DM

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.DM_unary(*args)

    if _newclass:unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary
    def scalar_matrix(*args):
        """
        scalar_matrix(int op, DM x, DM y) -> DM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.DM_scalar_matrix(*args)

    if _newclass:scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix
    def matrix_scalar(*args):
        """
        matrix_scalar(int op, DM x, DM y) -> DM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.DM_matrix_scalar(*args)

    if _newclass:matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar
    def matrix_matrix(*args):
        """
        matrix_matrix(int op, DM x, DM y) -> DM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.DM_matrix_matrix(*args)

    if _newclass:matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix
    def printme(self, *args):
        """printme(DM self, DM y) -> DM"""
        return _casadi.DM_printme(self, *args)

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi.DM_setEqualityCheckingDepth(*args)

    if _newclass:setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth
    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi.DM_getEqualityCheckingDepth(*args)

    if _newclass:getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth
    def get_input(*args):
        """get_input(Function f) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"""
        return _casadi.DM_get_input(*args)

    if _newclass:get_input = staticmethod(get_input)
    __swig_getmethods__["get_input"] = lambda x: get_input
    def jac(*args):
        """
        jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> DM
        jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> DM
        jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> DM
        jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
            bool symmetric=False) -> DM

        Jacobian expression.


        """
        return _casadi.DM_jac(*args)

    if _newclass:jac = staticmethod(jac)
    __swig_getmethods__["jac"] = lambda x: jac
    def grad(*args):
        """
        grad(Function f, int iind=0, int oind=0) -> DM
        grad(Function f, std::string const & iname, int oind=0) -> DM
        grad(Function f, int iind, std::string const & oname) -> DM
        grad(Function f, std::string const & iname, std::string const & oname) -> DM

        Gradient expression.


        """
        return _casadi.DM_grad(*args)

    if _newclass:grad = staticmethod(grad)
    __swig_getmethods__["grad"] = lambda x: grad
    def tang(*args):
        """
        tang(Function f, int iind=0, int oind=0) -> DM
        tang(Function f, std::string const & iname, int oind=0) -> DM
        tang(Function f, int iind, std::string const & oname) -> DM
        tang(Function f, std::string const & iname, std::string const & oname) -> DM

        Tangent expression.


        """
        return _casadi.DM_tang(*args)

    if _newclass:tang = staticmethod(tang)
    __swig_getmethods__["tang"] = lambda x: tang
    def hess(*args):
        """
        hess(Function f, int iind=0, int oind=0) -> DM
        hess(Function f, std::string const & iname, int oind=0) -> DM
        hess(Function f, int iind, std::string const & oname) -> DM
        hess(Function f, std::string const & iname, std::string const & oname) -> DM

        Hessian expression


        """
        return _casadi.DM_hess(*args)

    if _newclass:hess = staticmethod(hess)
    __swig_getmethods__["hess"] = lambda x: hess
    def type_name(*args):
        """type_name() -> std::string"""
        return _casadi.DM_type_name(*args)

    if _newclass:type_name = staticmethod(type_name)
    __swig_getmethods__["type_name"] = lambda x: type_name
    def print_split(self, *args):
        """
        print_split(DM self)

        Get strings corresponding to the nonzeros and the interdependencies.


        """
        return _casadi.DM_print_split(self, *args)

    def print_scalar(self, *args):
        """
        print_scalar(DM self, bool trailing_newline=True)

        Print scalar.


        """
        return _casadi.DM_print_scalar(self, *args)

    def print_vector(self, *args):
        """
        print_vector(DM self, bool trailing_newline=True)

        Print vector-style.


        """
        return _casadi.DM_print_vector(self, *args)

    def print_dense(self, *args):
        """
        print_dense(DM self, bool trailing_newline=True)

        Print dense matrix-stype.


        """
        return _casadi.DM_print_dense(self, *args)

    def print_sparse(self, *args):
        """
        print_sparse(DM self, bool trailing_newline=True)

        Print sparse matrix style.


        """
        return _casadi.DM_print_sparse(self, *args)

    def clear(self, *args):
        """clear(DM self)"""
        return _casadi.DM_clear(self, *args)

    def resize(self, *args):
        """resize(DM self, int nrow, int ncol)"""
        return _casadi.DM_resize(self, *args)

    def reserve(self, *args):
        """
        reserve(DM self, int nnz)
        reserve(DM self, int nnz, int ncol)
        """
        return _casadi.DM_reserve(self, *args)

    def erase(self, *args):
        """
        erase(DM self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)
        erase(DM self, std::vector< int,std::allocator< int > > const & rr, bool ind1=False)

        >  void array(Scalar) .erase([int ] rr, [int ] cc, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or
        columns of a matrix.

        >  void array(Scalar) .erase([int ] rr, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase elements of
        a matrix.


        """
        return _casadi.DM_erase(self, *args)

    def remove(self, *args):
        """
        remove(DM self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc)

        Remove columns and rows Remove/delete rows and/or columns of a matrix.


        """
        return _casadi.DM_remove(self, *args)

    def enlarge(self, *args):
        """
        enlarge(DM self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)

        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.


        """
        return _casadi.DM_enlarge(self, *args)

    def sparsity(self, *args):
        """
        sparsity(DM self) -> Sparsity

        Get an owning reference to the sparsity pattern.


        """
        return _casadi.DM_sparsity(self, *args)

    def triplet(*args):
        """
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            DM d) -> DM
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            DM d, int nrow, int ncol) -> DM
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            DM d, std::pair< int,int > const & rc) -> DM
        """
        return _casadi.DM_triplet(*args)

    if _newclass:triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet
    def inf(*args):
        """
        inf(Sparsity sp) -> DM
        inf(int nrow=1, int ncol=1) -> DM
        inf(std::pair< int,int > const & rc) -> DM

        create a matrix with all inf


        """
        return _casadi.DM_inf(*args)

    if _newclass:inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf
    def nan(*args):
        """
        nan(Sparsity sp) -> DM
        nan(int nrow=1, int ncol=1) -> DM
        nan(std::pair< int,int > const & rc) -> DM

        create a matrix with all nan


        """
        return _casadi.DM_nan(*args)

    if _newclass:nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan
    def eye(*args):
        """eye(int ncol) -> DM"""
        return _casadi.DM_eye(*args)

    if _newclass:eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye
    def element_hash(self, *args):
        """
        element_hash(DM self) -> size_t

        Returns a number that is unique for a given symbolic scalar.

        Only defined if symbolic scalar.


        """
        return _casadi.DM_element_hash(self, *args)

    def is_regular(self, *args):
        """
        is_regular(DM self) -> bool

        Checks if expression does not contain NaN or Inf.


        """
        return _casadi.DM_is_regular(self, *args)

    def is_smooth(self, *args):
        """
        is_smooth(DM self) -> bool

        Check if smooth.


        """
        return _casadi.DM_is_smooth(self, *args)

    def is_leaf(self, *args):
        """
        is_leaf(DM self) -> bool

        Check if SX is a leaf of the SX graph.

        Only defined if symbolic scalar.


        """
        return _casadi.DM_is_leaf(self, *args)

    def is_commutative(self, *args):
        """
        is_commutative(DM self) -> bool

        Check whether a binary SX is commutative.

        Only defined if symbolic scalar.


        """
        return _casadi.DM_is_commutative(self, *args)

    def is_symbolic(self, *args):
        """
        is_symbolic(DM self) -> bool

        Check if symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi.DM_is_symbolic(self, *args)

    def is_valid_input(self, *args):
        """
        is_valid_input(DM self) -> bool

        Check if matrix can be used to define function inputs. Sparse matrices can
        return true if all non-zero elements are symbolic.


        """
        return _casadi.DM_is_valid_input(self, *args)

    def has_duplicates(self, *args):
        """
        has_duplicates(DM self) -> bool

        [INTERNAL]  Detect
        duplicate symbolic expressions If there are symbolic primitives appearing
        more than once, the function will return true and the names of the duplicate
        expressions will be printed to userOut<true, PL_WARN>(). Note: Will mark the
        node using SXElem::setTemp. Make sure to call resetInput() after usage.


        """
        return _casadi.DM_has_duplicates(self, *args)

    def resetInput(self, *args):
        """
        resetInput(DM self)

        [INTERNAL]  Reset the
        marker for an input expression.


        """
        return _casadi.DM_resetInput(self, *args)

    def is_constant(self, *args):
        """
        is_constant(DM self) -> bool

        Check if the matrix is constant (note that false negative answers are
        possible)


        """
        return _casadi.DM_is_constant(self, *args)

    def is_integer(self, *args):
        """
        is_integer(DM self) -> bool

        Check if the matrix is integer-valued (note that false negative answers are
        possible)


        """
        return _casadi.DM_is_integer(self, *args)

    def is_zero(self, *args):
        """
        is_zero(DM self) -> bool

        check if the matrix is 0 (note that false negative answers are possible)


        """
        return _casadi.DM_is_zero(self, *args)

    def is_one(self, *args):
        """
        is_one(DM self) -> bool

        check if the matrix is 1 (note that false negative answers are possible)


        """
        return _casadi.DM_is_one(self, *args)

    def is_minus_one(self, *args):
        """
        is_minus_one(DM self) -> bool

        check if the matrix is -1 (note that false negative answers are possible)


        """
        return _casadi.DM_is_minus_one(self, *args)

    def is_identity(self, *args):
        """
        is_identity(DM self) -> bool

        check if the matrix is an identity matrix (note that false negative answers
        are possible)


        """
        return _casadi.DM_is_identity(self, *args)

    def has_zeros(self, *args):
        """
        has_zeros(DM self) -> bool

        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi.DM_has_zeros(self, *args)

    def nonzeros(self, *args):
        """
        nonzeros(DM self) -> std::vector< double,std::allocator< double > >

        [INTERNAL]  Get all
        nonzeros.


        """
        return _casadi.DM_nonzeros(self, *args)

    def __float__(self, *args):
        """__float__(DM self) -> double"""
        return _casadi.DM___float__(self, *args)

    def __int__(self, *args):
        """__int__(DM self) -> int"""
        return _casadi.DM___int__(self, *args)

    def name(self, *args):
        """
        name(DM self) -> std::string

        Get name (only if symbolic scalar)


        """
        return _casadi.DM_name(self, *args)

    def dep(self, *args):
        """
        dep(DM self, int ch=0) -> DM

        Get expressions of the children of the expression Only defined if symbolic
        scalar. Wraps SXElem SXElem::dep(int ch=0) const.


        """
        return _casadi.DM_dep(self, *args)

    def n_dep(self, *args):
        """
        n_dep(DM self) -> int

        Get the number of dependencies of a binary SXElem Only defined if symbolic
        scalar.


        """
        return _casadi.DM_n_dep(self, *args)

    def setPrecision(*args):
        """
        setPrecision(int precision)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.DM_setPrecision(*args)

    if _newclass:setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision
    def setWidth(*args):
        """
        setWidth(int width)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.DM_setWidth(*args)

    if _newclass:setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth
    def setScientific(*args):
        """
        setScientific(bool scientific)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.DM_setScientific(*args)

    if _newclass:setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific
    def __init__(self, *args): 
        """
        __init__(casadi::Matrix<(double)> self) -> DM
        __init__(casadi::Matrix<(double)> self, DM m) -> DM
        __init__(casadi::Matrix<(double)> self, int nrow, int ncol) -> DM
        __init__(casadi::Matrix<(double)> self, Sparsity sp) -> DM
        __init__(casadi::Matrix<(double)> self, Sparsity sp, DM d) -> DM
        __init__(casadi::Matrix<(double)> self, double val) -> DM
        __init__(casadi::Matrix<(double)> self, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & m) -> DM
        __init__(casadi::Matrix<(double)> self, IM x) -> DM
        __init__(casadi::Matrix<(double)> self, std::vector< int,std::allocator< int > > const & x) -> DM
        __init__(casadi::Matrix<(double)> self, SX x) -> DM
        __init__(casadi::Matrix<(double)> self, std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > const & x) -> DM

        >  array(Scalar) ()
        ------------------------------------------------------------------------

        constructors

        empty 0-by-0 matrix constructor

        >  array(Scalar) (array(Scalar) m)
        ------------------------------------------------------------------------

        Copy constructor.

        >  array(Scalar) (int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a sparse matrix with all structural zeros.

        >  array(Scalar) (Sparsity sp)
        ------------------------------------------------------------------------

        Create a sparse matrix from a sparsity pattern. Same as
        Matrix::ones(sparsity)

        >  array(Scalar) (Sparsity sp, array(Scalar) d)
        ------------------------------------------------------------------------

        Construct matrix with a given sparsity and nonzeros.

        >  array(Scalar) (double val)
        ------------------------------------------------------------------------

        This constructor enables implicit type conversion from a numeric type.

        >  array(Scalar) ([[double ] ] m)
        ------------------------------------------------------------------------

        Dense matrix constructor with data given as vector of vectors.

        >  array(Scalar) (array(A) x)
        ------------------------------------------------------------------------

        Create a matrix from another matrix with a different entry type Assumes that
        the scalar conversion is valid.

        >  array(Scalar) ([A ] x)
        ------------------------------------------------------------------------

        Create an expression from a vector.

        >  array(Scalar) ([Scalar ] x)

        >  array(Scalar) ((int,int) rc)

        >  array(Scalar) (Sparsity sp, Scalar val, bool dummy)

        >  array(Scalar) (Sparsity sp, [Scalar ] d, bool dummy)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        this = _casadi.new_DM(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """assign(DM self, DM rhs)"""
        return _casadi.DM_assign(self, *args)

    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)


    def full(self, *args):
        """full(DM self) -> PyObject *"""
        return _casadi.DM_full(self, *args)

    __array_priority__ = 999.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()


    def __array_custom__(self,*args,**kwargs):
      if "dtype" in kwargs and not(isinstance(kwargs["dtype"],n.double)):
        return n.array(self.full(),dtype=kwargs["dtype"])
      else:
        return self.full()

    def sparse(self):
      import numpy as n
      import warnings
      with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        from scipy.sparse import csc_matrix
      return csc_matrix( (self.nonzeros(),self.row(),self.colind()), shape = self.shape, dtype=n.double )

    def tocsc(self):
      return self.sparse()


    def __nonzero__(self):
      if self.numel()!=1:
        raise Exception("Only a scalar can be cast to a float")
      if self.nnz()==0:
        return 0
      return float(self)!=0

    def __abs__(self):
      return abs(float(self))

    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.nonzeros(),dtype=float)}

    __swig_destroy__ = _casadi.delete_DM
DM_swigregister = _casadi.DM_swigregister
DM_swigregister(DM)

def DM_binary(*args):
  """
    DM_binary(int op, DM x, DM y) -> DM

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.DM_binary(*args)

def DM_unary(*args):
  """
    DM_unary(int op, DM x) -> DM

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.DM_unary(*args)

def DM_scalar_matrix(*args):
  """
    DM_scalar_matrix(int op, DM x, DM y) -> DM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.DM_scalar_matrix(*args)

def DM_matrix_scalar(*args):
  """
    DM_matrix_scalar(int op, DM x, DM y) -> DM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.DM_matrix_scalar(*args)

def DM_matrix_matrix(*args):
  """
    DM_matrix_matrix(int op, DM x, DM y) -> DM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.DM_matrix_matrix(*args)

def DM_setEqualityCheckingDepth(*args):
  """DM_setEqualityCheckingDepth(int eq_depth=1)"""
  return _casadi.DM_setEqualityCheckingDepth(*args)

def DM_getEqualityCheckingDepth(*args):
  """DM_getEqualityCheckingDepth() -> int"""
  return _casadi.DM_getEqualityCheckingDepth(*args)

def DM_get_input(*args):
  """DM_get_input(Function f) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"""
  return _casadi.DM_get_input(*args)

def DM_jac(*args):
  """
    jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> DM
    jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> DM
    jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> DM
    DM_jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
        bool symmetric=False) -> DM

    Jacobian expression.


    """
  return _casadi.DM_jac(*args)

def DM_grad(*args):
  """
    grad(Function f, int iind=0, int oind=0) -> DM
    grad(Function f, std::string const & iname, int oind=0) -> DM
    grad(Function f, int iind, std::string const & oname) -> DM
    DM_grad(Function f, std::string const & iname, std::string const & oname) -> DM

    Gradient expression.


    """
  return _casadi.DM_grad(*args)

def DM_tang(*args):
  """
    tang(Function f, int iind=0, int oind=0) -> DM
    tang(Function f, std::string const & iname, int oind=0) -> DM
    tang(Function f, int iind, std::string const & oname) -> DM
    DM_tang(Function f, std::string const & iname, std::string const & oname) -> DM

    Tangent expression.


    """
  return _casadi.DM_tang(*args)

def DM_hess(*args):
  """
    hess(Function f, int iind=0, int oind=0) -> DM
    hess(Function f, std::string const & iname, int oind=0) -> DM
    hess(Function f, int iind, std::string const & oname) -> DM
    DM_hess(Function f, std::string const & iname, std::string const & oname) -> DM

    Hessian expression


    """
  return _casadi.DM_hess(*args)

def DM_type_name(*args):
  """DM_type_name() -> std::string"""
  return _casadi.DM_type_name(*args)

def DM_triplet(*args):
  """
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        DM d) -> DM
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        DM d, int nrow, int ncol) -> DM
    DM_triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        DM d, std::pair< int,int > const & rc) -> DM
    """
  return _casadi.DM_triplet(*args)

def DM_inf(*args):
  """
    inf(Sparsity sp) -> DM
    inf(int nrow=1, int ncol=1) -> DM
    DM_inf(std::pair< int,int > const & rc) -> DM

    create a matrix with all inf


    """
  return _casadi.DM_inf(*args)

def DM_nan(*args):
  """
    nan(Sparsity sp) -> DM
    nan(int nrow=1, int ncol=1) -> DM
    DM_nan(std::pair< int,int > const & rc) -> DM

    create a matrix with all nan


    """
  return _casadi.DM_nan(*args)

def DM_eye(*args):
  """DM_eye(int ncol) -> DM"""
  return _casadi.DM_eye(*args)

def DM_setPrecision(*args):
  """
    DM_setPrecision(int precision)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.DM_setPrecision(*args)

def DM_setWidth(*args):
  """
    DM_setWidth(int width)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.DM_setWidth(*args)

def DM_setScientific(*args):
  """
    DM_setScientific(bool scientific)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.DM_setScientific(*args)

class IM(MatrixCommon,ExpIM,GenIM,PrintIM):
    """
    Sparse matrix class. SX and DM are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [MatrixCommon,ExpIM,GenIM,PrintIM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IM, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon,ExpIM,GenIM,PrintIM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IM, name)
    __repr__ = _swig_repr
    def sanity_check(self, *args):
        """
        sanity_check(IM self, bool complete=False)

        Check if the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi.IM_sanity_check(self, *args)

    def has_nz(self, *args):
        """
        has_nz(IM self, int rr, int cc) -> bool

        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi.IM_has_nz(self, *args)

    def __nonzero__(self, *args):
        """
        __nonzero__(IM self) -> bool

        >  bool array(Scalar) .__nonzero__() const 
        ------------------------------------------------------------------------

        Returns the truth value of a Matrix.

        >  bool SX.__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.IM___nonzero__(self, *args)

    def get(self, *args):
        """
        get(IM self, bool ind1, Slice rr)
        get(IM self, bool ind1, IM rr)
        get(IM self, bool ind1, Sparsity sp)
        get(IM self, bool ind1, Slice rr, Slice cc)
        get(IM self, bool ind1, Slice rr, IM cc)
        get(IM self, bool ind1, IM rr, Slice cc)
        get(IM self, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Sparsity sp) const 
        ------------------------------------------------------------------------

        Get a submatrix, single argument

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, IM cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, IM cc) const 
        ------------------------------------------------------------------------

        Get a submatrix, two arguments


        """
        return _casadi.IM_get(self, *args)

    def set(self, *args):
        """
        set(IM self, IM m, bool ind1, Slice rr)
        set(IM self, IM m, bool ind1, IM rr)
        set(IM self, IM m, bool ind1, Sparsity sp)
        set(IM self, IM m, bool ind1, Slice rr, Slice cc)
        set(IM self, IM m, bool ind1, Slice rr, IM cc)
        set(IM self, IM m, bool ind1, IM rr, Slice cc)
        set(IM self, IM m, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Sparsity sp)
        ------------------------------------------------------------------------

        Set a submatrix, single argument

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, IM cc)
        ------------------------------------------------------------------------

        Set a submatrix, two arguments


        """
        return _casadi.IM_set(self, *args)

    def get_nz(self, *args):
        """
        get_nz(IM self, bool ind1, Slice k)
        get_nz(IM self, bool ind1, IM k)

        Get a set of nonzeros


        """
        return _casadi.IM_get_nz(self, *args)

    def set_nz(self, *args):
        """
        set_nz(IM self, IM m, bool ind1, Slice k)
        set_nz(IM self, IM m, bool ind1, IM k)

        Set a set of nonzeros


        """
        return _casadi.IM_set_nz(self, *args)

    def __pos__(self, *args):
        """__pos__(IM self) -> IM"""
        return _casadi.IM___pos__(self, *args)

    def __neg__(self, *args):
        """__neg__(IM self) -> IM"""
        return _casadi.IM___neg__(self, *args)

    def binary(*args):
        """
        binary(int op, IM x, IM y) -> IM

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.IM_binary(*args)

    if _newclass:binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary
    def unary(*args):
        """
        unary(int op, IM x) -> IM

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.IM_unary(*args)

    if _newclass:unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary
    def scalar_matrix(*args):
        """
        scalar_matrix(int op, IM x, IM y) -> IM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.IM_scalar_matrix(*args)

    if _newclass:scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix
    def matrix_scalar(*args):
        """
        matrix_scalar(int op, IM x, IM y) -> IM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.IM_matrix_scalar(*args)

    if _newclass:matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar
    def matrix_matrix(*args):
        """
        matrix_matrix(int op, IM x, IM y) -> IM

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.IM_matrix_matrix(*args)

    if _newclass:matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix
    def printme(self, *args):
        """printme(IM self, IM y) -> IM"""
        return _casadi.IM_printme(self, *args)

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi.IM_setEqualityCheckingDepth(*args)

    if _newclass:setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth
    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi.IM_getEqualityCheckingDepth(*args)

    if _newclass:getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth
    def get_input(*args):
        """get_input(Function f) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >"""
        return _casadi.IM_get_input(*args)

    if _newclass:get_input = staticmethod(get_input)
    __swig_getmethods__["get_input"] = lambda x: get_input
    def jac(*args):
        """
        jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> IM
        jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> IM
        jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> IM
        jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
            bool symmetric=False) -> IM

        Jacobian expression.


        """
        return _casadi.IM_jac(*args)

    if _newclass:jac = staticmethod(jac)
    __swig_getmethods__["jac"] = lambda x: jac
    def grad(*args):
        """
        grad(Function f, int iind=0, int oind=0) -> IM
        grad(Function f, std::string const & iname, int oind=0) -> IM
        grad(Function f, int iind, std::string const & oname) -> IM
        grad(Function f, std::string const & iname, std::string const & oname) -> IM

        Gradient expression.


        """
        return _casadi.IM_grad(*args)

    if _newclass:grad = staticmethod(grad)
    __swig_getmethods__["grad"] = lambda x: grad
    def tang(*args):
        """
        tang(Function f, int iind=0, int oind=0) -> IM
        tang(Function f, std::string const & iname, int oind=0) -> IM
        tang(Function f, int iind, std::string const & oname) -> IM
        tang(Function f, std::string const & iname, std::string const & oname) -> IM

        Tangent expression.


        """
        return _casadi.IM_tang(*args)

    if _newclass:tang = staticmethod(tang)
    __swig_getmethods__["tang"] = lambda x: tang
    def hess(*args):
        """
        hess(Function f, int iind=0, int oind=0) -> IM
        hess(Function f, std::string const & iname, int oind=0) -> IM
        hess(Function f, int iind, std::string const & oname) -> IM
        hess(Function f, std::string const & iname, std::string const & oname) -> IM

        Hessian expression


        """
        return _casadi.IM_hess(*args)

    if _newclass:hess = staticmethod(hess)
    __swig_getmethods__["hess"] = lambda x: hess
    def type_name(*args):
        """type_name() -> std::string"""
        return _casadi.IM_type_name(*args)

    if _newclass:type_name = staticmethod(type_name)
    __swig_getmethods__["type_name"] = lambda x: type_name
    def print_split(self, *args):
        """
        print_split(IM self)

        Get strings corresponding to the nonzeros and the interdependencies.


        """
        return _casadi.IM_print_split(self, *args)

    def print_scalar(self, *args):
        """
        print_scalar(IM self, bool trailing_newline=True)

        Print scalar.


        """
        return _casadi.IM_print_scalar(self, *args)

    def print_vector(self, *args):
        """
        print_vector(IM self, bool trailing_newline=True)

        Print vector-style.


        """
        return _casadi.IM_print_vector(self, *args)

    def print_dense(self, *args):
        """
        print_dense(IM self, bool trailing_newline=True)

        Print dense matrix-stype.


        """
        return _casadi.IM_print_dense(self, *args)

    def print_sparse(self, *args):
        """
        print_sparse(IM self, bool trailing_newline=True)

        Print sparse matrix style.


        """
        return _casadi.IM_print_sparse(self, *args)

    def clear(self, *args):
        """clear(IM self)"""
        return _casadi.IM_clear(self, *args)

    def resize(self, *args):
        """resize(IM self, int nrow, int ncol)"""
        return _casadi.IM_resize(self, *args)

    def reserve(self, *args):
        """
        reserve(IM self, int nnz)
        reserve(IM self, int nnz, int ncol)
        """
        return _casadi.IM_reserve(self, *args)

    def erase(self, *args):
        """
        erase(IM self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)
        erase(IM self, std::vector< int,std::allocator< int > > const & rr, bool ind1=False)

        >  void array(Scalar) .erase([int ] rr, [int ] cc, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or
        columns of a matrix.

        >  void array(Scalar) .erase([int ] rr, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase elements of
        a matrix.


        """
        return _casadi.IM_erase(self, *args)

    def remove(self, *args):
        """
        remove(IM self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc)

        Remove columns and rows Remove/delete rows and/or columns of a matrix.


        """
        return _casadi.IM_remove(self, *args)

    def enlarge(self, *args):
        """
        enlarge(IM self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)

        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.


        """
        return _casadi.IM_enlarge(self, *args)

    def sparsity(self, *args):
        """
        sparsity(IM self) -> Sparsity

        Get an owning reference to the sparsity pattern.


        """
        return _casadi.IM_sparsity(self, *args)

    def triplet(*args):
        """
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            IM d) -> IM
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            IM d, int nrow, int ncol) -> IM
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            IM d, std::pair< int,int > const & rc) -> IM
        """
        return _casadi.IM_triplet(*args)

    if _newclass:triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet
    def inf(*args):
        """
        inf(Sparsity sp) -> IM
        inf(int nrow=1, int ncol=1) -> IM
        inf(std::pair< int,int > const & rc) -> IM

        create a matrix with all inf


        """
        return _casadi.IM_inf(*args)

    if _newclass:inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf
    def nan(*args):
        """
        nan(Sparsity sp) -> IM
        nan(int nrow=1, int ncol=1) -> IM
        nan(std::pair< int,int > const & rc) -> IM

        create a matrix with all nan


        """
        return _casadi.IM_nan(*args)

    if _newclass:nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan
    def eye(*args):
        """eye(int ncol) -> IM"""
        return _casadi.IM_eye(*args)

    if _newclass:eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye
    def element_hash(self, *args):
        """
        element_hash(IM self) -> size_t

        Returns a number that is unique for a given symbolic scalar.

        Only defined if symbolic scalar.


        """
        return _casadi.IM_element_hash(self, *args)

    def is_regular(self, *args):
        """
        is_regular(IM self) -> bool

        Checks if expression does not contain NaN or Inf.


        """
        return _casadi.IM_is_regular(self, *args)

    def is_smooth(self, *args):
        """
        is_smooth(IM self) -> bool

        Check if smooth.


        """
        return _casadi.IM_is_smooth(self, *args)

    def is_leaf(self, *args):
        """
        is_leaf(IM self) -> bool

        Check if SX is a leaf of the SX graph.

        Only defined if symbolic scalar.


        """
        return _casadi.IM_is_leaf(self, *args)

    def is_commutative(self, *args):
        """
        is_commutative(IM self) -> bool

        Check whether a binary SX is commutative.

        Only defined if symbolic scalar.


        """
        return _casadi.IM_is_commutative(self, *args)

    def is_symbolic(self, *args):
        """
        is_symbolic(IM self) -> bool

        Check if symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi.IM_is_symbolic(self, *args)

    def is_valid_input(self, *args):
        """
        is_valid_input(IM self) -> bool

        Check if matrix can be used to define function inputs. Sparse matrices can
        return true if all non-zero elements are symbolic.


        """
        return _casadi.IM_is_valid_input(self, *args)

    def has_duplicates(self, *args):
        """
        has_duplicates(IM self) -> bool

        [INTERNAL]  Detect
        duplicate symbolic expressions If there are symbolic primitives appearing
        more than once, the function will return true and the names of the duplicate
        expressions will be printed to userOut<true, PL_WARN>(). Note: Will mark the
        node using SXElem::setTemp. Make sure to call resetInput() after usage.


        """
        return _casadi.IM_has_duplicates(self, *args)

    def resetInput(self, *args):
        """
        resetInput(IM self)

        [INTERNAL]  Reset the
        marker for an input expression.


        """
        return _casadi.IM_resetInput(self, *args)

    def is_constant(self, *args):
        """
        is_constant(IM self) -> bool

        Check if the matrix is constant (note that false negative answers are
        possible)


        """
        return _casadi.IM_is_constant(self, *args)

    def is_integer(self, *args):
        """
        is_integer(IM self) -> bool

        Check if the matrix is integer-valued (note that false negative answers are
        possible)


        """
        return _casadi.IM_is_integer(self, *args)

    def is_zero(self, *args):
        """
        is_zero(IM self) -> bool

        check if the matrix is 0 (note that false negative answers are possible)


        """
        return _casadi.IM_is_zero(self, *args)

    def is_one(self, *args):
        """
        is_one(IM self) -> bool

        check if the matrix is 1 (note that false negative answers are possible)


        """
        return _casadi.IM_is_one(self, *args)

    def is_minus_one(self, *args):
        """
        is_minus_one(IM self) -> bool

        check if the matrix is -1 (note that false negative answers are possible)


        """
        return _casadi.IM_is_minus_one(self, *args)

    def is_identity(self, *args):
        """
        is_identity(IM self) -> bool

        check if the matrix is an identity matrix (note that false negative answers
        are possible)


        """
        return _casadi.IM_is_identity(self, *args)

    def has_zeros(self, *args):
        """
        has_zeros(IM self) -> bool

        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi.IM_has_zeros(self, *args)

    def nonzeros(self, *args):
        """
        nonzeros(IM self) -> std::vector< int,std::allocator< int > >

        [INTERNAL]  Get all
        nonzeros.


        """
        return _casadi.IM_nonzeros(self, *args)

    def __float__(self, *args):
        """__float__(IM self) -> double"""
        return _casadi.IM___float__(self, *args)

    def __int__(self, *args):
        """__int__(IM self) -> int"""
        return _casadi.IM___int__(self, *args)

    def name(self, *args):
        """
        name(IM self) -> std::string

        Get name (only if symbolic scalar)


        """
        return _casadi.IM_name(self, *args)

    def dep(self, *args):
        """
        dep(IM self, int ch=0) -> IM

        Get expressions of the children of the expression Only defined if symbolic
        scalar. Wraps SXElem SXElem::dep(int ch=0) const.


        """
        return _casadi.IM_dep(self, *args)

    def n_dep(self, *args):
        """
        n_dep(IM self) -> int

        Get the number of dependencies of a binary SXElem Only defined if symbolic
        scalar.


        """
        return _casadi.IM_n_dep(self, *args)

    def setPrecision(*args):
        """
        setPrecision(int precision)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.IM_setPrecision(*args)

    if _newclass:setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision
    def setWidth(*args):
        """
        setWidth(int width)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.IM_setWidth(*args)

    if _newclass:setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth
    def setScientific(*args):
        """
        setScientific(bool scientific)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.IM_setScientific(*args)

    if _newclass:setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific
    def __init__(self, *args): 
        """
        __init__(casadi::Matrix<(int)> self) -> IM
        __init__(casadi::Matrix<(int)> self, IM m) -> IM
        __init__(casadi::Matrix<(int)> self, int nrow, int ncol) -> IM
        __init__(casadi::Matrix<(int)> self, Sparsity sp) -> IM
        __init__(casadi::Matrix<(int)> self, Sparsity sp, IM d) -> IM
        __init__(casadi::Matrix<(int)> self, double val) -> IM
        __init__(casadi::Matrix<(int)> self, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & m) -> IM
        __init__(casadi::Matrix<(int)> self, DM x) -> IM
        __init__(casadi::Matrix<(int)> self, std::vector< double,std::allocator< double > > const & x) -> IM
        __init__(casadi::Matrix<(int)> self, SX x) -> IM
        __init__(casadi::Matrix<(int)> self, std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > const & x) -> IM

        >  array(Scalar) ()
        ------------------------------------------------------------------------

        constructors

        empty 0-by-0 matrix constructor

        >  array(Scalar) (array(Scalar) m)
        ------------------------------------------------------------------------

        Copy constructor.

        >  array(Scalar) (int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a sparse matrix with all structural zeros.

        >  array(Scalar) (Sparsity sp)
        ------------------------------------------------------------------------

        Create a sparse matrix from a sparsity pattern. Same as
        Matrix::ones(sparsity)

        >  array(Scalar) (Sparsity sp, array(Scalar) d)
        ------------------------------------------------------------------------

        Construct matrix with a given sparsity and nonzeros.

        >  array(Scalar) (double val)
        ------------------------------------------------------------------------

        This constructor enables implicit type conversion from a numeric type.

        >  array(Scalar) ([[double ] ] m)
        ------------------------------------------------------------------------

        Dense matrix constructor with data given as vector of vectors.

        >  array(Scalar) (array(A) x)
        ------------------------------------------------------------------------

        Create a matrix from another matrix with a different entry type Assumes that
        the scalar conversion is valid.

        >  array(Scalar) ([A ] x)
        ------------------------------------------------------------------------

        Create an expression from a vector.

        >  array(Scalar) ([Scalar ] x)

        >  array(Scalar) ((int,int) rc)

        >  array(Scalar) (Sparsity sp, Scalar val, bool dummy)

        >  array(Scalar) (Sparsity sp, [Scalar ] d, bool dummy)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        this = _casadi.new_IM(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """assign(IM self, IM rhs)"""
        return _casadi.IM_assign(self, *args)

    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)


    def full(self, *args):
        """full(IM self) -> PyObject *"""
        return _casadi.IM_full(self, *args)

    __array_priority__ = 998.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()


    def __abs__(self):
      return abs(int(self))

    def __setstate__(self, state):
        sp = Sparsity.__new__(Sparsity)
        sp.__setstate__(state["sparsity"])
        self.__init__(sp,state["data"])

    def __getstate__(self):
        return {"sparsity" : self.sparsity().__getstate__(), "data": numpy.array(self.nonzeros(),dtype=int)}

    __swig_destroy__ = _casadi.delete_IM
IM_swigregister = _casadi.IM_swigregister
IM_swigregister(IM)

def IM_binary(*args):
  """
    IM_binary(int op, IM x, IM y) -> IM

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.IM_binary(*args)

def IM_unary(*args):
  """
    IM_unary(int op, IM x) -> IM

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.IM_unary(*args)

def IM_scalar_matrix(*args):
  """
    IM_scalar_matrix(int op, IM x, IM y) -> IM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.IM_scalar_matrix(*args)

def IM_matrix_scalar(*args):
  """
    IM_matrix_scalar(int op, IM x, IM y) -> IM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.IM_matrix_scalar(*args)

def IM_matrix_matrix(*args):
  """
    IM_matrix_matrix(int op, IM x, IM y) -> IM

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.IM_matrix_matrix(*args)

def IM_setEqualityCheckingDepth(*args):
  """IM_setEqualityCheckingDepth(int eq_depth=1)"""
  return _casadi.IM_setEqualityCheckingDepth(*args)

def IM_getEqualityCheckingDepth(*args):
  """IM_getEqualityCheckingDepth() -> int"""
  return _casadi.IM_getEqualityCheckingDepth(*args)

def IM_get_input(*args):
  """IM_get_input(Function f) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >"""
  return _casadi.IM_get_input(*args)

def IM_jac(*args):
  """
    jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> IM
    jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> IM
    jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> IM
    IM_jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
        bool symmetric=False) -> IM

    Jacobian expression.


    """
  return _casadi.IM_jac(*args)

def IM_grad(*args):
  """
    grad(Function f, int iind=0, int oind=0) -> IM
    grad(Function f, std::string const & iname, int oind=0) -> IM
    grad(Function f, int iind, std::string const & oname) -> IM
    IM_grad(Function f, std::string const & iname, std::string const & oname) -> IM

    Gradient expression.


    """
  return _casadi.IM_grad(*args)

def IM_tang(*args):
  """
    tang(Function f, int iind=0, int oind=0) -> IM
    tang(Function f, std::string const & iname, int oind=0) -> IM
    tang(Function f, int iind, std::string const & oname) -> IM
    IM_tang(Function f, std::string const & iname, std::string const & oname) -> IM

    Tangent expression.


    """
  return _casadi.IM_tang(*args)

def IM_hess(*args):
  """
    hess(Function f, int iind=0, int oind=0) -> IM
    hess(Function f, std::string const & iname, int oind=0) -> IM
    hess(Function f, int iind, std::string const & oname) -> IM
    IM_hess(Function f, std::string const & iname, std::string const & oname) -> IM

    Hessian expression


    """
  return _casadi.IM_hess(*args)

def IM_type_name(*args):
  """IM_type_name() -> std::string"""
  return _casadi.IM_type_name(*args)

def IM_triplet(*args):
  """
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        IM d) -> IM
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        IM d, int nrow, int ncol) -> IM
    IM_triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        IM d, std::pair< int,int > const & rc) -> IM
    """
  return _casadi.IM_triplet(*args)

def IM_inf(*args):
  """
    inf(Sparsity sp) -> IM
    inf(int nrow=1, int ncol=1) -> IM
    IM_inf(std::pair< int,int > const & rc) -> IM

    create a matrix with all inf


    """
  return _casadi.IM_inf(*args)

def IM_nan(*args):
  """
    nan(Sparsity sp) -> IM
    nan(int nrow=1, int ncol=1) -> IM
    IM_nan(std::pair< int,int > const & rc) -> IM

    create a matrix with all nan


    """
  return _casadi.IM_nan(*args)

def IM_eye(*args):
  """IM_eye(int ncol) -> IM"""
  return _casadi.IM_eye(*args)

def IM_setPrecision(*args):
  """
    IM_setPrecision(int precision)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.IM_setPrecision(*args)

def IM_setWidth(*args):
  """
    IM_setWidth(int width)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.IM_setWidth(*args)

def IM_setScientific(*args):
  """
    IM_setScientific(bool scientific)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.IM_setScientific(*args)

class SXElem(_object):
    """Proxy of C++ casadi::SXElem class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SXElem, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SXElem, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::SXElem self) -> SXElem
        __init__(casadi::SXElem self, SXElem other) -> SXElem
        """
        this = _casadi.new_SXElem(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SXElem
SXElem_swigregister = _casadi.SXElem_swigregister
SXElem_swigregister(SXElem)

try:
  import numpy

  def constpow(x,y):
    pass

  constpow=numpy.frompyfunc(constpow,2,1)
except:
  pass

class SX(MatrixCommon,ExpSX,GenSX,PrintSX):
    """
    Sparse matrix class. SX and DM are specializations.

    General sparse matrix class that is designed with the idea that "everything
    is a matrix", that is, also scalars and vectors. This philosophy makes it
    easy to use and to interface in particularly with Python and Matlab/Octave.
    Index starts with 0. Index vec happens as follows: (rr, cc) -> k =
    rr+cc*size1() Vectors are column vectors.  The storage format is Compressed
    Column Storage (CCS), similar to that used for sparse matrices in Matlab,
    but unlike this format, we do allow for elements to be structurally non-zero
    but numerically zero.  Matrix<Scalar> is polymorphic with a
    std::vector<Scalar> that contain all non-identical-zero elements. The
    sparsity can be accessed with Sparsity& sparsity() Joel Andersson

    C++ includes: casadi_types.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [MatrixCommon,ExpSX,GenSX,PrintSX]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SX, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixCommon,ExpSX,GenSX,PrintSX]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SX, name)
    __repr__ = _swig_repr
    def sanity_check(self, *args):
        """
        sanity_check(SX self, bool complete=False)

        Check if the dimensions and colind, row vectors are compatible.

        Parameters:
        -----------

        complete:  set to true to also check elementwise throws an error as possible
        result


        """
        return _casadi.SX_sanity_check(self, *args)

    def has_nz(self, *args):
        """
        has_nz(SX self, int rr, int cc) -> bool

        Returns true if the matrix has a non-zero at location rr, cc.


        """
        return _casadi.SX_has_nz(self, *args)

    def __nonzero__(self, *args):
        """
        __nonzero__(SX self) -> bool

        >  bool array(Scalar) .__nonzero__() const 
        ------------------------------------------------------------------------

        Returns the truth value of a Matrix.

        >  bool SX.__nonzero__() const
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        return _casadi.SX___nonzero__(self, *args)

    def get(self, *args):
        """
        get(SX self, bool ind1, Slice rr)
        get(SX self, bool ind1, IM rr)
        get(SX self, bool ind1, Sparsity sp)
        get(SX self, bool ind1, Slice rr, Slice cc)
        get(SX self, bool ind1, Slice rr, IM cc)
        get(SX self, bool ind1, IM rr, Slice cc)
        get(SX self, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Sparsity sp) const 
        ------------------------------------------------------------------------

        Get a submatrix, single argument

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, Slice rr, IM cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, Slice cc) const

        >  void array(Scalar) .get(array(Scalar) output_m, bool ind1, IM rr, IM cc) const 
        ------------------------------------------------------------------------

        Get a submatrix, two arguments


        """
        return _casadi.SX_get(self, *args)

    def set(self, *args):
        """
        set(SX self, SX m, bool ind1, Slice rr)
        set(SX self, SX m, bool ind1, IM rr)
        set(SX self, SX m, bool ind1, Sparsity sp)
        set(SX self, SX m, bool ind1, Slice rr, Slice cc)
        set(SX self, SX m, bool ind1, Slice rr, IM cc)
        set(SX self, SX m, bool ind1, IM rr, Slice cc)
        set(SX self, SX m, bool ind1, IM rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Sparsity sp)
        ------------------------------------------------------------------------

        Set a submatrix, single argument

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, Slice rr, IM cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, Slice cc)

        >  void array(Scalar) .set(array(Scalar) m, bool ind1, IM rr, IM cc)
        ------------------------------------------------------------------------

        Set a submatrix, two arguments


        """
        return _casadi.SX_set(self, *args)

    def get_nz(self, *args):
        """
        get_nz(SX self, bool ind1, Slice k)
        get_nz(SX self, bool ind1, IM k)

        Get a set of nonzeros


        """
        return _casadi.SX_get_nz(self, *args)

    def set_nz(self, *args):
        """
        set_nz(SX self, SX m, bool ind1, Slice k)
        set_nz(SX self, SX m, bool ind1, IM k)

        Set a set of nonzeros


        """
        return _casadi.SX_set_nz(self, *args)

    def __pos__(self, *args):
        """__pos__(SX self) -> SX"""
        return _casadi.SX___pos__(self, *args)

    def __neg__(self, *args):
        """__neg__(SX self) -> SX"""
        return _casadi.SX___neg__(self, *args)

    def binary(*args):
        """
        binary(int op, SX x, SX y) -> SX

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.SX_binary(*args)

    if _newclass:binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary
    def unary(*args):
        """
        unary(int op, SX x) -> SX

        [INTERNAL]  Create nodes by
        their ID.


        """
        return _casadi.SX_unary(*args)

    if _newclass:unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary
    def scalar_matrix(*args):
        """
        scalar_matrix(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.SX_scalar_matrix(*args)

    if _newclass:scalar_matrix = staticmethod(scalar_matrix)
    __swig_getmethods__["scalar_matrix"] = lambda x: scalar_matrix
    def matrix_scalar(*args):
        """
        matrix_scalar(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.SX_matrix_scalar(*args)

    if _newclass:matrix_scalar = staticmethod(matrix_scalar)
    __swig_getmethods__["matrix_scalar"] = lambda x: matrix_scalar
    def matrix_matrix(*args):
        """
        matrix_matrix(int op, SX x, SX y) -> SX

        [INTERNAL]  Create
        nodes by their ID.


        """
        return _casadi.SX_matrix_matrix(*args)

    if _newclass:matrix_matrix = staticmethod(matrix_matrix)
    __swig_getmethods__["matrix_matrix"] = lambda x: matrix_matrix
    def printme(self, *args):
        """printme(SX self, SX y) -> SX"""
        return _casadi.SX_printme(self, *args)

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi.SX_setEqualityCheckingDepth(*args)

    if _newclass:setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth
    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi.SX_getEqualityCheckingDepth(*args)

    if _newclass:getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth
    def get_input(*args):
        """get_input(Function f) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"""
        return _casadi.SX_get_input(*args)

    if _newclass:get_input = staticmethod(get_input)
    __swig_getmethods__["get_input"] = lambda x: get_input
    def jac(*args):
        """
        jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> SX
        jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> SX
        jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> SX
        jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
            bool symmetric=False) -> SX

        Jacobian expression.


        """
        return _casadi.SX_jac(*args)

    if _newclass:jac = staticmethod(jac)
    __swig_getmethods__["jac"] = lambda x: jac
    def grad(*args):
        """
        grad(Function f, int iind=0, int oind=0) -> SX
        grad(Function f, std::string const & iname, int oind=0) -> SX
        grad(Function f, int iind, std::string const & oname) -> SX
        grad(Function f, std::string const & iname, std::string const & oname) -> SX

        Gradient expression.


        """
        return _casadi.SX_grad(*args)

    if _newclass:grad = staticmethod(grad)
    __swig_getmethods__["grad"] = lambda x: grad
    def tang(*args):
        """
        tang(Function f, int iind=0, int oind=0) -> SX
        tang(Function f, std::string const & iname, int oind=0) -> SX
        tang(Function f, int iind, std::string const & oname) -> SX
        tang(Function f, std::string const & iname, std::string const & oname) -> SX

        Tangent expression.


        """
        return _casadi.SX_tang(*args)

    if _newclass:tang = staticmethod(tang)
    __swig_getmethods__["tang"] = lambda x: tang
    def hess(*args):
        """
        hess(Function f, int iind=0, int oind=0) -> SX
        hess(Function f, std::string const & iname, int oind=0) -> SX
        hess(Function f, int iind, std::string const & oname) -> SX
        hess(Function f, std::string const & iname, std::string const & oname) -> SX

        Hessian expression


        """
        return _casadi.SX_hess(*args)

    if _newclass:hess = staticmethod(hess)
    __swig_getmethods__["hess"] = lambda x: hess
    def type_name(*args):
        """type_name() -> std::string"""
        return _casadi.SX_type_name(*args)

    if _newclass:type_name = staticmethod(type_name)
    __swig_getmethods__["type_name"] = lambda x: type_name
    def print_split(self, *args):
        """
        print_split(SX self)

        Get strings corresponding to the nonzeros and the interdependencies.


        """
        return _casadi.SX_print_split(self, *args)

    def print_scalar(self, *args):
        """
        print_scalar(SX self, bool trailing_newline=True)

        Print scalar.


        """
        return _casadi.SX_print_scalar(self, *args)

    def print_vector(self, *args):
        """
        print_vector(SX self, bool trailing_newline=True)

        Print vector-style.


        """
        return _casadi.SX_print_vector(self, *args)

    def print_dense(self, *args):
        """
        print_dense(SX self, bool trailing_newline=True)

        Print dense matrix-stype.


        """
        return _casadi.SX_print_dense(self, *args)

    def print_sparse(self, *args):
        """
        print_sparse(SX self, bool trailing_newline=True)

        Print sparse matrix style.


        """
        return _casadi.SX_print_sparse(self, *args)

    def clear(self, *args):
        """clear(SX self)"""
        return _casadi.SX_clear(self, *args)

    def resize(self, *args):
        """resize(SX self, int nrow, int ncol)"""
        return _casadi.SX_resize(self, *args)

    def reserve(self, *args):
        """
        reserve(SX self, int nnz)
        reserve(SX self, int nnz, int ncol)
        """
        return _casadi.SX_reserve(self, *args)

    def erase(self, *args):
        """
        erase(SX self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)
        erase(SX self, std::vector< int,std::allocator< int > > const & rr, bool ind1=False)

        >  void array(Scalar) .erase([int ] rr, [int ] cc, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or
        columns of a matrix.

        >  void array(Scalar) .erase([int ] rr, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase elements of
        a matrix.


        """
        return _casadi.SX_erase(self, *args)

    def remove(self, *args):
        """
        remove(SX self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc)

        Remove columns and rows Remove/delete rows and/or columns of a matrix.


        """
        return _casadi.SX_remove(self, *args)

    def enlarge(self, *args):
        """
        enlarge(SX self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)

        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.


        """
        return _casadi.SX_enlarge(self, *args)

    def sparsity(self, *args):
        """
        sparsity(SX self) -> Sparsity

        Get an owning reference to the sparsity pattern.


        """
        return _casadi.SX_sparsity(self, *args)

    def triplet(*args):
        """
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            SX d) -> SX
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            SX d, int nrow, int ncol) -> SX
        triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
            SX d, std::pair< int,int > const & rc) -> SX
        """
        return _casadi.SX_triplet(*args)

    if _newclass:triplet = staticmethod(triplet)
    __swig_getmethods__["triplet"] = lambda x: triplet
    def inf(*args):
        """
        inf(Sparsity sp) -> SX
        inf(int nrow=1, int ncol=1) -> SX
        inf(std::pair< int,int > const & rc) -> SX

        create a matrix with all inf


        """
        return _casadi.SX_inf(*args)

    if _newclass:inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf
    def nan(*args):
        """
        nan(Sparsity sp) -> SX
        nan(int nrow=1, int ncol=1) -> SX
        nan(std::pair< int,int > const & rc) -> SX

        create a matrix with all nan


        """
        return _casadi.SX_nan(*args)

    if _newclass:nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan
    def eye(*args):
        """eye(int ncol) -> SX"""
        return _casadi.SX_eye(*args)

    if _newclass:eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye
    def element_hash(self, *args):
        """
        element_hash(SX self) -> size_t

        Returns a number that is unique for a given symbolic scalar.

        Only defined if symbolic scalar.


        """
        return _casadi.SX_element_hash(self, *args)

    def is_regular(self, *args):
        """
        is_regular(SX self) -> bool

        Checks if expression does not contain NaN or Inf.


        """
        return _casadi.SX_is_regular(self, *args)

    def is_smooth(self, *args):
        """
        is_smooth(SX self) -> bool

        Check if smooth.


        """
        return _casadi.SX_is_smooth(self, *args)

    def is_leaf(self, *args):
        """
        is_leaf(SX self) -> bool

        Check if SX is a leaf of the SX graph.

        Only defined if symbolic scalar.


        """
        return _casadi.SX_is_leaf(self, *args)

    def is_commutative(self, *args):
        """
        is_commutative(SX self) -> bool

        Check whether a binary SX is commutative.

        Only defined if symbolic scalar.


        """
        return _casadi.SX_is_commutative(self, *args)

    def is_symbolic(self, *args):
        """
        is_symbolic(SX self) -> bool

        Check if symbolic (Dense) Sparse matrices invariable return false.


        """
        return _casadi.SX_is_symbolic(self, *args)

    def is_valid_input(self, *args):
        """
        is_valid_input(SX self) -> bool

        Check if matrix can be used to define function inputs. Sparse matrices can
        return true if all non-zero elements are symbolic.


        """
        return _casadi.SX_is_valid_input(self, *args)

    def has_duplicates(self, *args):
        """
        has_duplicates(SX self) -> bool

        [INTERNAL]  Detect
        duplicate symbolic expressions If there are symbolic primitives appearing
        more than once, the function will return true and the names of the duplicate
        expressions will be printed to userOut<true, PL_WARN>(). Note: Will mark the
        node using SXElem::setTemp. Make sure to call resetInput() after usage.


        """
        return _casadi.SX_has_duplicates(self, *args)

    def resetInput(self, *args):
        """
        resetInput(SX self)

        [INTERNAL]  Reset the
        marker for an input expression.


        """
        return _casadi.SX_resetInput(self, *args)

    def is_constant(self, *args):
        """
        is_constant(SX self) -> bool

        Check if the matrix is constant (note that false negative answers are
        possible)


        """
        return _casadi.SX_is_constant(self, *args)

    def is_integer(self, *args):
        """
        is_integer(SX self) -> bool

        Check if the matrix is integer-valued (note that false negative answers are
        possible)


        """
        return _casadi.SX_is_integer(self, *args)

    def is_zero(self, *args):
        """
        is_zero(SX self) -> bool

        check if the matrix is 0 (note that false negative answers are possible)


        """
        return _casadi.SX_is_zero(self, *args)

    def is_one(self, *args):
        """
        is_one(SX self) -> bool

        check if the matrix is 1 (note that false negative answers are possible)


        """
        return _casadi.SX_is_one(self, *args)

    def is_minus_one(self, *args):
        """
        is_minus_one(SX self) -> bool

        check if the matrix is -1 (note that false negative answers are possible)


        """
        return _casadi.SX_is_minus_one(self, *args)

    def is_identity(self, *args):
        """
        is_identity(SX self) -> bool

        check if the matrix is an identity matrix (note that false negative answers
        are possible)


        """
        return _casadi.SX_is_identity(self, *args)

    def has_zeros(self, *args):
        """
        has_zeros(SX self) -> bool

        Check if the matrix has any zero entries which are not structural zeros.


        """
        return _casadi.SX_has_zeros(self, *args)

    def nonzeros(self, *args):
        """
        nonzeros(SX self) -> std::vector< casadi::SXElem,std::allocator< casadi::SXElem > >

        [INTERNAL]  Get all
        nonzeros.


        """
        return _casadi.SX_nonzeros(self, *args)

    def __float__(self, *args):
        """__float__(SX self) -> double"""
        return _casadi.SX___float__(self, *args)

    def __int__(self, *args):
        """__int__(SX self) -> int"""
        return _casadi.SX___int__(self, *args)

    def name(self, *args):
        """
        name(SX self) -> std::string

        Get name (only if symbolic scalar)


        """
        return _casadi.SX_name(self, *args)

    def dep(self, *args):
        """
        dep(SX self, int ch=0) -> SX

        Get expressions of the children of the expression Only defined if symbolic
        scalar. Wraps SXElem SXElem::dep(int ch=0) const.


        """
        return _casadi.SX_dep(self, *args)

    def n_dep(self, *args):
        """
        n_dep(SX self) -> int

        Get the number of dependencies of a binary SXElem Only defined if symbolic
        scalar.


        """
        return _casadi.SX_n_dep(self, *args)

    def setPrecision(*args):
        """
        setPrecision(int precision)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.SX_setPrecision(*args)

    if _newclass:setPrecision = staticmethod(setPrecision)
    __swig_getmethods__["setPrecision"] = lambda x: setPrecision
    def setWidth(*args):
        """
        setWidth(int width)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.SX_setWidth(*args)

    if _newclass:setWidth = staticmethod(setWidth)
    __swig_getmethods__["setWidth"] = lambda x: setWidth
    def setScientific(*args):
        """
        setScientific(bool scientific)

        Set the 'precision, width & scientific' used in printing and serializing to
        streams.


        """
        return _casadi.SX_setScientific(*args)

    if _newclass:setScientific = staticmethod(setScientific)
    __swig_getmethods__["setScientific"] = lambda x: setScientific
    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)


    __array_priority__ = 1001.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()


    def __init__(self, *args): 
        """
        __init__(casadi::Matrix<(casadi::SXElem)> self) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, SX m) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, int nrow, int ncol) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, Sparsity sp) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, Sparsity sp, SX d) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, double val) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & m) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, IM x) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, std::vector< int,std::allocator< int > > const & x) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, DM x) -> SX
        __init__(casadi::Matrix<(casadi::SXElem)> self, std::vector< double,std::allocator< double > > const & x) -> SX

        >  array(Scalar) ()
        ------------------------------------------------------------------------

        constructors

        empty 0-by-0 matrix constructor

        >  array(Scalar) (array(Scalar) m)
        ------------------------------------------------------------------------

        Copy constructor.

        >  array(Scalar) (int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a sparse matrix with all structural zeros.

        >  array(Scalar) (Sparsity sp)
        ------------------------------------------------------------------------

        Create a sparse matrix from a sparsity pattern. Same as
        Matrix::ones(sparsity)

        >  array(Scalar) (Sparsity sp, array(Scalar) d)
        ------------------------------------------------------------------------

        Construct matrix with a given sparsity and nonzeros.

        >  array(Scalar) (double val)
        ------------------------------------------------------------------------

        This constructor enables implicit type conversion from a numeric type.

        >  array(Scalar) ([[double ] ] m)
        ------------------------------------------------------------------------

        Dense matrix constructor with data given as vector of vectors.

        >  array(Scalar) (array(A) x)
        ------------------------------------------------------------------------

        Create a matrix from another matrix with a different entry type Assumes that
        the scalar conversion is valid.

        >  array(Scalar) ([A ] x)
        ------------------------------------------------------------------------

        Create an expression from a vector.

        >  array(Scalar) ([Scalar ] x)

        >  array(Scalar) ((int,int) rc)

        >  array(Scalar) (Sparsity sp, Scalar val, bool dummy)

        >  array(Scalar) (Sparsity sp, [Scalar ] d, bool dummy)
        ------------------------------------------------------------------------
        [INTERNAL] 

        """
        this = _casadi.new_SX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_SX
SX_swigregister = _casadi.SX_swigregister
SX_swigregister(SX)

def SX_binary(*args):
  """
    SX_binary(int op, SX x, SX y) -> SX

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.SX_binary(*args)

def SX_unary(*args):
  """
    SX_unary(int op, SX x) -> SX

    [INTERNAL]  Create nodes by
    their ID.


    """
  return _casadi.SX_unary(*args)

def SX_scalar_matrix(*args):
  """
    SX_scalar_matrix(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.SX_scalar_matrix(*args)

def SX_matrix_scalar(*args):
  """
    SX_matrix_scalar(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.SX_matrix_scalar(*args)

def SX_matrix_matrix(*args):
  """
    SX_matrix_matrix(int op, SX x, SX y) -> SX

    [INTERNAL]  Create
    nodes by their ID.


    """
  return _casadi.SX_matrix_matrix(*args)

def SX_setEqualityCheckingDepth(*args):
  """SX_setEqualityCheckingDepth(int eq_depth=1)"""
  return _casadi.SX_setEqualityCheckingDepth(*args)

def SX_getEqualityCheckingDepth(*args):
  """SX_getEqualityCheckingDepth() -> int"""
  return _casadi.SX_getEqualityCheckingDepth(*args)

def SX_get_input(*args):
  """SX_get_input(Function f) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"""
  return _casadi.SX_get_input(*args)

def SX_jac(*args):
  """
    jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> SX
    jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> SX
    jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> SX
    SX_jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
        bool symmetric=False) -> SX

    Jacobian expression.


    """
  return _casadi.SX_jac(*args)

def SX_grad(*args):
  """
    grad(Function f, int iind=0, int oind=0) -> SX
    grad(Function f, std::string const & iname, int oind=0) -> SX
    grad(Function f, int iind, std::string const & oname) -> SX
    SX_grad(Function f, std::string const & iname, std::string const & oname) -> SX

    Gradient expression.


    """
  return _casadi.SX_grad(*args)

def SX_tang(*args):
  """
    tang(Function f, int iind=0, int oind=0) -> SX
    tang(Function f, std::string const & iname, int oind=0) -> SX
    tang(Function f, int iind, std::string const & oname) -> SX
    SX_tang(Function f, std::string const & iname, std::string const & oname) -> SX

    Tangent expression.


    """
  return _casadi.SX_tang(*args)

def SX_hess(*args):
  """
    hess(Function f, int iind=0, int oind=0) -> SX
    hess(Function f, std::string const & iname, int oind=0) -> SX
    hess(Function f, int iind, std::string const & oname) -> SX
    SX_hess(Function f, std::string const & iname, std::string const & oname) -> SX

    Hessian expression


    """
  return _casadi.SX_hess(*args)

def SX_type_name(*args):
  """SX_type_name() -> std::string"""
  return _casadi.SX_type_name(*args)

def SX_triplet(*args):
  """
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        SX d) -> SX
    triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        SX d, int nrow, int ncol) -> SX
    SX_triplet(std::vector< int,std::allocator< int > > const & row, std::vector< int,std::allocator< int > > const & col, 
        SX d, std::pair< int,int > const & rc) -> SX
    """
  return _casadi.SX_triplet(*args)

def SX_inf(*args):
  """
    inf(Sparsity sp) -> SX
    inf(int nrow=1, int ncol=1) -> SX
    SX_inf(std::pair< int,int > const & rc) -> SX

    create a matrix with all inf


    """
  return _casadi.SX_inf(*args)

def SX_nan(*args):
  """
    nan(Sparsity sp) -> SX
    nan(int nrow=1, int ncol=1) -> SX
    SX_nan(std::pair< int,int > const & rc) -> SX

    create a matrix with all nan


    """
  return _casadi.SX_nan(*args)

def SX_eye(*args):
  """SX_eye(int ncol) -> SX"""
  return _casadi.SX_eye(*args)

def SX_setPrecision(*args):
  """
    SX_setPrecision(int precision)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.SX_setPrecision(*args)

def SX_setWidth(*args):
  """
    SX_setWidth(int width)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.SX_setWidth(*args)

def SX_setScientific(*args):
  """
    SX_setScientific(bool scientific)

    Set the 'precision, width & scientific' used in printing and serializing to
    streams.


    """
  return _casadi.SX_setScientific(*args)

class MX(ExpMX,GenMX,SharedObject):
    """
    MX - Matrix expression.

    The MX class is used to build up trees made up from MXNodes. It is a more
    general graph representation than the scalar expression, SX, and much less
    efficient for small objects. On the other hand, the class allows much more
    general operations than does SX, in particular matrix valued operations and
    calls to arbitrary differentiable functions.

    The MX class is designed to have identical syntax with the Matrix<> template
    class, and uses Matrix<double> as its internal representation of the values
    at a node. By keeping the syntaxes identical, it is possible to switch from
    one class to the other, as well as inlining MX functions to SXElem
    functions.

    Note that an operation is always "lazy", making a matrix multiplication
    will create a matrix multiplication node, not perform the actual
    multiplication.

    Joel Andersson

    C++ includes: mx.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [ExpMX,GenMX,SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MX, name, value)
    __swig_getmethods__ = {}
    for _s in [ExpMX,GenMX,SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MX, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::MX self) -> MX
        __init__(casadi::MX self, int nrow, int ncol) -> MX
        __init__(casadi::MX self, Sparsity sp) -> MX
        __init__(casadi::MX self, Sparsity sp, MX val) -> MX
        __init__(casadi::MX self, double x) -> MX
        __init__(casadi::MX self, MX x) -> MX
        __init__(casadi::MX self, std::vector< double,std::allocator< double > > const & x) -> MX
        __init__(casadi::MX self, DM x) -> MX

        >  MX()
        ------------------------------------------------------------------------

        Default constructor.

        >  MX(int nrow, int ncol)
        ------------------------------------------------------------------------

        Create a sparse matrix with all structural zeros.

        >  MX(Sparsity sp)
        ------------------------------------------------------------------------

        Create a sparse matrix from a sparsity pattern. Same as MX::ones(sparsity)

        >  MX(Sparsity sp, MX val)
        ------------------------------------------------------------------------

        Construct matrix with a given sparsity and nonzeros.

        >  MX(double x)
        ------------------------------------------------------------------------

        Create scalar constant (also implicit type conversion)

        >  MX(MX x)
        ------------------------------------------------------------------------

        Copy constructor.

        >  MX([double ] x)
        ------------------------------------------------------------------------

        Create vector constant (also implicit type conversion)

        >  MX(DM x)
        ------------------------------------------------------------------------

        Create sparse matrix constant (also implicit type conversion)


        """
        this = _casadi.new_MX(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_MX
    def __nonzero__(self, *args):
        """
        __nonzero__(MX self) -> bool

        Returns the truth value of an MX expression.


        """
        return _casadi.MX___nonzero__(self, *args)

    def sparsity(self, *args):
        """
        sparsity(MX self) -> Sparsity

        Get an owning reference to the sparsity pattern.


        """
        return _casadi.MX_sparsity(self, *args)

    def erase(self, *args):
        """
        erase(MX self, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)
        erase(MX self, std::vector< int,std::allocator< int > > const & rr, bool ind1=False)

        >  void MX.erase([int ] rr, [int ] cc, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase rows and/or
        columns of a matrix.

        >  void MX.erase([int ] rr, bool ind1=false)
        ------------------------------------------------------------------------

        Erase a submatrix (leaving structural zeros in its place) Erase elements of
        a matrix.


        """
        return _casadi.MX_erase(self, *args)

    def enlarge(self, *args):
        """
        enlarge(MX self, int nrow, int ncol, std::vector< int,std::allocator< int > > const & rr, std::vector< int,std::allocator< int > > const & cc, 
            bool ind1=False)

        Enlarge matrix Make the matrix larger by inserting empty rows and columns,
        keeping the existing non-zeros.


        """
        return _casadi.MX_enlarge(self, *args)

    def __neg__(self, *args):
        """__neg__(MX self) -> MX"""
        return _casadi.MX___neg__(self, *args)

    def dep(self, *args):
        """
        dep(MX self, int ch=0) -> MX

        Get the nth dependency as MX.


        """
        return _casadi.MX_dep(self, *args)

    def n_out(self, *args):
        """
        n_out(MX self) -> int

        Number of outputs.


        """
        return _casadi.MX_n_out(self, *args)

    def getOutput(self, *args):
        """
        getOutput(MX self, int oind=0) -> MX

        Get an output.


        """
        return _casadi.MX_getOutput(self, *args)

    def n_dep(self, *args):
        """
        n_dep(MX self) -> int

        Get the number of dependencies of a binary SXElem.


        """
        return _casadi.MX_n_dep(self, *args)

    def name(self, *args):
        """
        name(MX self) -> std::string

        Get the name.


        """
        return _casadi.MX_name(self, *args)

    def __float__(self, *args):
        """__float__(MX self) -> double"""
        return _casadi.MX___float__(self, *args)

    def to_DM(self, *args):
        """to_DM(MX self) -> DM"""
        return _casadi.MX_to_DM(self, *args)

    def is_symbolic(self, *args):
        """
        is_symbolic(MX self) -> bool

        Check if symbolic.


        """
        return _casadi.MX_is_symbolic(self, *args)

    def is_constant(self, *args):
        """
        is_constant(MX self) -> bool

        Check if constant.


        """
        return _casadi.MX_is_constant(self, *args)

    def is_call(self, *args):
        """
        is_call(MX self) -> bool

        Check if evaluation.


        """
        return _casadi.MX_is_call(self, *args)

    def is_output(self, *args):
        """
        is_output(MX self) -> bool

        Check if evaluation output.


        """
        return _casadi.MX_is_output(self, *args)

    def get_output(self, *args):
        """
        get_output(MX self) -> int

        Get the index of evaluation output - only valid when is_calloutput() is
        true.


        """
        return _casadi.MX_get_output(self, *args)

    def is_op(self, *args):
        """
        is_op(MX self, int op) -> bool

        Is it a certain operation.


        """
        return _casadi.MX_is_op(self, *args)

    def is_multiplication(self, *args):
        """
        is_multiplication(MX self) -> bool

        Check if multiplication.


        """
        return _casadi.MX_is_multiplication(self, *args)

    def is_commutative(self, *args):
        """
        is_commutative(MX self) -> bool

        Check if commutative operation.


        """
        return _casadi.MX_is_commutative(self, *args)

    def is_norm(self, *args):
        """
        is_norm(MX self) -> bool

        Check if norm.


        """
        return _casadi.MX_is_norm(self, *args)

    def is_valid_input(self, *args):
        """
        is_valid_input(MX self) -> bool

        Check if matrix can be used to define function inputs. Valid inputs for
        MXFunctions are combinations of Reshape, concatenations and SymbolicMX.


        """
        return _casadi.MX_is_valid_input(self, *args)

    def n_primitives(self, *args):
        """
        n_primitives(MX self) -> int

        Get the number of symbolic primitive Assumes is_valid_input() returns true.


        """
        return _casadi.MX_n_primitives(self, *args)

    def primitives(self, *args):
        """
        primitives(MX self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >

        Get symbolic primitives.


        """
        return _casadi.MX_primitives(self, *args)

    def split_primitives(self, *args):
        """
        split_primitives(MX self, MX x) -> std::vector< casadi::MX,std::allocator< casadi::MX > >

        Split up an expression along symbolic primitives.


        """
        return _casadi.MX_split_primitives(self, *args)

    def join_primitives(self, *args):
        """
        join_primitives(MX self, std::vector< casadi::MX,std::allocator< casadi::MX > > & v) -> MX

        Join an expression along symbolic primitives.


        """
        return _casadi.MX_join_primitives(self, *args)

    def has_duplicates(self, *args):
        """
        has_duplicates(MX self) -> bool

        [INTERNAL]  Detect
        duplicate symbolic expressions If there are symbolic primitives appearing
        more than once, the function will return true and the names of the duplicate
        expressions will be printed to userOut<true, PL_WARN>(). Note: Will mark the
        node using MX::setTemp. Make sure to call resetInput() after usage.


        """
        return _casadi.MX_has_duplicates(self, *args)

    def resetInput(self, *args):
        """
        resetInput(MX self)

        [INTERNAL]  Reset the marker
        for an input expression.


        """
        return _casadi.MX_resetInput(self, *args)

    def is_identity(self, *args):
        """
        is_identity(MX self) -> bool

        check if identity


        """
        return _casadi.MX_is_identity(self, *args)

    def is_zero(self, *args):
        """
        is_zero(MX self) -> bool

        check if zero (note that false negative answers are possible)


        """
        return _casadi.MX_is_zero(self, *args)

    def is_one(self, *args):
        """
        is_one(MX self) -> bool

        check if zero (note that false negative answers are possible)


        """
        return _casadi.MX_is_one(self, *args)

    def is_minus_one(self, *args):
        """
        is_minus_one(MX self) -> bool

        check if zero (note that false negative answers are possible)


        """
        return _casadi.MX_is_minus_one(self, *args)

    def is_transpose(self, *args):
        """
        is_transpose(MX self) -> bool

        Is the expression a transpose?


        """
        return _casadi.MX_is_transpose(self, *args)

    def is_regular(self, *args):
        """
        is_regular(MX self) -> bool

        Checks if expression does not contain NaN or Inf.


        """
        return _casadi.MX_is_regular(self, *args)

    def numFunctions(self, *args):
        """
        numFunctions(MX self) -> int

        Number of functions.


        """
        return _casadi.MX_numFunctions(self, *args)

    def getFunction(self, *args):
        """
        getFunction(MX self, int i=0) -> Function

        Get function.


        """
        return _casadi.MX_getFunction(self, *args)

    def is_binary(self, *args):
        """
        is_binary(MX self) -> bool

        Is binary operation.


        """
        return _casadi.MX_is_binary(self, *args)

    def is_unary(self, *args):
        """
        is_unary(MX self) -> bool

        Is unary operation.


        """
        return _casadi.MX_is_unary(self, *args)

    def op(self, *args):
        """
        op(MX self) -> int

        Get operation type.


        """
        return _casadi.MX_op(self, *args)

    def getTemp(self, *args):
        """
        getTemp(MX self) -> int

        [INTERNAL]  Get the temporary
        variable


        """
        return _casadi.MX_getTemp(self, *args)

    def setTemp(self, *args):
        """
        setTemp(MX self, int t)

        [INTERNAL]  Set the temporary
        variable.


        """
        return _casadi.MX_setTemp(self, *args)

    def binary(*args):
        """
        binary(int op, MX x, MX y) -> MX

        Create nodes by their ID.


        """
        return _casadi.MX_binary(*args)

    if _newclass:binary = staticmethod(binary)
    __swig_getmethods__["binary"] = lambda x: binary
    def unary(*args):
        """
        unary(int op, MX x) -> MX

        Create nodes by their ID.


        """
        return _casadi.MX_unary(*args)

    if _newclass:unary = staticmethod(unary)
    __swig_getmethods__["unary"] = lambda x: unary
    def inf(*args):
        """
        inf(Sparsity sp) -> MX
        inf(int nrow=1, int ncol=1) -> MX
        inf(std::pair< int,int > const & rc) -> MX

        create a matrix with all inf


        """
        return _casadi.MX_inf(*args)

    if _newclass:inf = staticmethod(inf)
    __swig_getmethods__["inf"] = lambda x: inf
    def nan(*args):
        """
        nan(Sparsity sp) -> MX
        nan(int nrow=1, int ncol=1) -> MX
        nan(std::pair< int,int > const & rc) -> MX

        create a matrix with all nan


        """
        return _casadi.MX_nan(*args)

    if _newclass:nan = staticmethod(nan)
    __swig_getmethods__["nan"] = lambda x: nan
    def eye(*args):
        """eye(int ncol) -> MX"""
        return _casadi.MX_eye(*args)

    if _newclass:eye = staticmethod(eye)
    __swig_getmethods__["eye"] = lambda x: eye
    def get(self, *args):
        """
        get(MX self, bool ind1, Slice rr)
        get(MX self, bool ind1, IM rr)
        get(MX self, bool ind1, Sparsity sp)
        get(MX self, bool ind1, Slice rr, Slice cc)
        get(MX self, bool ind1, Slice rr, IM cc)
        get(MX self, bool ind1, IM rr, Slice cc)
        get(MX self, bool ind1, IM rr, IM cc)

        >  void MX.get(MX &output_m, bool ind1, Slice rr) const

        >  void MX.get(MX &output_m, bool ind1, IM rr) const

        >  void MX.get(MX &output_m, bool ind1, Sparsity sp) const 
        ------------------------------------------------------------------------

        Get a submatrix, single argument

        >  void MX.get(MX &output_m, bool ind1, Slice rr, Slice cc) const

        >  void MX.get(MX &output_m, bool ind1, Slice rr, IM cc) const

        >  void MX.get(MX &output_m, bool ind1, IM rr, Slice cc) const

        >  void MX.get(MX &output_m, bool ind1, IM rr, IM cc) const 
        ------------------------------------------------------------------------

        Get a submatrix, two arguments


        """
        return _casadi.MX_get(self, *args)

    def set(self, *args):
        """
        set(MX self, MX m, bool ind1, Slice rr)
        set(MX self, MX m, bool ind1, IM rr)
        set(MX self, MX m, bool ind1, Sparsity sp)
        set(MX self, MX m, bool ind1, Slice rr, Slice cc)
        set(MX self, MX m, bool ind1, Slice rr, IM cc)
        set(MX self, MX m, bool ind1, IM rr, Slice cc)
        set(MX self, MX m, bool ind1, IM rr, IM cc)

        >  void MX.set(MX m, bool ind1, Slice rr)

        >  void MX.set(MX m, bool ind1, IM rr)

        >  void MX.set(MX m, bool ind1, Sparsity sp)
        ------------------------------------------------------------------------

        Set a submatrix, single argument


        """
        return _casadi.MX_set(self, *args)

    def get_nz(self, *args):
        """
        get_nz(MX self, bool ind1, Slice kk)
        get_nz(MX self, bool ind1, IM kk)

        Get a set of nonzeros


        """
        return _casadi.MX_get_nz(self, *args)

    def set_nz(self, *args):
        """
        set_nz(MX self, MX m, bool ind1, Slice kk)
        set_nz(MX self, MX m, bool ind1, IM kk)

        Set a set of nonzeros


        """
        return _casadi.MX_set_nz(self, *args)

    def printme(self, *args):
        """printme(MX self, MX y) -> MX"""
        return _casadi.MX_printme(self, *args)

    def attachAssert(self, *args):
        """
        attachAssert(MX self, MX y, std::string const & fail_message="") -> MX

        returns itself, but with an assertion attached

        If y does not evaluate to 1, a runtime error is raised


        """
        return _casadi.MX_attachAssert(self, *args)

    def monitor(self, *args):
        """
        monitor(MX self, std::string const & comment) -> MX

        Monitor an expression Returns itself, but with the side effect of printing
        the nonzeros along with a comment.


        """
        return _casadi.MX_monitor(self, *args)

    def mapping(self, *args):
        """
        mapping(MX self) -> IM

        Get an IM representation of a GetNonzeros or SetNonzeros node.


        """
        return _casadi.MX_mapping(self, *args)

    def setEqualityCheckingDepth(*args):
        """setEqualityCheckingDepth(int eq_depth=1)"""
        return _casadi.MX_setEqualityCheckingDepth(*args)

    if _newclass:setEqualityCheckingDepth = staticmethod(setEqualityCheckingDepth)
    __swig_getmethods__["setEqualityCheckingDepth"] = lambda x: setEqualityCheckingDepth
    def getEqualityCheckingDepth(*args):
        """getEqualityCheckingDepth() -> int"""
        return _casadi.MX_getEqualityCheckingDepth(*args)

    if _newclass:getEqualityCheckingDepth = staticmethod(getEqualityCheckingDepth)
    __swig_getmethods__["getEqualityCheckingDepth"] = lambda x: getEqualityCheckingDepth
    def test_cast(*args):
        """test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi.MX_test_cast(*args)

    if _newclass:test_cast = staticmethod(test_cast)
    __swig_getmethods__["test_cast"] = lambda x: test_cast
    def get_input(*args):
        """get_input(Function f) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"""
        return _casadi.MX_get_input(*args)

    if _newclass:get_input = staticmethod(get_input)
    __swig_getmethods__["get_input"] = lambda x: get_input
    def type_name(*args):
        """type_name() -> std::string"""
        return _casadi.MX_type_name(*args)

    if _newclass:type_name = staticmethod(type_name)
    __swig_getmethods__["type_name"] = lambda x: type_name
    def jac(*args):
        """
        jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> MX
        jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> MX
        jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> MX
        jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
            bool symmetric=False) -> MX

        Jacobian expression.


        """
        return _casadi.MX_jac(*args)

    if _newclass:jac = staticmethod(jac)
    __swig_getmethods__["jac"] = lambda x: jac
    def grad(*args):
        """
        grad(Function f, int iind=0, int oind=0) -> MX
        grad(Function f, std::string const & iname, int oind=0) -> MX
        grad(Function f, int iind, std::string const & oname) -> MX
        grad(Function f, std::string const & iname, std::string const & oname) -> MX

        Gradient expression.


        """
        return _casadi.MX_grad(*args)

    if _newclass:grad = staticmethod(grad)
    __swig_getmethods__["grad"] = lambda x: grad
    def tang(*args):
        """
        tang(Function f, int iind=0, int oind=0) -> MX
        tang(Function f, std::string const & iname, int oind=0) -> MX
        tang(Function f, int iind, std::string const & oname) -> MX
        tang(Function f, std::string const & iname, std::string const & oname) -> MX

        Tangent expression.


        """
        return _casadi.MX_tang(*args)

    if _newclass:tang = staticmethod(tang)
    __swig_getmethods__["tang"] = lambda x: tang
    @property
    def shape(self):
        return (self.size1(),self.size2())

    def reshape(self,arg):
        return _casadi.reshape(self,arg)

    @property
    def T(self):
        return _casadi.transpose(self)

    def __getitem__(self, s):
          if isinstance(s, tuple) and len(s)==2:
            if s[1] is None: raise TypeError("Cannot slice with None")
            return self.get(False, s[0], s[1])
          return self.get(False, s)

    def __setitem__(self,s,val):
          if isinstance(s,tuple) and len(s)==2:
            return self.set(val, False, s[0], s[1])
          return self.set(val, False, s)

    @property
    def nz(self):
      return NZproxy(self)


    __array_priority__ = 1002.0

    def __array_wrap__(self,out_arr,context=None):
      if context is None:
        return out_arr
      name = context[0].__name__
      args = list(context[1])

      if len(context[1])==3:
        raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b' where 'a' is a numpy type. This is not supported, and cannot be supported without changing numpy." % name)

      if "vectorized" in name:
          name = name[:-len(" (vectorized)")]

      conversion = {"multiply": "mul", "divide": "div", "true_divide": "div", "subtract":"sub","power":"pow","greater_equal":"ge","less_equal": "le", "less": "lt", "greater": "gt"}
      if name in conversion:
        name = conversion[name]
      if len(context[1])==2 and context[1][1] is self and not(context[1][0] is self):
        name = 'r' + name
        args.reverse()
      if not(hasattr(self,name)) or ('mul' in name):
        name = '__' + name + '__'
      fun=getattr(self, name)
      return fun(*args[1:])


    def __array__(self,*args,**kwargs):
      import numpy as n
      if len(args) > 1 and isinstance(args[1],tuple) and isinstance(args[1][0],n.ufunc) and isinstance(args[1][0],n.ufunc) and len(args[1])>1 and args[1][0].nin==len(args[1][1]):
        if len(args[1][1])==3:
          raise Exception("Error with %s. Looks like you are using an assignment operator, such as 'a+=b'. This is not supported when 'a' is a numpy type, and cannot be supported without changing numpy itself. Either upgrade a to a CasADi type first, or use 'a = a + b'. " % args[1][0].__name__)
        return n.array([n.nan])
      else:
        if hasattr(self,'__array_custom__'):
          return self.__array_custom__(*args,**kwargs)
        else:
          return self.full()


MX_swigregister = _casadi.MX_swigregister
MX_swigregister(MX)

def MX_binary(*args):
  """
    MX_binary(int op, MX x, MX y) -> MX

    Create nodes by their ID.


    """
  return _casadi.MX_binary(*args)

def MX_unary(*args):
  """
    MX_unary(int op, MX x) -> MX

    Create nodes by their ID.


    """
  return _casadi.MX_unary(*args)

def MX_inf(*args):
  """
    inf(Sparsity sp) -> MX
    inf(int nrow=1, int ncol=1) -> MX
    MX_inf(std::pair< int,int > const & rc) -> MX

    create a matrix with all inf


    """
  return _casadi.MX_inf(*args)

def MX_nan(*args):
  """
    nan(Sparsity sp) -> MX
    nan(int nrow=1, int ncol=1) -> MX
    MX_nan(std::pair< int,int > const & rc) -> MX

    create a matrix with all nan


    """
  return _casadi.MX_nan(*args)

def MX_eye(*args):
  """MX_eye(int ncol) -> MX"""
  return _casadi.MX_eye(*args)

def MX_setEqualityCheckingDepth(*args):
  """MX_setEqualityCheckingDepth(int eq_depth=1)"""
  return _casadi.MX_setEqualityCheckingDepth(*args)

def MX_getEqualityCheckingDepth(*args):
  """MX_getEqualityCheckingDepth() -> int"""
  return _casadi.MX_getEqualityCheckingDepth(*args)

def MX_test_cast(*args):
  """MX_test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
  return _casadi.MX_test_cast(*args)

def MX_get_input(*args):
  """MX_get_input(Function f) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"""
  return _casadi.MX_get_input(*args)

def MX_type_name(*args):
  """MX_type_name() -> std::string"""
  return _casadi.MX_type_name(*args)

def MX_jac(*args):
  """
    jac(Function f, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> MX
    jac(Function f, std::string const & iname, int oind=0, bool compact=False, bool symmetric=False) -> MX
    jac(Function f, int iind, std::string const & oname, bool compact=False, bool symmetric=False) -> MX
    MX_jac(Function f, std::string const & iname, std::string const & oname, bool compact=False, 
        bool symmetric=False) -> MX

    Jacobian expression.


    """
  return _casadi.MX_jac(*args)

def MX_grad(*args):
  """
    grad(Function f, int iind=0, int oind=0) -> MX
    grad(Function f, std::string const & iname, int oind=0) -> MX
    grad(Function f, int iind, std::string const & oname) -> MX
    MX_grad(Function f, std::string const & iname, std::string const & oname) -> MX

    Gradient expression.


    """
  return _casadi.MX_grad(*args)

def MX_tang(*args):
  """
    tang(Function f, int iind=0, int oind=0) -> MX
    tang(Function f, std::string const & iname, int oind=0) -> MX
    tang(Function f, int iind, std::string const & oname) -> MX
    MX_tang(Function f, std::string const & iname, std::string const & oname) -> MX

    Tangent expression.


    """
  return _casadi.MX_tang(*args)

def attach_return_type(f,t):
  if not(hasattr(f,'func_annotations')):
    f.func_annotations = {}
  if not(isinstance(getattr(f,'func_annotations'),dict)):
    raise Exception("Cannot annotate this python Method to be a sparsitygenerator. Method has func_annotations attribute with unknown type.")
  f.func_annotations["return"] = t
  return f

def pyevaluate(f):
  return attach_return_type(f,None)

def pycallback(f):
  return attach_return_type(f,int)


def pyfunction(inputs,outputs):
  def wrap(f):

    @pyevaluate
    def fcustom(f2):
      res = f([f2.getInput(i) for i in range(f2.n_in())])
      if not isinstance(res,list):
        res = [res]
      for i in range(f2.n_out()):
        f2.setOutput(res[i],i)
    import warnings

    with warnings.catch_warnings():
      warnings.filterwarnings("ignore",category=DeprecationWarning)
      Fun = CustomFunction("CustomFunction",fcustom,inputs,outputs)
      return Fun

  return wrap

def PyFunction(name, obj, inputs, outputs, opts={}):
    @pyevaluate
    def fcustom(f):
      res = [f.getOutput(i) for i in range(f.n_out())]
      obj.evaluate([f.getInput(i) for i in range(f.n_in())],res)
      for i in range(f.n_out()): f.setOutput(res[i], i)

    import warnings

    with warnings.catch_warnings():
      warnings.filterwarnings("ignore",category=DeprecationWarning)
      return CustomFunction("CustomFunction", fcustom,
                            inputs, outputs, opts)


class Function(SharedObject):
    """
    General function.

    A general function $f$ in casadi can be multi-input, multi-output. Number of
    inputs: nin n_in() Number of outputs: nout n_out()  We can view this
    function as a being composed of a ( nin, nout) grid of single-input, single-
    output primitive functions. Each such primitive function $f_ {i, j}
    \\forall i \\in [0, nin-1], j \\in [0, nout-1]$ can map as $\\mathbf
    {R}^{n, m}\\to\\mathbf{R}^{p, q}$, in which n, m, p, q can take
    different values for every (i, j) pair.  When passing input, you specify
    which partition $i$ is active. You pass the numbers vectorized, as a vector
    of size $(n*m)$. When requesting output, you specify which partition $j$ is
    active. You get the numbers vectorized, as a vector of size $(p*q)$.  To
    calculate Jacobians, you need to have $(m=1, q=1)$.

    Write the Jacobian as $J_ {i, j} = \\nabla f_{i, j} = \\frac
    {\\partial f_{i, j}(\\vec{x})}{\\partial \\vec{x}}$.

    We have the following relationships for function mapping from a row vector
    to a row vector:

    $ \\vec {s}_f = \\nabla f_{i, j} . \\vec{v}$ $ \\vec {s}_a =
    (\\nabla f_{i, j})^T . \\vec{w}$

    Some quantities in these formulas must be transposed: input col: transpose $
    \\vec {v} $ and $\\vec{s}_a$ output col: transpose $ \\vec {w} $ and
    $\\vec{s}_f$  NOTE: Functions are allowed to modify their input arguments
    when evaluating: implicitFunction, IDAS solver Further releases may disallow
    this.

    Joel Andersson

    C++ includes: function.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Function, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Function, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_Function
    def expand(self, *args):
        """
        expand(Function self) -> Function
        expand(Function self, std::string const & name, casadi::Dict const & opts=casadi::Dict()) -> Function

        Expand a function to SX.


        """
        return _casadi.Function_expand(self, *args)

    def n_in(self, *args):
        """
        n_in(Function self) -> int

        Get the number of function inputs.


        """
        return _casadi.Function_n_in(self, *args)

    def n_out(self, *args):
        """
        n_out(Function self) -> int

        Get the number of function outputs.


        """
        return _casadi.Function_n_out(self, *args)

    def size1_in(self, *args):
        """
        size1_in(Function self, int ind) -> int
        size1_in(Function self, std::string const & iname) -> int

        Get input dimension.


        """
        return _casadi.Function_size1_in(self, *args)

    def size2_in(self, *args):
        """
        size2_in(Function self, int ind) -> int
        size2_in(Function self, std::string const & iname) -> int

        Get input dimension.


        """
        return _casadi.Function_size2_in(self, *args)

    def size_in(self, *args):
        """
        size_in(Function self, int ind) -> std::pair< int,int >
        size_in(Function self, std::string const & iname) -> std::pair< int,int >

        Get input dimension.


        """
        return _casadi.Function_size_in(self, *args)

    def size1_out(self, *args):
        """
        size1_out(Function self, int ind) -> int
        size1_out(Function self, std::string const & oname) -> int

        Get output dimension.


        """
        return _casadi.Function_size1_out(self, *args)

    def size2_out(self, *args):
        """
        size2_out(Function self, int ind) -> int
        size2_out(Function self, std::string const & oname) -> int

        Get output dimension.


        """
        return _casadi.Function_size2_out(self, *args)

    def size_out(self, *args):
        """
        size_out(Function self, int ind) -> std::pair< int,int >
        size_out(Function self, std::string const & oname) -> std::pair< int,int >

        Get output dimension.


        """
        return _casadi.Function_size_out(self, *args)

    def nnz_in(self, *args):
        """
        nnz_in(Function self) -> int
        nnz_in(Function self, int ind) -> int
        nnz_in(Function self, std::string const & iname) -> int

        Get of number of input nonzeros For a particular input or for all for all of
        the inputs.


        """
        return _casadi.Function_nnz_in(self, *args)

    def nnz_out(self, *args):
        """
        nnz_out(Function self) -> int
        nnz_out(Function self, int ind) -> int
        nnz_out(Function self, std::string const & oname) -> int

        Get of number of output nonzeros For a particular output or for all for all
        of the outputs.


        """
        return _casadi.Function_nnz_out(self, *args)

    def numel_in(self, *args):
        """
        numel_in(Function self) -> int
        numel_in(Function self, int ind) -> int
        numel_in(Function self, std::string const & iname) -> int

        Get of number of input elements For a particular input or for all for all of
        the inputs.


        """
        return _casadi.Function_numel_in(self, *args)

    def numel_out(self, *args):
        """
        numel_out(Function self) -> int
        numel_out(Function self, int ind) -> int
        numel_out(Function self, std::string const & oname) -> int

        Get of number of output elements For a particular output or for all for all
        of the outputs.


        """
        return _casadi.Function_numel_out(self, *args)

    def name_in(self, *args):
        """
        name_in(Function self) -> std::vector< std::string,std::allocator< std::string > >
        name_in(Function self, int ind) -> std::string

        >  [str] Function.name_in() const 
        ------------------------------------------------------------------------

        Get input scheme.

        >  str Function.name_in(int ind) const 
        ------------------------------------------------------------------------

        Get input scheme name by index.


        """
        return _casadi.Function_name_in(self, *args)

    def name_out(self, *args):
        """
        name_out(Function self) -> std::vector< std::string,std::allocator< std::string > >
        name_out(Function self, int ind) -> std::string

        >  [str] Function.name_out() const 
        ------------------------------------------------------------------------

        Get output scheme.

        >  str Function.name_out(int ind) const 
        ------------------------------------------------------------------------

        Get output scheme name by index.


        """
        return _casadi.Function_name_out(self, *args)

    def index_in(self, *args):
        """
        index_in(Function self, std::string const & name) -> int

        Find the index for a string describing a particular entry of an input
        scheme.

        example: schemeEntry("x_opt") -> returns NLPSOL_X if FunctionInternal
        adheres to SCHEME_NLPINput


        """
        return _casadi.Function_index_in(self, *args)

    def index_out(self, *args):
        """
        index_out(Function self, std::string const & name) -> int

        Find the index for a string describing a particular entry of an output
        scheme.

        example: schemeEntry("x_opt") -> returns NLPSOL_X if FunctionInternal
        adheres to SCHEME_NLPINput


        """
        return _casadi.Function_index_out(self, *args)

    def default_in(self, *args):
        """
        default_in(Function self, int ind) -> double

        Get default input value (NOTE: constant reference)


        """
        return _casadi.Function_default_in(self, *args)

    def sparsity_in(self, *args):
        """
        sparsity_in(Function self, int ind) -> Sparsity
        sparsity_in(Function self, std::string const & iname) -> Sparsity

        Get sparsity of a given input.


        """
        return _casadi.Function_sparsity_in(self, *args)

    def sparsity_out(self, *args):
        """
        sparsity_out(Function self, int ind) -> Sparsity
        sparsity_out(Function self, std::string const & iname) -> Sparsity

        Get sparsity of a given output.


        """
        return _casadi.Function_sparsity_out(self, *args)

    def printDimensions(self, *args):
        """
        printDimensions(Function self)

        Print dimensions of inputs and outputs.


        """
        return _casadi.Function_printDimensions(self, *args)

    def printOptions(self, *args):
        """
        printOptions(Function self)

        Print options to a stream.


        """
        return _casadi.Function_printOptions(self, *args)

    def printOption(self, *args):
        """
        printOption(Function self, std::string const & name)

        Print all information there is to know about a certain option.


        """
        return _casadi.Function_printOption(self, *args)

    def jacobian(self, *args):
        """
        jacobian(Function self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, std::string const & iind, int oind=0, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, int iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Function
        jacobian(Function self, std::string const & iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Function

        Generate a Jacobian function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. If
        compact is set to true, only the nonzeros of the input and output
        expressions are considered. If symmetric is set to true, the Jacobian being
        calculated is known to be symmetric (usually a Hessian), which can be
        exploited by the algorithm.

        The generated Jacobian has one more output than the calling function
        corresponding to the Jacobian and the same number of inputs.


        """
        return _casadi.Function_jacobian(self, *args)

    def setJacobian(self, *args):
        """
        setJacobian(Function self, Function jac, int iind=0, int oind=0, bool compact=False)

        Set the Jacobian function of output oind with respect to input iind NOTE:
        Does not take ownership, only weak references to the Jacobians are kept
        internally


        """
        return _casadi.Function_setJacobian(self, *args)

    def gradient(self, *args):
        """
        gradient(Function self, int iind=0, int oind=0) -> Function
        gradient(Function self, std::string const & iind, int oind=0) -> Function
        gradient(Function self, int iind, std::string const & oind) -> Function
        gradient(Function self, std::string const & iind, std::string const & oind) -> Function

        Generate a gradient function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. Note
        that the output must be scalar. In other cases, use the Jacobian instead.


        """
        return _casadi.Function_gradient(self, *args)

    def tangent(self, *args):
        """
        tangent(Function self, int iind=0, int oind=0) -> Function
        tangent(Function self, std::string const & iind, int oind=0) -> Function
        tangent(Function self, int iind, std::string const & oind) -> Function
        tangent(Function self, std::string const & iind, std::string const & oind) -> Function

        Generate a tangent function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The default behavior of this class is defined by the derived class. Note
        that the input must be scalar. In other cases, use the Jacobian instead.


        """
        return _casadi.Function_tangent(self, *args)

    def hessian(self, *args):
        """
        hessian(Function self, int iind=0, int oind=0) -> Function
        hessian(Function self, std::string const & iind, int oind=0) -> Function
        hessian(Function self, int iind, std::string const & oind) -> Function
        hessian(Function self, std::string const & iind, std::string const & oind) -> Function

        Generate a Hessian function of output oind with respect to input iind.

        Parameters:
        -----------

        iind:  The index of the input

        oind:  The index of the output

        The generated Hessian has two more outputs than the calling function
        corresponding to the Hessian and the gradients.


        """
        return _casadi.Function_hessian(self, *args)

    def fullJacobian(self, *args):
        """
        fullJacobian(Function self) -> Function

        Generate a Jacobian function of all the inputs elements with respect to all
        the output elements).


        """
        return _casadi.Function_fullJacobian(self, *args)

    def setFullJacobian(self, *args):
        """
        setFullJacobian(Function self, Function jac)

        Set the Jacobian of all the input nonzeros with respect to all output
        nonzeros NOTE: Does not take ownership, only weak references to the Jacobian
        are kept internally


        """
        return _casadi.Function_setFullJacobian(self, *args)

    def call(self, *args):
        """
        call(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg, bool always_inline=False, 
            bool never_inline=False)
        call(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, bool always_inline=False, 
            bool never_inline=False)
        call(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, bool always_inline=False, 
            bool never_inline=False)
        call(Function self, casadi::DMDict const & arg, bool always_inline=False, bool never_inline=False)
        call(Function self, casadi::SXDict const & arg, bool always_inline=False, bool never_inline=False)
        call(Function self, casadi::MXDict const & arg, bool always_inline=False, bool never_inline=False)

        Evaluate the function symbolically or numerically.


        """
        return _casadi.Function_call(self, *args)

    def mapsum(self, *args):
        """
        mapsum(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::string const & parallelization="serial") -> std::vector< casadi::MX,std::allocator< casadi::MX > >

        Evaluate symbolically in parallel and sum (matrix graph)

        Parameters:
        -----------

        parallelization:  Type of parallelization used: unroll|serial|openmp


        """
        return _casadi.Function_mapsum(self, *args)

    def mapaccum(self, *args):
        """
        mapaccum(Function self, std::string const & name, int n, casadi::Dict const & opts=casadi::Dict()) -> Function
        mapaccum(Function self, std::string const & name, int n, std::vector< int,std::allocator< int > > const & accum_in, 
            std::vector< int,std::allocator< int > > const & accum_out, casadi::Dict const & opts=casadi::Dict()) -> Function

        Create a mapaccumulated version of this function.

        Suppose the function has a signature of:

        ::

             f: (x, u) -> (x_next , y )
          



        The the mapaccumulated version has the signature:

        ::

             F: (x0, U) -> (X , Y )
          
              with
                  U: horzcat([u0, u1, ..., u_(N-1)])
                  X: horzcat([x1, x2, ..., x_N])
                  Y: horzcat([y0, y1, ..., y_(N-1)])
          
              and
                  x1, y0 <- f(x0, u0)
                  x2, y1 <- f(x1, u1)
                  ...
                  x_N, y_(N-1) <- f(x_(N-1), u_(N-1))
          




        """
        return _casadi.Function_mapaccum(self, *args)

    def map(self, *args):
        """
        map(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::string const & parallelization="serial") -> std::vector< casadi::MX,std::allocator< casadi::MX > >
        map(Function self, std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const & arg, 
            std::string const & parallelization="serial") -> std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > >
        map(Function self, std::string const & name, std::string const & parallelization, int n, std::vector< int,std::allocator< int > > const & reduce_in, 
            std::vector< int,std::allocator< int > > const & reduce_out, 
            casadi::Dict const & opts=casadi::Dict()) -> Function
        map(Function self, std::string const & name, std::string const & parallelization, int n, casadi::Dict const & opts=casadi::Dict()) -> Function

        >  Function Function.map(str name, str parallelization, int n, [int ] reduce_in, [int ] reduce_out, Dict opts=Dict())

        >  Function Function.map(str name, str parallelization, int n, Dict opts=Dict())
        ------------------------------------------------------------------------

        Create a mapped version of this function.

        Suppose the function has a signature of:

        ::

             f: (a, p) -> ( s )
          



        The the mapaccumulated version has the signature:

        ::

             F: (A, P) -> (S )
          
              with
                  A: horzcat([a0, a1, ..., a_(N-1)])
                  P: horzcat([p0, p1, ..., p_(N-1)])
                  S: horzcat([s0, s1, ..., s_(N-1)])
              and
                  s0 <- f(a0, p0)
                  s1 <- f(a1, p1)
                  ...
                  s_(N-1) <- f(a_(N-1), p_(N-1))
          



        Parameters:
        -----------

        parallelization:  Type of parallelization used: unroll|serial|openmp

        >  [MX] Function.map([MX ] arg, str parallelization="serial")

        >  std.map<str, MX> Function.map(const std.map< str, MX > &arg, str parallelization="serial")
        ------------------------------------------------------------------------

        Evaluate symbolically in parallel (matrix graph)

        Parameters:
        -----------

        parallelization:  Type of parallelization used: unroll|serial|openmp


        """
        return _casadi.Function_map(self, *args)

    def slice(self, *args):
        """
        slice(Function self, std::vector< int,std::allocator< int > > const & order_in, std::vector< int,std::allocator< int > > const & order_out, 
            casadi::Dict const & opts=casadi::Dict()) -> Function

        returns a new function with a selection of inputs/outputs of the original


        """
        return _casadi.Function_slice(self, *args)

    def conditional(*args):
        """
        conditional(std::string const & name, std::vector< casadi::Function,std::allocator< casadi::Function > > const & f, 
            Function f_def, casadi::Dict const & opts=casadi::Dict()) -> Function
        """
        return _casadi.Function_conditional(*args)

    if _newclass:conditional = staticmethod(conditional)
    __swig_getmethods__["conditional"] = lambda x: conditional
    def if_else(*args):
        """if_else(std::string const & name, Function f_true, Function f_false, casadi::Dict const & opts=casadi::Dict()) -> Function"""
        return _casadi.Function_if_else(*args)

    if _newclass:if_else = staticmethod(if_else)
    __swig_getmethods__["if_else"] = lambda x: if_else
    def kernel_sum(self, *args):
        """
        kernel_sum(Function self, std::string const & name, std::pair< int,int > const & size, double r, int n, casadi::Dict const & opts=casadi::Dict()) -> Function

        kernel_sum Consider a dense matrix V.

        KernelSum computes

        F(V,X) = sum_i sum_j f ( [i;j], V(i,j), X)

        with X: [x;y]

        where the summation is taken for all entries (i,j) that are a distance r
        away from X.

        This function assumes that V is fixed: sensitivities with respect to it are
        not computed.

        This allows for improved speed of evaluation.

        Having V fixed is a common use case: V may be a large bitmap (observation),
        onto which a kernel is fitted.

        Joris Gillis


        """
        return _casadi.Function_kernel_sum(self, *args)

    def derivative(self, *args):
        """
        derivative(Function self, casadi::DMVector const & arg, casadi::DMVectorVector const & fseed, casadi::DMVectorVector const & aseed, 
            bool always_inline=False, bool never_inline=False)
        derivative(Function self, casadi::SXVector const & arg, casadi::SXVectorVector const & fseed, casadi::SXVectorVector const & aseed, 
            bool always_inline=False, bool never_inline=False)
        derivative(Function self, casadi::MXVector const & arg, casadi::MXVectorVector const & fseed, casadi::MXVectorVector const & aseed, 
            bool always_inline=False, bool never_inline=False)
        derivative(Function self, int nfwd, int nadj) -> Function

        >  void Function.derivative([DM] arg, [DM] &output_res, [DMVector] fseed, [DMVector] &output_fsens, [DMVector] aseed, [DMVector] &output_asens, bool always_inline=false, bool never_inline=false)

        >  void Function.derivative([SX] arg, [SX] &output_res, [SXVector] fseed, [SXVector] &output_fsens, [SXVector] aseed, [SXVector] &output_asens, bool always_inline=false, bool never_inline=false)

        >  void Function.derivative([MX] arg, [MX] &output_res, [MXVector] fseed, [MXVector] &output_fsens, [MXVector] aseed, [MXVector] &output_asens, bool always_inline=false, bool never_inline=false)
        ------------------------------------------------------------------------
        [INTERNAL] 
        Evaluate the function symbolically or numerically with directional
        derivatives The first two arguments are the nondifferentiated inputs
        and results of the evaluation, the next two arguments are a set of
        forward directional seeds and the resulting forward directional
        derivatives, the length of the vector being the number of forward
        directions. The next two arguments are a set of adjoint directional
        seeds and the resulting adjoint directional derivatives, the length of
        the vector being the number of adjoint directions.

        >  Function Function.derivative(int nfwd, int nadj)
        ------------------------------------------------------------------------

        Get a function that calculates nfwd forward derivatives and nadj adjoint
        derivatives Legacy function: Use forward and reverse instead.

        Returns a function with (1+nfwd)*n_in+nadj*n_out inputs and (1+nfwd)*n_out +
        nadj*n_in outputs. The first n_in inputs correspond to nondifferentiated
        inputs. The next nfwd*n_in inputs correspond to forward seeds, one direction
        at a time and the last nadj*n_out inputs correspond to adjoint seeds, one
        direction at a time. The first n_out outputs correspond to nondifferentiated
        outputs. The next nfwd*n_out outputs correspond to forward sensitivities,
        one direction at a time and the last nadj*n_in outputs corresponds to
        adjoint sensitivities, one direction at a time.

        (n_in = n_in(), n_out = n_out())


        """
        return _casadi.Function_derivative(self, *args)

    def forward(self, *args):
        """
        forward(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, 
            std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & fseed, 
            bool always_inline=False, 
            bool never_inline=False)
        forward(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, std::vector< casadi::SX,std::allocator< casadi::SX > > const & res, 
            std::vector< std::vector< casadi::SX,std::allocator< casadi::SX > >,std::allocator< std::vector< casadi::SX,std::allocator< casadi::SX > > > > const & fseed, 
            bool always_inline=False, 
            bool never_inline=False)
        forward(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg, std::vector< casadi::DM,std::allocator< casadi::DM > > const & res, 
            std::vector< std::vector< casadi::DM,std::allocator< casadi::DM > >,std::allocator< std::vector< casadi::DM,std::allocator< casadi::DM > > > > const & fseed, 
            bool always_inline=False, 
            bool never_inline=False)
        forward(Function self, int nfwd) -> Function

        >  void Function.forward([MX ] arg, [MX ] res, [[MX ] ] fseed,[[MX ] ] output_fsens, bool always_inline=false, bool never_inline=false)

        >  void Function.forward([SX ] arg, [SX ] res, [[SX ] ] fseed,[[SX ] ] output_fsens, bool always_inline=false, bool never_inline=false)

        >  void Function.forward([DM ] arg, [DM ] res, [[DM ] ] fseed,[[DM ] ] output_fsens, bool always_inline=false, bool never_inline=false)
        ------------------------------------------------------------------------

        Create call to (cached) derivative function, forward mode.

        >  Function Function.forward(int nfwd)
        ------------------------------------------------------------------------

        Get a function that calculates nfwd forward derivatives.

        Returns a function with n_in + n_out +nfwd*n_in inputs and nfwd*n_out
        outputs. The first n_in inputs correspond to nondifferentiated inputs. The
        next n_out inputs correspond to nondifferentiated outputs. and the last
        nfwd*n_in inputs correspond to forward seeds, one direction at a time The
        nfwd*n_out outputs correspond to forward sensitivities, one direction at a
        time. * (n_in = n_in(), n_out = n_out())

        The functions returned are cached, meaning that if called multiple timed
        with the same value, then multiple references to the same function will be
        returned.


        """
        return _casadi.Function_forward(self, *args)

    def reverse(self, *args):
        """
        reverse(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, 
            std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & aseed, 
            bool always_inline=False, 
            bool never_inline=False)
        reverse(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, std::vector< casadi::SX,std::allocator< casadi::SX > > const & res, 
            std::vector< std::vector< casadi::SX,std::allocator< casadi::SX > >,std::allocator< std::vector< casadi::SX,std::allocator< casadi::SX > > > > const & aseed, 
            bool always_inline=False, 
            bool never_inline=False)
        reverse(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg, std::vector< casadi::DM,std::allocator< casadi::DM > > const & res, 
            std::vector< std::vector< casadi::DM,std::allocator< casadi::DM > >,std::allocator< std::vector< casadi::DM,std::allocator< casadi::DM > > > > const & aseed, 
            bool always_inline=False, 
            bool never_inline=False)
        reverse(Function self, int nadj) -> Function

        >  void Function.reverse([MX ] arg, [MX ] res, [[MX ] ] aseed,[[MX ] ] output_asens, bool always_inline=false, bool never_inline=false)

        >  void Function.reverse([SX ] arg, [SX ] res, [[SX ] ] aseed,[[SX ] ] output_asens, bool always_inline=false, bool never_inline=false)

        >  void Function.reverse([DM ] arg, [DM ] res, [[DM ] ] aseed,[[DM ] ] output_asens, bool always_inline=false, bool never_inline=false)
        ------------------------------------------------------------------------

        Create call to (cached) derivative function, reverse mode.

        >  Function Function.reverse(int nadj)
        ------------------------------------------------------------------------

        Get a function that calculates nadj adjoint derivatives.

        Returns a function with n_in + n_out +nadj*n_out inputs and nadj*n_in
        outputs. The first n_in inputs correspond to nondifferentiated inputs. The
        next n_out inputs correspond to nondifferentiated outputs. and the last
        nadj*n_out inputs correspond to adjoint seeds, one direction at a time The
        nadj*n_in outputs correspond to adjoint sensitivities, one direction at a
        time. * (n_in = n_in(), n_out = n_out())

        (n_in = n_in(), n_out = n_out())

        The functions returned are cached, meaning that if called multiple timed
        with the same value, then multiple references to the same function will be
        returned.


        """
        return _casadi.Function_reverse(self, *args)

    def set_forward(self, *args):
        """
        set_forward(Function self, Function fcn, int nfwd)

        Set a function that calculates nfwd forward derivatives NOTE: Does not take
        ownership, only weak references to the derivatives are kept internally.


        """
        return _casadi.Function_set_forward(self, *args)

    def set_reverse(self, *args):
        """
        set_reverse(Function self, Function fcn, int nadj)

        Set a function that calculates nadj adjoint derivatives NOTE: Does not take
        ownership, only weak references to the derivatives are kept internally.


        """
        return _casadi.Function_set_reverse(self, *args)

    def sparsity_jac(self, *args):
        """
        sparsity_jac(Function self, int iind=0, int oind=0, bool compact=False, bool symmetric=False) -> Sparsity
        sparsity_jac(Function self, std::string const & iind, int oind=0, bool compact=False, bool symmetric=False) -> Sparsity
        sparsity_jac(Function self, int iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity
        sparsity_jac(Function self, std::string const & iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity

        Get, if necessary generate, the sparsity of a Jacobian block


        """
        return _casadi.Function_sparsity_jac(self, *args)

    def set_jac_sparsity(self, *args):
        """
        set_jac_sparsity(Function self, Sparsity sp, int iind, int oind, bool compact=False)
        set_jac_sparsity(Function self, Sparsity sp, std::string const & iind, int oind, bool compact=False)
        set_jac_sparsity(Function self, Sparsity sp, int iind, std::string const & oind, bool compact=False)
        set_jac_sparsity(Function self, Sparsity sp, std::string const & iind, std::string const & oind, bool compact=False)

        Generate the sparsity of a Jacobian block


        """
        return _casadi.Function_set_jac_sparsity(self, *args)

    def generate(self, *args):
        """
        generate(Function self, std::string const & fname, casadi::Dict const & opts=casadi::Dict())
        generate(Function self, casadi::Dict const & opts=casadi::Dict())

        Export / Generate C code for the function.


        """
        return _casadi.Function_generate(self, *args)

    def generate_dependencies(self, *args):
        """
        generate_dependencies(Function self, std::string const & fname, casadi::Dict const & opts=casadi::Dict())

        Export / Generate C code for the dependency function.


        """
        return _casadi.Function_generate_dependencies(self, *args)

    def stats(self, *args):
        """
        stats(Function self, int mem=0) -> casadi::Dict

        Get all statistics obtained at the end of the last evaluate call.


        """
        return _casadi.Function_stats(self, *args)

    def sx_in(self, *args):
        """
        sx_in(Function self, int iind) -> SX
        sx_in(Function self, std::string const & iname) -> SX
        sx_in(Function self) -> std::vector< casadi::SX,std::allocator< casadi::SX > > const

        Get symbolic primitives equivalent to the input expressions There is no
        guarantee that subsequent calls return unique answers.


        """
        return _casadi.Function_sx_in(self, *args)

    def mx_in(self, *args):
        """
        mx_in(Function self, int ind) -> MX
        mx_in(Function self, std::string const & iname) -> MX
        mx_in(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const

        Get symbolic primitives equivalent to the input expressions There is no
        guarantee that subsequent calls return unique answers.


        """
        return _casadi.Function_mx_in(self, *args)

    def sx_out(self, *args):
        """
        sx_out(Function self, int oind) -> SX
        sx_out(Function self, std::string const & oname) -> SX
        sx_out(Function self) -> std::vector< casadi::SX,std::allocator< casadi::SX > > const

        Get symbolic primitives equivalent to the output expressions There is no
        guarantee that subsequent calls return unique answers.


        """
        return _casadi.Function_sx_out(self, *args)

    def mx_out(self, *args):
        """
        mx_out(Function self, int ind) -> MX
        mx_out(Function self, std::string const & oname) -> MX
        mx_out(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const

        Get symbolic primitives equivalent to the output expressions There is no
        guarantee that subsequent calls return unique answers.


        """
        return _casadi.Function_mx_out(self, *args)

    def free_sx(self, *args):
        """
        free_sx(Function self) -> SX

        Get all the free variables of the function.


        """
        return _casadi.Function_free_sx(self, *args)

    def free_mx(self, *args):
        """
        free_mx(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >

        Get all the free variables of the function.


        """
        return _casadi.Function_free_mx(self, *args)

    def has_free(self, *args):
        """
        has_free(Function self) -> bool

        Does the function have free variables.


        """
        return _casadi.Function_has_free(self, *args)

    def generate_lifted(self, *args):
        """
        generate_lifted(Function self)

        Extract the functions needed for the Lifted Newton method.


        """
        return _casadi.Function_generate_lifted(self, *args)

    def getAlgorithmSize(self, *args):
        """
        getAlgorithmSize(Function self) -> int

        Get the number of atomic operations.


        """
        return _casadi.Function_getAlgorithmSize(self, *args)

    def getWorkSize(self, *args):
        """
        getWorkSize(Function self) -> int

        Get the length of the work vector.


        """
        return _casadi.Function_getWorkSize(self, *args)

    def getAtomicOperation(self, *args):
        """
        getAtomicOperation(Function self, int k) -> int

        Get an atomic operation operator index.


        """
        return _casadi.Function_getAtomicOperation(self, *args)

    def getAtomicInput(self, *args):
        """
        getAtomicInput(Function self, int k) -> std::pair< int,int >

        Get the (integer) input arguments of an atomic operation.


        """
        return _casadi.Function_getAtomicInput(self, *args)

    def getAtomicInputReal(self, *args):
        """
        getAtomicInputReal(Function self, int k) -> double

        Get the floating point output argument of an atomic operation.


        """
        return _casadi.Function_getAtomicInputReal(self, *args)

    def getAtomicOutput(self, *args):
        """
        getAtomicOutput(Function self, int k) -> int

        Get the (integer) output argument of an atomic operation.


        """
        return _casadi.Function_getAtomicOutput(self, *args)

    def n_nodes(self, *args):
        """
        n_nodes(Function self) -> int

        Number of nodes in the algorithm.


        """
        return _casadi.Function_n_nodes(self, *args)

    def spCanEvaluate(self, *args):
        """
        spCanEvaluate(Function self, bool fwd) -> bool

        [INTERNAL]  Is the
        class able to propagate seeds through the algorithm?

        (for usage, see the example propagating_sparsity.cpp)


        """
        return _casadi.Function_spCanEvaluate(self, *args)

    def sz_arg(self, *args):
        """
        sz_arg(Function self) -> size_t

        [INTERNAL]  Get required
        length of arg field.


        """
        return _casadi.Function_sz_arg(self, *args)

    def sz_res(self, *args):
        """
        sz_res(Function self) -> size_t

        [INTERNAL]  Get required
        length of res field.


        """
        return _casadi.Function_sz_res(self, *args)

    def sz_iw(self, *args):
        """
        sz_iw(Function self) -> size_t

        [INTERNAL]  Get required
        length of iw field.


        """
        return _casadi.Function_sz_iw(self, *args)

    def sz_w(self, *args):
        """
        sz_w(Function self) -> size_t

        [INTERNAL]  Get required
        length of w field.


        """
        return _casadi.Function_sz_w(self, *args)

    def addMonitor(self, *args):
        """
        addMonitor(Function self, std::string const & mon)

        Add modules to be monitored.


        """
        return _casadi.Function_addMonitor(self, *args)

    def removeMonitor(self, *args):
        """
        removeMonitor(Function self, std::string const & mon)

        Remove modules to be monitored.


        """
        return _casadi.Function_removeMonitor(self, *args)

    def checkInputs(self, *args):
        """
        checkInputs(Function self)

        [INTERNAL]  Check if
        the numerical values of the supplied bounds make sense.


        """
        return _casadi.Function_checkInputs(self, *args)

    def name(self, *args):
        """
        name(Function self) -> std::string

        Name of the function.


        """
        return _casadi.Function_name(self, *args)

    def type_name(self, *args):
        """
        type_name(Function self) -> std::string

        Get type name.


        """
        return _casadi.Function_type_name(self, *args)

    def is_a(self, *args):
        """
        is_a(Function self, std::string const & type, bool recursive=True) -> bool

        Check if the function is of a particular type Optionally check if name
        matches one of the base classes (default true)


        """
        return _casadi.Function_is_a(self, *args)

    def check_name(*args):
        """check_name(std::string const & name) -> bool"""
        return _casadi.Function_check_name(*args)

    if _newclass:check_name = staticmethod(check_name)
    __swig_getmethods__["check_name"] = lambda x: check_name
    def fix_name(*args):
        """fix_name(std::string const & name) -> std::string"""
        return _casadi.Function_fix_name(*args)

    if _newclass:fix_name = staticmethod(fix_name)
    __swig_getmethods__["fix_name"] = lambda x: fix_name
    def checkout(self, *args):
        """
        checkout(Function self) -> int

        Checkout a memory object.


        """
        return _casadi.Function_checkout(self, *args)

    def release(self, *args):
        """
        release(Function self, int mem)

        Release a memory object.


        """
        return _casadi.Function_release(self, *args)

    def linsol_solve(self, *args):
        """
        linsol_solve(Function self, MX A, MX B, bool tr=False) -> MX

        Create a solve node.


        """
        return _casadi.Function_linsol_solve(self, *args)

    def linsol_cholesky_sparsity(self, *args):
        """
        linsol_cholesky_sparsity(Function self, bool tr=False, int mem=0) -> Sparsity

        Obtain a symbolic Cholesky factorization Only for Cholesky solvers.


        """
        return _casadi.Function_linsol_cholesky_sparsity(self, *args)

    def linsol_cholesky(self, *args):
        """
        linsol_cholesky(Function self, bool tr=False, int mem=0) -> DM

        Obtain a numeric Cholesky factorization Only for Cholesky solvers.


        """
        return _casadi.Function_linsol_cholesky(self, *args)

    def rootfinder_fun(self, *args):
        """
        rootfinder_fun(Function self) -> Function

        Access rhs function for a rootfinder.


        """
        return _casadi.Function_rootfinder_fun(self, *args)

    def rootfinder_jac(self, *args):
        """
        rootfinder_jac(Function self) -> Function

        Access Jacobian of the ths function for a rootfinder.


        """
        return _casadi.Function_rootfinder_jac(self, *args)

    def rootfinder_linsol(self, *args):
        """
        rootfinder_linsol(Function self) -> Function

        Access linear solver of a rootfinder.


        """
        return _casadi.Function_rootfinder_linsol(self, *args)

    def integrator_dae(self, *args):
        """
        integrator_dae(Function self) -> Function

        Get the DAE for an integrator.


        """
        return _casadi.Function_integrator_dae(self, *args)

    def qpsol_debug(self, *args):
        """
        qpsol_debug(Function self, std::string const & filename)
        qpsol_debug(Function self, std::ostream & file)

        Generate native code in the interfaced language for debugging


        """
        return _casadi.Function_qpsol_debug(self, *args)

    def __call__(self, *args, **kwargs):
      # Either named inputs or ordered inputs
      if len(args)>0 and len(kwargs)>0:
        raise SyntaxError('Function evaluation requires all arguments to be named or none')
      if len(args)>0:
        # Ordered inputs -> return tuple
        ret = self.call(args)
        if len(ret)==0:
          return None
        elif len(ret)==1:
          return ret[0]
        else:
          return tuple(ret)
      else:
        # Named inputs -> return dictionary
        return self.call(kwargs)

    def __init__(self, *args): 
        """
        __init__(casadi::Function self) -> Function
        __init__(casadi::Function self, std::string const & fname) -> Function
        __init__(casadi::Function self, std::string const & name, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, 
            std::vector< casadi::SX,std::allocator< casadi::SX > > const & res, 
            casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, std::string const & name, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, 
            std::vector< casadi::SX,std::allocator< casadi::SX > > const & res, 
            std::vector< std::string,std::allocator< std::string > > const & argn, 
            std::vector< std::string,std::allocator< std::string > > const & resn, casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, std::string const & name, std::map< std::string,casadi::SX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::SX > > > const & dict, 
            std::vector< std::string,std::allocator< std::string > > const & argn, 
            std::vector< std::string,std::allocator< std::string > > const & resn, 
            casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, 
            std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, 
            casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, 
            std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, 
            std::vector< std::string,std::allocator< std::string > > const & argn, 
            std::vector< std::string,std::allocator< std::string > > const & resn, casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, std::string const & name, std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const & dict, 
            std::vector< std::string,std::allocator< std::string > > const & argn, 
            std::vector< std::string,std::allocator< std::string > > const & resn, 
            casadi::Dict const & opts=casadi::Dict()) -> Function
        __init__(casadi::Function self, Function other) -> Function

        >  Function(str name, [SX ] arg, [SX ] res, Dict opts=Dict())

        >  Function(str name, [SX ] arg, [SX ] res, [str ] argn, [str ] resn, Dict opts=Dict())

        >  Function(str name, const std.map< str, SX > &dict, [str ] argn, [str ] resn, Dict opts=Dict())
        ------------------------------------------------------------------------

        Construct an SX function.

        >  Function(str name, [MX ] arg, [MX ] res, Dict opts=Dict())

        >  Function(str name, [MX ] arg, [MX ] res, [str ] argn, [str ] resn, Dict opts=Dict())

        >  Function(str name, const std.map< str, MX > &dict, [str ] argn, [str ] resn, Dict opts=Dict())
        ------------------------------------------------------------------------

        Construct an MX function.

        >  Function()
        ------------------------------------------------------------------------

        Default constructor, null pointer.

        >  Function(str fname)
        ------------------------------------------------------------------------

        Construct from a file.


        """
        this = _casadi.new_Function(*args)
        try: self.this.append(this)
        except: self.this = this
Function_swigregister = _casadi.Function_swigregister
Function_swigregister(Function)

def Function_conditional(*args):
  """
    Function_conditional(std::string const & name, std::vector< casadi::Function,std::allocator< casadi::Function > > const & f, 
        Function f_def, casadi::Dict const & opts=casadi::Dict()) -> Function
    """
  return _casadi.Function_conditional(*args)

def Function_if_else(*args):
  """Function_if_else(std::string const & name, Function f_true, Function f_false, casadi::Dict const & opts=casadi::Dict()) -> Function"""
  return _casadi.Function_if_else(*args)

def Function_check_name(*args):
  """Function_check_name(std::string const & name) -> bool"""
  return _casadi.Function_check_name(*args)

def Function_fix_name(*args):
  """Function_fix_name(std::string const & name) -> std::string"""
  return _casadi.Function_fix_name(*args)


def external(*args):
  """
    external(std::string const & name, casadi::Dict const & opts=casadi::Dict()) -> Function
    external(std::string const & name, std::string const & bin_name, casadi::Dict const & opts=casadi::Dict()) -> Function
    external(std::string const & name, Compiler compiler, casadi::Dict const & opts=casadi::Dict()) -> Function

    >  Function external(str name, Dict opts=Dict())
    ------------------------------------------------------------------------

    Load an external function File name is assumed to be ./<f_name>.so.

    >  Function external(str name, str bin_name, Dict opts=Dict())
    ------------------------------------------------------------------------

    Load an external function File name given.

    >  Function external(str name, Compiler compiler, Dict opts=Dict())
    ------------------------------------------------------------------------

    Load a just-in-time compiled external function File name given.


    """
  return _casadi.external(*args)

def jit(*args):
  """
    jit(std::string const & name, int n_in, int n_out, std::string const & body, casadi::Dict const & opts=casadi::Dict()) -> Function

    Create a just-in-time compiled function from a C/C++ language string The
    function can an arbitrary number of inputs and outputs that must all be
    scalar-valued. Only specify the function body, assuming that the inputs are
    stored in an array named 'arg' and the outputs stored in an array named
    'res'. The data type used must be 'real_t', which is typically equal to
    'double` or another data type with the same API as 'double'.

    The final generated function will have a structure similar to:

    void fname(const real_t* arg, real_t* res) { <FUNCTION_BODY> }


    """
  return _casadi.jit(*args)

def integrator(*args):
  """
    integrator(std::string const & name, std::string const & solver, casadi::SXDict const & dae, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    integrator(std::string const & name, std::string const & solver, casadi::MXDict const & dae, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    integrator(std::string const & name, std::string const & solver, Function dae, casadi::Dict const & opts=casadi::Dict()) -> Function
    integrator(std::string const & name, std::string const & solver, std::pair< casadi::Function,casadi::Function > const & dae, 
        casadi::Dict const & opts=casadi::Dict()) -> Function

    >  Function integrator(str name, str solver, const str:SX &dae, Dict opts=Dict())
    ------------------------------------------------------------------------

    Create an ODE/DAE integrator Solves an initial value problem (IVP) coupled
    to a terminal value problem with differential equation given as an implicit
    ODE coupled to an algebraic equation and a set of quadratures:



    ::

      Initial conditions at t=t0
      x(t0)  = x0
      q(t0)  = 0
      
      Forward integration from t=t0 to t=tf
      der(x) = function(x, z, p, t)                  Forward ODE
      0 = fz(x, z, p, t)                  Forward algebraic equations
      der(q) = fq(x, z, p, t)                  Forward quadratures
      
      Terminal conditions at t=tf
      rx(tf)  = rx0
      rq(tf)  = 0
      
      Backward integration from t=tf to t=t0
      der(rx) = gx(rx, rz, rp, x, z, p, t)        Backward ODE
      0 = gz(rx, rz, rp, x, z, p, t)        Backward algebraic equations
      der(rq) = gq(rx, rz, rp, x, z, p, t)        Backward quadratures
      
      where we assume that both the forward and backwards integrations are index-1
      (i.e. dfz/dz, dgz/drz are invertible) and furthermore that
      gx, gz and gq have a linear dependency on rx, rz and rp.



    General information
    ===================



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |   Description   |     Used in     |
    +=================+=================+=================+=================+
    | ad_weight       | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | derivative calc |                 |
    |                 |                 | ulation.When    |                 |
    |                 |                 | there is an     |                 |
    |                 |                 | option of       |                 |
    |                 |                 | either using    |                 |
    |                 |                 | forward or      |                 |
    |                 |                 | reverse mode    |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives,    |                 |
    |                 |                 | the condition a |                 |
    |                 |                 | d_weight*nf<=(1 |                 |
    |                 |                 | -ad_weight)*na  |                 |
    |                 |                 | is used where   |                 |
    |                 |                 | nf and na are   |                 |
    |                 |                 | estimates of    |                 |
    |                 |                 | the number of   |                 |
    |                 |                 | forward/reverse |                 |
    |                 |                 | mode            |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives     |                 |
    |                 |                 | needed. By      |                 |
    |                 |                 | default,        |                 |
    |                 |                 | ad_weight is    |                 |
    |                 |                 | calculated      |                 |
    |                 |                 | automatically,  |                 |
    |                 |                 | but this can be |                 |
    |                 |                 | overridden by   |                 |
    |                 |                 | setting this    |                 |
    |                 |                 | option. In      |                 |
    |                 |                 | particular, 0   |                 |
    |                 |                 | means forcing   |                 |
    |                 |                 | forward mode    |                 |
    |                 |                 | and 1 forcing   |                 |
    |                 |                 | reverse mode.   |                 |
    |                 |                 | Leave unset for |                 |
    |                 |                 | (class          |                 |
    |                 |                 | specific)       |                 |
    |                 |                 | heuristics.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | ad_weight_sp    | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | sparsity        |                 |
    |                 |                 | pattern         |                 |
    |                 |                 | calculation cal |                 |
    |                 |                 | culation.Overri |                 |
    |                 |                 | des default     |                 |
    |                 |                 | behavior. Set   |                 |
    |                 |                 | to 0 and 1 to   |                 |
    |                 |                 | force forward   |                 |
    |                 |                 | and reverse     |                 |
    |                 |                 | mode            |                 |
    |                 |                 | respectively.   |                 |
    |                 |                 | Cf. option      |                 |
    |                 |                 | "ad_weight".    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | augmented_optio | OT_DICT         | Options to be   | casadi::Integra |
    | ns              |                 | passed down to  | tor             |
    |                 |                 | the augmented   |                 |
    |                 |                 | integrator, if  |                 |
    |                 |                 | one is          |                 |
    |                 |                 | constructed.    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | Just-in-time    | casadi::Functio |
    |                 |                 | compiler plugin | nInternal       |
    |                 |                 | to be used.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_of   | OT_FUNCTION     | The function is | casadi::Functio |
    |                 |                 | a derivative of | nInternal       |
    |                 |                 | another         |                 |
    |                 |                 | function. The   |                 |
    |                 |                 | type of         |                 |
    |                 |                 | derivative      |                 |
    |                 |                 | (directional    |                 |
    |                 |                 | derivative,     |                 |
    |                 |                 | Jacobian) is    |                 |
    |                 |                 | inferred from   |                 |
    |                 |                 | the function    |                 |
    |                 |                 | name.           |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | expand          | OT_BOOL         | Replace MX with | casadi::Integra |
    |                 |                 | SX expressions  | tor             |
    |                 |                 | in problem      |                 |
    |                 |                 | formulation     |                 |
    |                 |                 | [false]         |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | gather_stats    | OT_BOOL         | Flag to         | casadi::Functio |
    |                 |                 | indicate        | nInternal       |
    |                 |                 | whether         |                 |
    |                 |                 | statistics must |                 |
    |                 |                 | be gathered     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | grid            | OT_DOUBLEVECTOR | Time grid       | casadi::Integra |
    |                 |                 |                 | tor             |
    +-----------------+-----------------+-----------------+-----------------+
    | input_scheme    | OT_STRINGVECTOR | Custom input    | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | inputs_check    | OT_BOOL         | Throw           | casadi::Functio |
    |                 |                 | exceptions when | nInternal       |
    |                 |                 | the numerical   |                 |
    |                 |                 | values of the   |                 |
    |                 |                 | inputs don't    |                 |
    |                 |                 | make sense      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_penalty     | OT_DOUBLE       | When requested  | casadi::Functio |
    |                 |                 | for a number of | nInternal       |
    |                 |                 | forward/reverse |                 |
    |                 |                 | directions, it  |                 |
    |                 |                 | may be cheaper  |                 |
    |                 |                 | to compute      |                 |
    |                 |                 | first the full  |                 |
    |                 |                 | jacobian and    |                 |
    |                 |                 | then multiply   |                 |
    |                 |                 | with seeds,     |                 |
    |                 |                 | rather than     |                 |
    |                 |                 | obtain the      |                 |
    |                 |                 | requested       |                 |
    |                 |                 | directions in a |                 |
    |                 |                 | straightforward |                 |
    |                 |                 | manner. Casadi  |                 |
    |                 |                 | uses a          |                 |
    |                 |                 | heuristic to    |                 |
    |                 |                 | decide which is |                 |
    |                 |                 | cheaper. A high |                 |
    |                 |                 | value of        |                 |
    |                 |                 | 'jac_penalty'   |                 |
    |                 |                 | makes it less   |                 |
    |                 |                 | likely for the  |                 |
    |                 |                 | heurstic to     |                 |
    |                 |                 | chose the full  |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy. The   |                 |
    |                 |                 | special value   |                 |
    |                 |                 | -1 indicates    |                 |
    |                 |                 | never to use    |                 |
    |                 |                 | the full        |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy        |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit             | OT_BOOL         | Use just-in-    | casadi::Functio |
    |                 |                 | time compiler   | nInternal       |
    |                 |                 | to speed up the |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit_options     | OT_DICT         | Options to be   | casadi::Functio |
    |                 |                 | passed to the   | nInternal       |
    |                 |                 | jit compiler.   |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | monitor         | OT_STRINGVECTOR | Monitors to be  | casadi::Functio |
    |                 |                 | activated       | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | number_of_finit | OT_INT          | Number of       | casadi::Integra |
    | e_elements      |                 | finite elements | tor             |
    +-----------------+-----------------+-----------------+-----------------+
    | output_scheme   | OT_STRINGVECTOR | Custom output   | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | output_t0       | OT_BOOL         | Output the      | casadi::Integra |
    |                 |                 | state at the    | tor             |
    |                 |                 | initial time    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | print_stats     | OT_BOOL         | Print out       | casadi::Integra |
    |                 |                 | statistics      | tor             |
    |                 |                 | after           |                 |
    |                 |                 | integration     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | regularity_chec | OT_BOOL         | Throw           | casadi::Functio |
    | k               |                 | exceptions when | nInternal       |
    |                 |                 | NaN or Inf      |                 |
    |                 |                 | appears during  |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | rootfinder      | OT_STRING       | An implicit     | casadi::Integra |
    |                 |                 | function solver | tor             |
    +-----------------+-----------------+-----------------+-----------------+
    | rootfinder_opti | OT_DICT         | Options to be   | casadi::Integra |
    | ons             |                 | passed to the   | tor             |
    |                 |                 | NLP Solver      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | t0              | OT_DOUBLE       | Beginning of    | casadi::Integra |
    |                 |                 | the time        | tor             |
    |                 |                 | horizon         |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | tf              | OT_DOUBLE       | End of the time | casadi::Integra |
    |                 |                 | horizon         | tor             |
    +-----------------+-----------------+-----------------+-----------------+
    | user_data       | OT_VOIDPTR      | A user-defined  | casadi::Functio |
    |                 |                 | field that can  | nInternal       |
    |                 |                 | be used to      |                 |
    |                 |                 | identify the    |                 |
    |                 |                 | function or     |                 |
    |                 |                 | pass additional |                 |
    |                 |                 | information     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | verbose         | OT_BOOL         | Verbose         | casadi::Functio |
    |                 |                 | evaluation  for | nInternal       |
    |                 |                 | debugging       |                 |
    +-----------------+-----------------+-----------------+-----------------+

    >Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | INTEGRATOR_X0          |                        | Differential state at  |
    |                        |                        | the initial time.      |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_P           |                        | Parameters.            |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_Z0          |                        | Initial guess for the  |
    |                        |                        | algebraic variable.    |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RX0         |                        | Backward differential  |
    |                        |                        | state at the final     |
    |                        |                        | time.                  |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RP          |                        | Backward parameter     |
    |                        |                        | vector.                |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RZ0         |                        | Initial guess for the  |
    |                        |                        | backwards algebraic    |
    |                        |                        | variable.              |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::IntegratorOutput (INTEGRATOR_NUM_OUT = 6) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | INTEGRATOR_XF          |                        | Differential state at  |
    |                        |                        | the final time.        |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_QF          |                        | Quadrature state at    |
    |                        |                        | the final time.        |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_ZF          |                        | Algebraic variable at  |
    |                        |                        | the final time.        |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RXF         |                        | Backward differential  |
    |                        |                        | state at the initial   |
    |                        |                        | time.                  |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RQF         |                        | Backward quadrature    |
    |                        |                        | state at the initial   |
    |                        |                        | time.                  |
    +------------------------+------------------------+------------------------+
    | INTEGRATOR_RZF         |                        | Backward algebraic     |
    |                        |                        | variable at the        |
    |                        |                        | initial time.          |
    +------------------------+------------------------+------------------------+

    List of plugins
    ===============



    - cvodes

    - idas

    - collocation

    - rk

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Integrator.doc("myextraplugin")



    --------------------------------------------------------------------------------

    cvodes
    ------



    Interface to CVodes from the Sundials suite.

    A call to evaluate will integrate to the end.

    You can retrieve the entire state trajectory as follows, after the evaluate
    call: Call reset. Then call integrate(t_i) and getOuput for a series of
    times t_i.

    Note: depending on the dimension and structure of your problem, you may
    experience a dramatic speed-up by using a sparse linear solver:



    ::

         intg.setOption("linear_solver","csparse")
         intg.setOption("linear_solver_type","user_defined")



    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | abstol                 | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the IVP solution       |
    +------------------------+------------------------+------------------------+
    | abstolB                | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the adjoint            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | abstol]                |
    +------------------------+------------------------+------------------------+
    | disable_internal_warni | OT_BOOL                | Disable SUNDIALS       |
    | ngs                    |                        | internal warning       |
    |                        |                        | messages               |
    +------------------------+------------------------+------------------------+
    | exact_jacobian         | OT_BOOL                | Use exact Jacobian     |
    |                        |                        | information for the    |
    |                        |                        | forward integration    |
    +------------------------+------------------------+------------------------+
    | exact_jacobianB        | OT_BOOL                | Use exact Jacobian     |
    |                        |                        | information for the    |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | exact_jacobian]        |
    +------------------------+------------------------+------------------------+
    | finite_difference_fsen | OT_BOOL                | Use finite differences |
    | s                      |                        | to approximate the     |
    |                        |                        | forward sensitivity    |
    |                        |                        | equations (if AD is    |
    |                        |                        | not available)         |
    +------------------------+------------------------+------------------------+
    | fsens_abstol           | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the forward            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | abstol]                |
    +------------------------+------------------------+------------------------+
    | fsens_all_at_once      | OT_BOOL                | Calculate all right    |
    |                        |                        | hand sides of the      |
    |                        |                        | sensitivity equations  |
    |                        |                        | at once                |
    +------------------------+------------------------+------------------------+
    | fsens_err_con          | OT_BOOL                | include the forward    |
    |                        |                        | sensitivities in all   |
    |                        |                        | error controls         |
    +------------------------+------------------------+------------------------+
    | fsens_reltol           | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the forward            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | reltol]                |
    +------------------------+------------------------+------------------------+
    | fsens_scaling_factors  | OT_DOUBLEVECTOR        | Scaling factor for the |
    |                        |                        | components if finite   |
    |                        |                        | differences is used    |
    +------------------------+------------------------+------------------------+
    | fsens_sensitiviy_param | OT_INTVECTOR           | Specifies which        |
    | eters                  |                        | components will be     |
    |                        |                        | used when estimating   |
    |                        |                        | the sensitivity        |
    |                        |                        | equations              |
    +------------------------+------------------------+------------------------+
    | interpolation_type     | OT_STRING              | Type of interpolation  |
    |                        |                        | for the adjoint        |
    |                        |                        | sensitivities          |
    +------------------------+------------------------+------------------------+
    | iterative_solver       | OT_STRING              | Iterative solver:      |
    |                        |                        | GMRES|bcgstab|tfqmr    |
    +------------------------+------------------------+------------------------+
    | iterative_solverB      | OT_STRING              | Iterative solver for   |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | linear_multistep_metho | OT_STRING              | Integrator scheme:     |
    | d                      |                        | BDF|adams              |
    +------------------------+------------------------+------------------------+
    | linear_solver          | OT_STRING              | A custom linear solver |
    |                        |                        | creator function       |
    +------------------------+------------------------+------------------------+
    | linear_solverB         | OT_STRING              | A custom linear solver |
    |                        |                        | creator function for   |
    |                        |                        | backwards integration  |
    |                        |                        | [default: equal to     |
    |                        |                        | linear_solver]         |
    +------------------------+------------------------+------------------------+
    | linear_solver_options  | OT_DICT                | Options to be passed   |
    |                        |                        | to the linear solver   |
    +------------------------+------------------------+------------------------+
    | linear_solver_optionsB | OT_DICT                | Options to be passed   |
    |                        |                        | to the linear solver   |
    |                        |                        | for backwards          |
    |                        |                        | integration [default:  |
    |                        |                        | equal to               |
    |                        |                        | linear_solver_options] |
    +------------------------+------------------------+------------------------+
    | linear_solver_type     | OT_STRING              | Type of iterative      |
    |                        |                        | solver: user_defined|D |
    |                        |                        | ENSE|banded|iterative  |
    +------------------------+------------------------+------------------------+
    | linear_solver_typeB    | OT_STRING              | Linear solver for      |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | lower_bandwidth        | OT_INT                 | Lower band-width of    |
    |                        |                        | banded Jacobian        |
    |                        |                        | (estimations)          |
    +------------------------+------------------------+------------------------+
    | lower_bandwidthB       | OT_INT                 | lower band-width of    |
    |                        |                        | banded jacobians for   |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | lower_bandwidth]       |
    +------------------------+------------------------+------------------------+
    | max_krylov             | OT_INT                 | Maximum Krylov         |
    |                        |                        | subspace size          |
    +------------------------+------------------------+------------------------+
    | max_krylovB            | OT_INT                 | Maximum krylov         |
    |                        |                        | subspace size for      |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | max_multistep_order    | OT_INT                 | Maximum order for the  |
    |                        |                        | (variable-order)       |
    |                        |                        | multistep method       |
    +------------------------+------------------------+------------------------+
    | max_num_steps          | OT_INT                 | Maximum number of      |
    |                        |                        | integrator steps       |
    +------------------------+------------------------+------------------------+
    | nonlinear_solver_itera | OT_STRING              | Nonlinear solver type: |
    | tion                   |                        | NEWTON|functional      |
    +------------------------+------------------------+------------------------+
    | pretype                | OT_STRING              | Type of                |
    |                        |                        | preconditioning:       |
    |                        |                        | NONE|left|right|both   |
    +------------------------+------------------------+------------------------+
    | pretypeB               | OT_STRING              | Preconditioner for     |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | quad_err_con           | OT_BOOL                | Should the quadratures |
    |                        |                        | affect the step size   |
    |                        |                        | control                |
    +------------------------+------------------------+------------------------+
    | reltol                 | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the IVP solution       |
    +------------------------+------------------------+------------------------+
    | reltolB                | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the adjoint            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | reltol]                |
    +------------------------+------------------------+------------------------+
    | sensitivity_method     | OT_STRING              | Sensitivity method:    |
    |                        |                        | SIMULTANEOUS|staggered |
    +------------------------+------------------------+------------------------+
    | steps_per_checkpoint   | OT_INT                 | Number of steps        |
    |                        |                        | between two            |
    |                        |                        | consecutive            |
    |                        |                        | checkpoints            |
    +------------------------+------------------------+------------------------+
    | stop_at_end            | OT_BOOL                | Stop the integrator at |
    |                        |                        | the end of the         |
    |                        |                        | interval               |
    +------------------------+------------------------+------------------------+
    | upper_bandwidth        | OT_INT                 | Upper band-width of    |
    |                        |                        | banded Jacobian        |
    |                        |                        | (estimations)          |
    +------------------------+------------------------+------------------------+
    | upper_bandwidthB       | OT_INT                 | Upper band-width of    |
    |                        |                        | banded jacobians for   |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | upper_bandwidth]       |
    +------------------------+------------------------+------------------------+
    | use_preconditioner     | OT_BOOL                | Precondition an        |
    |                        |                        | iterative solver       |
    +------------------------+------------------------+------------------------+
    | use_preconditionerB    | OT_BOOL                | Precondition an        |
    |                        |                        | iterative solver for   |
    |                        |                        | the backwards problem  |
    |                        |                        | [default: equal to     |
    |                        |                        | use_preconditioner]    |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    idas
    ----



    Interface to IDAS from the Sundials suite.

    Note: depending on the dimension and structure of your problem, you may
    experience a dramatic speed-up by using a sparse linear solver:



    ::

         intg.setOption("linear_solver","csparse")
         intg.setOption("linear_solver_type","user_defined")



    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | abstol                 | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the IVP solution       |
    +------------------------+------------------------+------------------------+
    | abstolB                | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the adjoint            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | abstol]                |
    +------------------------+------------------------+------------------------+
    | abstolv                | OT_DOUBLEVECTOR        | Absolute tolerarance   |
    |                        |                        | for each component     |
    +------------------------+------------------------+------------------------+
    | calc_ic                | OT_BOOL                | Use IDACalcIC to get   |
    |                        |                        | consistent initial     |
    |                        |                        | conditions.            |
    +------------------------+------------------------+------------------------+
    | calc_icB               | OT_BOOL                | Use IDACalcIC to get   |
    |                        |                        | consistent initial     |
    |                        |                        | conditions for         |
    |                        |                        | backwards system       |
    |                        |                        | [default: equal to     |
    |                        |                        | calc_ic].              |
    +------------------------+------------------------+------------------------+
    | cj_scaling             | OT_BOOL                | IDAS scaling on cj for |
    |                        |                        | the user-defined       |
    |                        |                        | linear solver module   |
    +------------------------+------------------------+------------------------+
    | disable_internal_warni | OT_BOOL                | Disable SUNDIALS       |
    | ngs                    |                        | internal warning       |
    |                        |                        | messages               |
    +------------------------+------------------------+------------------------+
    | exact_jacobian         | OT_BOOL                | Use exact Jacobian     |
    |                        |                        | information for the    |
    |                        |                        | forward integration    |
    +------------------------+------------------------+------------------------+
    | exact_jacobianB        | OT_BOOL                | Use exact Jacobian     |
    |                        |                        | information for the    |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | exact_jacobian]        |
    +------------------------+------------------------+------------------------+
    | extra_fsens_calc_ic    | OT_BOOL                | Call calc ic an extra  |
    |                        |                        | time, with fsens=0     |
    +------------------------+------------------------+------------------------+
    | finite_difference_fsen | OT_BOOL                | Use finite differences |
    | s                      |                        | to approximate the     |
    |                        |                        | forward sensitivity    |
    |                        |                        | equations (if AD is    |
    |                        |                        | not available)         |
    +------------------------+------------------------+------------------------+
    | first_time             | OT_DOUBLE              | First requested time   |
    |                        |                        | as a fraction of the   |
    |                        |                        | time interval          |
    +------------------------+------------------------+------------------------+
    | fsens_abstol           | OT_DOUBLE              | Absolute tolerence for |
    |                        |                        | the forward            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | abstol]                |
    +------------------------+------------------------+------------------------+
    | fsens_abstolv          | OT_DOUBLEVECTOR        | Absolute tolerarance   |
    |                        |                        | for each component,    |
    |                        |                        | forward sensitivities  |
    +------------------------+------------------------+------------------------+
    | fsens_err_con          | OT_BOOL                | include the forward    |
    |                        |                        | sensitivities in all   |
    |                        |                        | error controls         |
    +------------------------+------------------------+------------------------+
    | fsens_reltol           | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the forward            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | reltol]                |
    +------------------------+------------------------+------------------------+
    | fsens_scaling_factors  | OT_DOUBLEVECTOR        | Scaling factor for the |
    |                        |                        | components if finite   |
    |                        |                        | differences is used    |
    +------------------------+------------------------+------------------------+
    | fsens_sensitiviy_param | OT_INTVECTOR           | Specifies which        |
    | eters                  |                        | components will be     |
    |                        |                        | used when estimating   |
    |                        |                        | the sensitivity        |
    |                        |                        | equations              |
    +------------------------+------------------------+------------------------+
    | init_xdot              | OT_DOUBLEVECTOR        | Initial values for the |
    |                        |                        | state derivatives      |
    +------------------------+------------------------+------------------------+
    | interpolation_type     | OT_STRING              | Type of interpolation  |
    |                        |                        | for the adjoint        |
    |                        |                        | sensitivities          |
    +------------------------+------------------------+------------------------+
    | iterative_solver       | OT_STRING              | Iterative solver:      |
    |                        |                        | GMRES|bcgstab|tfqmr    |
    +------------------------+------------------------+------------------------+
    | iterative_solverB      | OT_STRING              | Iterative solver for   |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | linear_solver          | OT_STRING              | A custom linear solver |
    |                        |                        | creator function       |
    +------------------------+------------------------+------------------------+
    | linear_solverB         | OT_STRING              | A custom linear solver |
    |                        |                        | creator function for   |
    |                        |                        | backwards integration  |
    |                        |                        | [default: equal to     |
    |                        |                        | linear_solver]         |
    +------------------------+------------------------+------------------------+
    | linear_solver_options  | OT_DICT                | Options to be passed   |
    |                        |                        | to the linear solver   |
    +------------------------+------------------------+------------------------+
    | linear_solver_optionsB | OT_DICT                | Options to be passed   |
    |                        |                        | to the linear solver   |
    |                        |                        | for backwards          |
    |                        |                        | integration [default:  |
    |                        |                        | equal to               |
    |                        |                        | linear_solver_options] |
    +------------------------+------------------------+------------------------+
    | linear_solver_type     | OT_STRING              | Type of iterative      |
    |                        |                        | solver: user_defined|D |
    |                        |                        | ENSE|banded|iterative  |
    +------------------------+------------------------+------------------------+
    | linear_solver_typeB    | OT_STRING              | Linear solver for      |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | lower_bandwidth        | OT_INT                 | Lower band-width of    |
    |                        |                        | banded Jacobian        |
    |                        |                        | (estimations)          |
    +------------------------+------------------------+------------------------+
    | lower_bandwidthB       | OT_INT                 | lower band-width of    |
    |                        |                        | banded jacobians for   |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | lower_bandwidth]       |
    +------------------------+------------------------+------------------------+
    | max_krylov             | OT_INT                 | Maximum Krylov         |
    |                        |                        | subspace size          |
    +------------------------+------------------------+------------------------+
    | max_krylovB            | OT_INT                 | Maximum krylov         |
    |                        |                        | subspace size for      |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | max_multistep_order    | OT_INT                 | Maximum order for the  |
    |                        |                        | (variable-order)       |
    |                        |                        | multistep method       |
    +------------------------+------------------------+------------------------+
    | max_num_steps          | OT_INT                 | Maximum number of      |
    |                        |                        | integrator steps       |
    +------------------------+------------------------+------------------------+
    | max_step_size          | OT_DOUBLE              | Maximim step size      |
    +------------------------+------------------------+------------------------+
    | pretype                | OT_STRING              | Type of                |
    |                        |                        | preconditioning:       |
    |                        |                        | NONE|left|right|both   |
    +------------------------+------------------------+------------------------+
    | pretypeB               | OT_STRING              | Preconditioner for     |
    |                        |                        | backward integration   |
    +------------------------+------------------------+------------------------+
    | quad_err_con           | OT_BOOL                | Should the quadratures |
    |                        |                        | affect the step size   |
    |                        |                        | control                |
    +------------------------+------------------------+------------------------+
    | reltol                 | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the IVP solution       |
    +------------------------+------------------------+------------------------+
    | reltolB                | OT_DOUBLE              | Relative tolerence for |
    |                        |                        | the adjoint            |
    |                        |                        | sensitivity solution   |
    |                        |                        | [default: equal to     |
    |                        |                        | reltol]                |
    +------------------------+------------------------+------------------------+
    | sensitivity_method     | OT_STRING              | Sensitivity method:    |
    |                        |                        | SIMULTANEOUS|staggered |
    +------------------------+------------------------+------------------------+
    | steps_per_checkpoint   | OT_INT                 | Number of steps        |
    |                        |                        | between two            |
    |                        |                        | consecutive            |
    |                        |                        | checkpoints            |
    +------------------------+------------------------+------------------------+
    | stop_at_end            | OT_BOOL                | Stop the integrator at |
    |                        |                        | the end of the         |
    |                        |                        | interval               |
    +------------------------+------------------------+------------------------+
    | suppress_algebraic     | OT_BOOL                | Suppress algebraic     |
    |                        |                        | variables in the error |
    |                        |                        | testing                |
    +------------------------+------------------------+------------------------+
    | upper_bandwidth        | OT_INT                 | Upper band-width of    |
    |                        |                        | banded Jacobian        |
    |                        |                        | (estimations)          |
    +------------------------+------------------------+------------------------+
    | upper_bandwidthB       | OT_INT                 | Upper band-width of    |
    |                        |                        | banded jacobians for   |
    |                        |                        | backward integration   |
    |                        |                        | [default: equal to     |
    |                        |                        | upper_bandwidth]       |
    +------------------------+------------------------+------------------------+
    | use_preconditioner     | OT_BOOL                | Precondition an        |
    |                        |                        | iterative solver       |
    +------------------------+------------------------+------------------------+
    | use_preconditionerB    | OT_BOOL                | Precondition an        |
    |                        |                        | iterative solver for   |
    |                        |                        | the backwards problem  |
    |                        |                        | [default: equal to     |
    |                        |                        | use_preconditioner]    |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    collocation
    -----------



    Fixed-step implicit Runge-Kutta integrator ODE/DAE integrator based on
    collocation schemes

    The method is still under development

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | augmented_options      | OT_DICT                | Options to be passed   |
    |                        |                        | down to the augmented  |
    |                        |                        | integrator, if one is  |
    |                        |                        | constructed.           |
    +------------------------+------------------------+------------------------+
    | collocation_scheme     | OT_STRING              | Collocation scheme:    |
    |                        |                        | radau|legendre         |
    +------------------------+------------------------+------------------------+
    | expand                 | OT_BOOL                | Replace MX with SX     |
    |                        |                        | expressions in problem |
    |                        |                        | formulation [false]    |
    +------------------------+------------------------+------------------------+
    | grid                   | OT_DOUBLEVECTOR        | Time grid              |
    +------------------------+------------------------+------------------------+
    | interpolation_order    | OT_INT                 | Order of the           |
    |                        |                        | interpolating          |
    |                        |                        | polynomials            |
    +------------------------+------------------------+------------------------+
    | number_of_finite_eleme | OT_INT                 | Number of finite       |
    | nts                    |                        | elements               |
    +------------------------+------------------------+------------------------+
    | output_t0              | OT_BOOL                | Output the state at    |
    |                        |                        | the initial time       |
    +------------------------+------------------------+------------------------+
    | print_stats            | OT_BOOL                | Print out statistics   |
    |                        |                        | after integration      |
    +------------------------+------------------------+------------------------+
    | rootfinder             | OT_STRING              | An implicit function   |
    |                        |                        | solver                 |
    +------------------------+------------------------+------------------------+
    | rootfinder_options     | OT_DICT                | Options to be passed   |
    |                        |                        | to the NLP Solver      |
    +------------------------+------------------------+------------------------+
    | t0                     | OT_DOUBLE              | Beginning of the time  |
    |                        |                        | horizon                |
    +------------------------+------------------------+------------------------+
    | tf                     | OT_DOUBLE              | End of the time        |
    |                        |                        | horizon                |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    rk --



    Fixed-step explicit Runge-Kutta integrator for ODEs Currently implements
    RK4.

    The method is still under development

    --------------------------------------------------------------------------------



    Joel Andersson


    """
  return _casadi.integrator(*args)

def has_integrator(*args):
  """
    has_integrator(std::string const & name) -> bool

    Check if a particular plugin is available.


    """
  return _casadi.has_integrator(*args)

def load_integrator(*args):
  """
    load_integrator(std::string const & name)

    Explicitly load a plugin dynamically.


    """
  return _casadi.load_integrator(*args)

def doc_integrator(*args):
  """
    doc_integrator(std::string const & name) -> std::string

    Get the documentation string for a plugin.


    """
  return _casadi.doc_integrator(*args)

def integrator_in(*args):
  """
    integrator_in() -> std::vector< std::string,std::allocator< std::string > >
    integrator_in(int ind) -> std::string

    >  CASADI_EXPORT[str] integrator_in()
    ------------------------------------------------------------------------

    Get input scheme of integrators.

    >  str integrator_in(int ind)
    ------------------------------------------------------------------------

    Get integrator input scheme name by index.


    """
  return _casadi.integrator_in(*args)

def integrator_out(*args):
  """
    integrator_out() -> std::vector< std::string,std::allocator< std::string > >
    integrator_out(int ind) -> std::string

    >  CASADI_EXPORT[str] integrator_out()
    ------------------------------------------------------------------------

    Get integrator output scheme of integrators.

    >  str integrator_out(int ind)
    ------------------------------------------------------------------------

    Get output scheme name by index.


    """
  return _casadi.integrator_out(*args)

def integrator_n_in(*args):
  """
    integrator_n_in() -> int

    Get the number of integrator inputs.


    """
  return _casadi.integrator_n_in(*args)

def integrator_n_out(*args):
  """
    integrator_n_out() -> int

    Get the number of integrator outputs.


    """
  return _casadi.integrator_n_out(*args)

def qpsol(*args):
  """
    qpsol(std::string const & name, std::string const & solver, casadi::SpDict const & qp, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    qpsol(std::string const & name, std::string const & solver, casadi::SXDict const & qp, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    qpsol(std::string const & name, std::string const & solver, casadi::MXDict const & qp, 
        casadi::Dict const & opts=casadi::Dict()) -> Function

    >  Function qpsol(str name, str solver, SpDict qp, Dict opts=Dict())
    ------------------------------------------------------------------------

    Create a QP solver Solves the following strictly convex problem:



    ::

      min          1/2 x' H x + g' x
      x
      
      subject to
      LBA <= A x <= UBA
      LBX <= x   <= UBX
      
      with :
      H sparse (n x n) positive definite
      g dense  (n x 1)
      
      n: number of decision variables (x)
      nc: number of constraints (A)



    If H is not positive-definite, the solver should throw an error.

    General information
    ===================



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |   Description   |     Used in     |
    +=================+=================+=================+=================+
    | ad_weight       | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | derivative calc |                 |
    |                 |                 | ulation.When    |                 |
    |                 |                 | there is an     |                 |
    |                 |                 | option of       |                 |
    |                 |                 | either using    |                 |
    |                 |                 | forward or      |                 |
    |                 |                 | reverse mode    |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives,    |                 |
    |                 |                 | the condition a |                 |
    |                 |                 | d_weight*nf<=(1 |                 |
    |                 |                 | -ad_weight)*na  |                 |
    |                 |                 | is used where   |                 |
    |                 |                 | nf and na are   |                 |
    |                 |                 | estimates of    |                 |
    |                 |                 | the number of   |                 |
    |                 |                 | forward/reverse |                 |
    |                 |                 | mode            |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives     |                 |
    |                 |                 | needed. By      |                 |
    |                 |                 | default,        |                 |
    |                 |                 | ad_weight is    |                 |
    |                 |                 | calculated      |                 |
    |                 |                 | automatically,  |                 |
    |                 |                 | but this can be |                 |
    |                 |                 | overridden by   |                 |
    |                 |                 | setting this    |                 |
    |                 |                 | option. In      |                 |
    |                 |                 | particular, 0   |                 |
    |                 |                 | means forcing   |                 |
    |                 |                 | forward mode    |                 |
    |                 |                 | and 1 forcing   |                 |
    |                 |                 | reverse mode.   |                 |
    |                 |                 | Leave unset for |                 |
    |                 |                 | (class          |                 |
    |                 |                 | specific)       |                 |
    |                 |                 | heuristics.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | ad_weight_sp    | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | sparsity        |                 |
    |                 |                 | pattern         |                 |
    |                 |                 | calculation cal |                 |
    |                 |                 | culation.Overri |                 |
    |                 |                 | des default     |                 |
    |                 |                 | behavior. Set   |                 |
    |                 |                 | to 0 and 1 to   |                 |
    |                 |                 | force forward   |                 |
    |                 |                 | and reverse     |                 |
    |                 |                 | mode            |                 |
    |                 |                 | respectively.   |                 |
    |                 |                 | Cf. option      |                 |
    |                 |                 | "ad_weight".    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | Just-in-time    | casadi::Functio |
    |                 |                 | compiler plugin | nInternal       |
    |                 |                 | to be used.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_of   | OT_FUNCTION     | The function is | casadi::Functio |
    |                 |                 | a derivative of | nInternal       |
    |                 |                 | another         |                 |
    |                 |                 | function. The   |                 |
    |                 |                 | type of         |                 |
    |                 |                 | derivative      |                 |
    |                 |                 | (directional    |                 |
    |                 |                 | derivative,     |                 |
    |                 |                 | Jacobian) is    |                 |
    |                 |                 | inferred from   |                 |
    |                 |                 | the function    |                 |
    |                 |                 | name.           |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | discrete        | OT_BOOLVECTOR   | Indicates which | casadi::Qpsol   |
    |                 |                 | of the          |                 |
    |                 |                 | variables are   |                 |
    |                 |                 | discrete, i.e.  |                 |
    |                 |                 | integer-valued  |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | gather_stats    | OT_BOOL         | Flag to         | casadi::Functio |
    |                 |                 | indicate        | nInternal       |
    |                 |                 | whether         |                 |
    |                 |                 | statistics must |                 |
    |                 |                 | be gathered     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | input_scheme    | OT_STRINGVECTOR | Custom input    | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | inputs_check    | OT_BOOL         | Throw           | casadi::Functio |
    |                 |                 | exceptions when | nInternal       |
    |                 |                 | the numerical   |                 |
    |                 |                 | values of the   |                 |
    |                 |                 | inputs don't    |                 |
    |                 |                 | make sense      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_penalty     | OT_DOUBLE       | When requested  | casadi::Functio |
    |                 |                 | for a number of | nInternal       |
    |                 |                 | forward/reverse |                 |
    |                 |                 | directions, it  |                 |
    |                 |                 | may be cheaper  |                 |
    |                 |                 | to compute      |                 |
    |                 |                 | first the full  |                 |
    |                 |                 | jacobian and    |                 |
    |                 |                 | then multiply   |                 |
    |                 |                 | with seeds,     |                 |
    |                 |                 | rather than     |                 |
    |                 |                 | obtain the      |                 |
    |                 |                 | requested       |                 |
    |                 |                 | directions in a |                 |
    |                 |                 | straightforward |                 |
    |                 |                 | manner. Casadi  |                 |
    |                 |                 | uses a          |                 |
    |                 |                 | heuristic to    |                 |
    |                 |                 | decide which is |                 |
    |                 |                 | cheaper. A high |                 |
    |                 |                 | value of        |                 |
    |                 |                 | 'jac_penalty'   |                 |
    |                 |                 | makes it less   |                 |
    |                 |                 | likely for the  |                 |
    |                 |                 | heurstic to     |                 |
    |                 |                 | chose the full  |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy. The   |                 |
    |                 |                 | special value   |                 |
    |                 |                 | -1 indicates    |                 |
    |                 |                 | never to use    |                 |
    |                 |                 | the full        |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy        |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit             | OT_BOOL         | Use just-in-    | casadi::Functio |
    |                 |                 | time compiler   | nInternal       |
    |                 |                 | to speed up the |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit_options     | OT_DICT         | Options to be   | casadi::Functio |
    |                 |                 | passed to the   | nInternal       |
    |                 |                 | jit compiler.   |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | monitor         | OT_STRINGVECTOR | Monitors to be  | casadi::Functio |
    |                 |                 | activated       | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | output_scheme   | OT_STRINGVECTOR | Custom output   | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | regularity_chec | OT_BOOL         | Throw           | casadi::Functio |
    | k               |                 | exceptions when | nInternal       |
    |                 |                 | NaN or Inf      |                 |
    |                 |                 | appears during  |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | user_data       | OT_VOIDPTR      | A user-defined  | casadi::Functio |
    |                 |                 | field that can  | nInternal       |
    |                 |                 | be used to      |                 |
    |                 |                 | identify the    |                 |
    |                 |                 | function or     |                 |
    |                 |                 | pass additional |                 |
    |                 |                 | information     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | verbose         | OT_BOOL         | Verbose         | casadi::Functio |
    |                 |                 | evaluation  for | nInternal       |
    |                 |                 | debugging       |                 |
    +-----------------+-----------------+-----------------+-----------------+

    >Input scheme: casadi::QpsolInput (QPSOL_NUM_IN = 9) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | QPSOL_H                |                        | The square matrix H:   |
    |                        |                        | sparse, (n x n). Only  |
    |                        |                        | the lower triangular   |
    |                        |                        | part is actually used. |
    |                        |                        | The matrix is assumed  |
    |                        |                        | to be symmetrical.     |
    +------------------------+------------------------+------------------------+
    | QPSOL_G                |                        | The vector g: dense,   |
    |                        |                        | (n x 1)                |
    +------------------------+------------------------+------------------------+
    | QPSOL_A                |                        | The matrix A: sparse,  |
    |                        |                        | (nc x n) - product     |
    |                        |                        | with x must be dense.  |
    +------------------------+------------------------+------------------------+
    | QPSOL_LBA              |                        | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QPSOL_UBA              |                        | dense, (nc x 1)        |
    +------------------------+------------------------+------------------------+
    | QPSOL_LBX              |                        | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QPSOL_UBX              |                        | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QPSOL_X0               |                        | dense, (n x 1)         |
    +------------------------+------------------------+------------------------+
    | QPSOL_LAM_X0           |                        | dense                  |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::QpsolOutput (QPSOL_NUM_OUT = 4) []

    +-------------+-------+---------------------------------------------------+
    |  Full name  | Short |                    Description                    |
    +=============+=======+===================================================+
    | QPSOL_X     |       | The primal solution.                              |
    +-------------+-------+---------------------------------------------------+
    | QPSOL_COST  |       | The optimal cost.                                 |
    +-------------+-------+---------------------------------------------------+
    | QPSOL_LAM_A |       | The dual solution corresponding to linear bounds. |
    +-------------+-------+---------------------------------------------------+
    | QPSOL_LAM_X |       | The dual solution corresponding to simple bounds. |
    +-------------+-------+---------------------------------------------------+

    List of plugins
    ===============



    - cplex

    - gurobi

    - ooqp

    - qpoases

    - sqic

    - nlp

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Qpsol.doc("myextraplugin")



    --------------------------------------------------------------------------------

    cplex
    -----



    Interface to Cplex solver for sparse Quadratic Programs

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | cplex                  | OT_DICT                | Options to be passed   |
    |                        |                        | to CPLEX               |
    +------------------------+------------------------+------------------------+
    | dep_check              | OT_INT                 | Detect redundant       |
    |                        |                        | constraints.           |
    +------------------------+------------------------+------------------------+
    | dump_filename          | OT_STRING              | The filename to dump   |
    |                        |                        | to.                    |
    +------------------------+------------------------+------------------------+
    | dump_to_file           | OT_BOOL                | Dumps QP to file in    |
    |                        |                        | CPLEX format.          |
    +------------------------+------------------------+------------------------+
    | qp_method              | OT_INT                 | Determines which CPLEX |
    |                        |                        | algorithm to use.      |
    +------------------------+------------------------+------------------------+
    | tol                    | OT_DOUBLE              | Tolerance of solver    |
    +------------------------+------------------------+------------------------+
    | warm_start             | OT_BOOL                | Use warm start with    |
    |                        |                        | simplex methods        |
    |                        |                        | (affects only the      |
    |                        |                        | simplex methods).      |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    gurobi
    ------



    Interface to the GUROBI Solver for quadratic programming

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | vtype                  | OT_STRINGVECTOR        | Type of variables: [CO |
    |                        |                        | NTINUOUS|binary|intege |
    |                        |                        | r|semicont|semiint]    |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    ooqp
    ----



    Interface to the OOQP Solver for quadratic programming The current
    implementation assumes that OOQP is configured with the MA27 sparse linear
    solver.

    NOTE: when doing multiple calls to evaluate(), check if you need to
    reInit();

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | artol                  | OT_DOUBLE              | tolerance as provided  |
    |                        |                        | with setArTol to OOQP  |
    +------------------------+------------------------+------------------------+
    | mutol                  | OT_DOUBLE              | tolerance as provided  |
    |                        |                        | with setMuTol to OOQP  |
    +------------------------+------------------------+------------------------+
    | print_level            | OT_INT                 | Print level. OOQP      |
    |                        |                        | listens to print_level |
    |                        |                        | 0, 10 and 100          |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    qpoases
    -------



    Interface to QPOases Solver for quadratic programming

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | CPUtime                | OT_DOUBLE              | The maximum allowed    |
    |                        |                        | CPU time in seconds    |
    |                        |                        | for the whole          |
    |                        |                        | initialisation (and    |
    |                        |                        | the actually required  |
    |                        |                        | one on output).        |
    |                        |                        | Disabled if unset.     |
    +------------------------+------------------------+------------------------+
    | boundRelaxation        | OT_DOUBLE              | Initial relaxation of  |
    |                        |                        | bounds to start        |
    |                        |                        | homotopy and initial   |
    |                        |                        | value for far bounds.  |
    +------------------------+------------------------+------------------------+
    | boundTolerance         | OT_DOUBLE              | If upper and lower     |
    |                        |                        | bounds differ less     |
    |                        |                        | than this tolerance,   |
    |                        |                        | they are regarded      |
    |                        |                        | equal, i.e. as         |
    |                        |                        | equality constraint.   |
    +------------------------+------------------------+------------------------+
    | enableCholeskyRefactor | OT_INT                 | Specifies the          |
    | isation                |                        | frequency of a full    |
    |                        |                        | re-factorisation of    |
    |                        |                        | projected Hessian      |
    |                        |                        | matrix: 0: turns them  |
    |                        |                        | off, 1: uses them at   |
    |                        |                        | each iteration etc.    |
    +------------------------+------------------------+------------------------+
    | enableDriftCorrection  | OT_INT                 | Specifies the          |
    |                        |                        | frequency of drift     |
    |                        |                        | corrections: 0: turns  |
    |                        |                        | them off.              |
    +------------------------+------------------------+------------------------+
    | enableEqualities       | OT_BOOL                | Specifies whether      |
    |                        |                        | equalities should be   |
    |                        |                        | treated as always      |
    |                        |                        | active (True) or not   |
    |                        |                        | (False)                |
    +------------------------+------------------------+------------------------+
    | enableFarBounds        | OT_BOOL                | Enables the use of far |
    |                        |                        | bounds.                |
    +------------------------+------------------------+------------------------+
    | enableFlippingBounds   | OT_BOOL                | Enables the use of     |
    |                        |                        | flipping bounds.       |
    +------------------------+------------------------+------------------------+
    | enableFullLITests      | OT_BOOL                | Enables condition-     |
    |                        |                        | hardened (but more     |
    |                        |                        | expensive) LI test.    |
    +------------------------+------------------------+------------------------+
    | enableNZCTests         | OT_BOOL                | Enables nonzero        |
    |                        |                        | curvature tests.       |
    +------------------------+------------------------+------------------------+
    | enableRamping          | OT_BOOL                | Enables ramping.       |
    +------------------------+------------------------+------------------------+
    | enableRegularisation   | OT_BOOL                | Enables automatic      |
    |                        |                        | Hessian                |
    |                        |                        | regularisation.        |
    +------------------------+------------------------+------------------------+
    | epsDen                 | OT_DOUBLE              | Denominator tolerance  |
    |                        |                        | for ratio tests.       |
    +------------------------+------------------------+------------------------+
    | epsFlipping            | OT_DOUBLE              | Tolerance of squared   |
    |                        |                        | Cholesky diagonal      |
    |                        |                        | factor which triggers  |
    |                        |                        | flipping bound.        |
    +------------------------+------------------------+------------------------+
    | epsIterRef             | OT_DOUBLE              | Early termination      |
    |                        |                        | tolerance for          |
    |                        |                        | iterative refinement.  |
    +------------------------+------------------------+------------------------+
    | epsLITests             | OT_DOUBLE              | Tolerance for linear   |
    |                        |                        | independence tests.    |
    +------------------------+------------------------+------------------------+
    | epsNZCTests            | OT_DOUBLE              | Tolerance for nonzero  |
    |                        |                        | curvature tests.       |
    +------------------------+------------------------+------------------------+
    | epsNum                 | OT_DOUBLE              | Numerator tolerance    |
    |                        |                        | for ratio tests.       |
    +------------------------+------------------------+------------------------+
    | epsRegularisation      | OT_DOUBLE              | Scaling factor of      |
    |                        |                        | identity matrix used   |
    |                        |                        | for Hessian            |
    |                        |                        | regularisation.        |
    +------------------------+------------------------+------------------------+
    | finalRamping           | OT_DOUBLE              | Final value for        |
    |                        |                        | ramping strategy.      |
    +------------------------+------------------------+------------------------+
    | growFarBounds          | OT_DOUBLE              | Factor to grow far     |
    |                        |                        | bounds.                |
    +------------------------+------------------------+------------------------+
    | initialFarBounds       | OT_DOUBLE              | Initial size for far   |
    |                        |                        | bounds.                |
    +------------------------+------------------------+------------------------+
    | initialRamping         | OT_DOUBLE              | Start value for        |
    |                        |                        | ramping strategy.      |
    +------------------------+------------------------+------------------------+
    | initialStatusBounds    | OT_STRING              | Initial status of      |
    |                        |                        | bounds at first        |
    |                        |                        | iteration.             |
    +------------------------+------------------------+------------------------+
    | maxDualJump            | OT_DOUBLE              | Maximum allowed jump   |
    |                        |                        | in dual variables in   |
    |                        |                        | linear independence    |
    |                        |                        | tests.                 |
    +------------------------+------------------------+------------------------+
    | maxPrimalJump          | OT_DOUBLE              | Maximum allowed jump   |
    |                        |                        | in primal variables in |
    |                        |                        | nonzero curvature      |
    |                        |                        | tests.                 |
    +------------------------+------------------------+------------------------+
    | nWSR                   | OT_INT                 | The maximum number of  |
    |                        |                        | working set            |
    |                        |                        | recalculations to be   |
    |                        |                        | performed during the   |
    |                        |                        | initial homotopy.      |
    |                        |                        | Default is 5(nx + nc)  |
    +------------------------+------------------------+------------------------+
    | numRefinementSteps     | OT_INT                 | Maximum number of      |
    |                        |                        | iterative refinement   |
    |                        |                        | steps.                 |
    +------------------------+------------------------+------------------------+
    | numRegularisationSteps | OT_INT                 | Maximum number of      |
    |                        |                        | successive             |
    |                        |                        | regularisation steps.  |
    +------------------------+------------------------+------------------------+
    | printLevel             | OT_STRING              | Defines the amount of  |
    |                        |                        | text output during QP  |
    |                        |                        | solution, see Section  |
    |                        |                        | 5.7                    |
    +------------------------+------------------------+------------------------+
    | sparse                 | OT_BOOL                | Formulate the QP using |
    |                        |                        | sparse matrices.       |
    |                        |                        | Default: false         |
    +------------------------+------------------------+------------------------+
    | terminationTolerance   | OT_DOUBLE              | Relative termination   |
    |                        |                        | tolerance to stop      |
    |                        |                        | homotopy.              |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqic
    ----



    Interface to the SQIC solver for quadratic programming

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    nlp
    ---



    Solve QPs using an Nlpsol

    >List of available options

    +----------------+-----------+---------------------------------+
    |       Id       |   Type    |           Description           |
    +================+===========+=================================+
    | nlpsol         | OT_STRING | Name of solver.                 |
    +----------------+-----------+---------------------------------+
    | nlpsol_options | OT_DICT   | Options to be passed to solver. |
    +----------------+-----------+---------------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson


    """
  return _casadi.qpsol(*args)

def qpsol_in(*args):
  """
    qpsol_in() -> std::vector< std::string,std::allocator< std::string > >
    qpsol_in(int ind) -> std::string

    >  CASADI_EXPORT[str] qpsol_in()
    ------------------------------------------------------------------------

    Get input scheme of QP solvers.

    >  str qpsol_in(int ind)
    ------------------------------------------------------------------------

    Get QP solver input scheme name by index.


    """
  return _casadi.qpsol_in(*args)

def qpsol_out(*args):
  """
    qpsol_out() -> std::vector< std::string,std::allocator< std::string > >
    qpsol_out(int ind) -> std::string

    >  CASADI_EXPORT[str] qpsol_out()
    ------------------------------------------------------------------------

    Get QP solver output scheme of QP solvers.

    >  str qpsol_out(int ind)
    ------------------------------------------------------------------------

    Get output scheme name by index.


    """
  return _casadi.qpsol_out(*args)

def qpsol_n_in(*args):
  """
    qpsol_n_in() -> int

    Get the number of QP solver inputs.


    """
  return _casadi.qpsol_n_in(*args)

def qpsol_n_out(*args):
  """
    qpsol_n_out() -> int

    Get the number of QP solver outputs.


    """
  return _casadi.qpsol_n_out(*args)

def has_qpsol(*args):
  """
    has_qpsol(std::string const & name) -> bool

    Check if a particular plugin is available.


    """
  return _casadi.has_qpsol(*args)

def load_qpsol(*args):
  """
    load_qpsol(std::string const & name)

    Explicitly load a plugin dynamically.


    """
  return _casadi.load_qpsol(*args)

def doc_qpsol(*args):
  """
    doc_qpsol(std::string const & name) -> std::string

    Get the documentation string for a plugin.


    """
  return _casadi.doc_qpsol(*args)

def nlpsol(*args):
  """
    nlpsol(std::string const & name, std::string const & solver, casadi::SXDict const & nlp, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    nlpsol(std::string const & name, std::string const & solver, casadi::MXDict const & nlp, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    nlpsol(std::string const & name, std::string const & solver, Function nlp, casadi::Dict const & opts=casadi::Dict()) -> Function
    nlpsol(std::string const & name, std::string const & solver, std::string const & fname, 
        casadi::Dict const & opts=casadi::Dict()) -> Function
    nlpsol(std::string const & name, std::string const & solver, Compiler compiler, casadi::Dict const & opts=casadi::Dict()) -> Function

    >  Function nlpsol(str name, str solver, const str:SX &nlp, Dict opts=Dict())
    ------------------------------------------------------------------------

    Create an NLP solver Creates a solver for the following parametric nonlinear
    program (NLP):

    ::

      min          F(x, p)
      x
      
      subject to
      LBX <=   x    <= UBX
      LBG <= G(x, p) <= UBG
      p  == P
      
      nx: number of decision variables
      ng: number of constraints
      np: number of parameters



    General information
    ===================



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |   Description   |     Used in     |
    +=================+=================+=================+=================+
    | ad_weight       | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | derivative calc |                 |
    |                 |                 | ulation.When    |                 |
    |                 |                 | there is an     |                 |
    |                 |                 | option of       |                 |
    |                 |                 | either using    |                 |
    |                 |                 | forward or      |                 |
    |                 |                 | reverse mode    |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives,    |                 |
    |                 |                 | the condition a |                 |
    |                 |                 | d_weight*nf<=(1 |                 |
    |                 |                 | -ad_weight)*na  |                 |
    |                 |                 | is used where   |                 |
    |                 |                 | nf and na are   |                 |
    |                 |                 | estimates of    |                 |
    |                 |                 | the number of   |                 |
    |                 |                 | forward/reverse |                 |
    |                 |                 | mode            |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives     |                 |
    |                 |                 | needed. By      |                 |
    |                 |                 | default,        |                 |
    |                 |                 | ad_weight is    |                 |
    |                 |                 | calculated      |                 |
    |                 |                 | automatically,  |                 |
    |                 |                 | but this can be |                 |
    |                 |                 | overridden by   |                 |
    |                 |                 | setting this    |                 |
    |                 |                 | option. In      |                 |
    |                 |                 | particular, 0   |                 |
    |                 |                 | means forcing   |                 |
    |                 |                 | forward mode    |                 |
    |                 |                 | and 1 forcing   |                 |
    |                 |                 | reverse mode.   |                 |
    |                 |                 | Leave unset for |                 |
    |                 |                 | (class          |                 |
    |                 |                 | specific)       |                 |
    |                 |                 | heuristics.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | ad_weight_sp    | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | sparsity        |                 |
    |                 |                 | pattern         |                 |
    |                 |                 | calculation cal |                 |
    |                 |                 | culation.Overri |                 |
    |                 |                 | des default     |                 |
    |                 |                 | behavior. Set   |                 |
    |                 |                 | to 0 and 1 to   |                 |
    |                 |                 | force forward   |                 |
    |                 |                 | and reverse     |                 |
    |                 |                 | mode            |                 |
    |                 |                 | respectively.   |                 |
    |                 |                 | Cf. option      |                 |
    |                 |                 | "ad_weight".    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | Just-in-time    | casadi::Functio |
    |                 |                 | compiler plugin | nInternal       |
    |                 |                 | to be used.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_of   | OT_FUNCTION     | The function is | casadi::Functio |
    |                 |                 | a derivative of | nInternal       |
    |                 |                 | another         |                 |
    |                 |                 | function. The   |                 |
    |                 |                 | type of         |                 |
    |                 |                 | derivative      |                 |
    |                 |                 | (directional    |                 |
    |                 |                 | derivative,     |                 |
    |                 |                 | Jacobian) is    |                 |
    |                 |                 | inferred from   |                 |
    |                 |                 | the function    |                 |
    |                 |                 | name.           |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | eval_errors_fat | OT_BOOL         | When errors     | casadi::Nlpsol  |
    | al              |                 | occur during    |                 |
    |                 |                 | evaluation of   |                 |
    |                 |                 | f,g,...,stop    |                 |
    |                 |                 | the iterations  |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | expand          | OT_BOOL         | Replace MX with | casadi::Nlpsol  |
    |                 |                 | SX expressions  |                 |
    |                 |                 | in problem      |                 |
    |                 |                 | formulation     |                 |
    |                 |                 | [false]         |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | gather_stats    | OT_BOOL         | Flag to         | casadi::Functio |
    |                 |                 | indicate        | nInternal       |
    |                 |                 | whether         |                 |
    |                 |                 | statistics must |                 |
    |                 |                 | be gathered     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | ignore_check_ve | OT_BOOL         | If set to true, | casadi::Nlpsol  |
    | c               |                 | the input shape |                 |
    |                 |                 | of F will not   |                 |
    |                 |                 | be checked.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | input_scheme    | OT_STRINGVECTOR | Custom input    | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | inputs_check    | OT_BOOL         | Throw           | casadi::Functio |
    |                 |                 | exceptions when | nInternal       |
    |                 |                 | the numerical   |                 |
    |                 |                 | values of the   |                 |
    |                 |                 | inputs don't    |                 |
    |                 |                 | make sense      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | iteration_callb | OT_FUNCTION     | A function that | casadi::Nlpsol  |
    | ack             |                 | will be called  |                 |
    |                 |                 | at each         |                 |
    |                 |                 | iteration with  |                 |
    |                 |                 | the solver as   |                 |
    |                 |                 | input. Check    |                 |
    |                 |                 | documentation   |                 |
    |                 |                 | of Callback .   |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | iteration_callb | OT_BOOL         | If set to true, | casadi::Nlpsol  |
    | ack_ignore_erro |                 | errors thrown   |                 |
    | rs              |                 | by iteration_ca |                 |
    |                 |                 | llback will be  |                 |
    |                 |                 | ignored.        |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | iteration_callb | OT_INT          | Only call the   | casadi::Nlpsol  |
    | ack_step        |                 | callback        |                 |
    |                 |                 | function every  |                 |
    |                 |                 | few iterations. |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_penalty     | OT_DOUBLE       | When requested  | casadi::Functio |
    |                 |                 | for a number of | nInternal       |
    |                 |                 | forward/reverse |                 |
    |                 |                 | directions, it  |                 |
    |                 |                 | may be cheaper  |                 |
    |                 |                 | to compute      |                 |
    |                 |                 | first the full  |                 |
    |                 |                 | jacobian and    |                 |
    |                 |                 | then multiply   |                 |
    |                 |                 | with seeds,     |                 |
    |                 |                 | rather than     |                 |
    |                 |                 | obtain the      |                 |
    |                 |                 | requested       |                 |
    |                 |                 | directions in a |                 |
    |                 |                 | straightforward |                 |
    |                 |                 | manner. Casadi  |                 |
    |                 |                 | uses a          |                 |
    |                 |                 | heuristic to    |                 |
    |                 |                 | decide which is |                 |
    |                 |                 | cheaper. A high |                 |
    |                 |                 | value of        |                 |
    |                 |                 | 'jac_penalty'   |                 |
    |                 |                 | makes it less   |                 |
    |                 |                 | likely for the  |                 |
    |                 |                 | heurstic to     |                 |
    |                 |                 | chose the full  |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy. The   |                 |
    |                 |                 | special value   |                 |
    |                 |                 | -1 indicates    |                 |
    |                 |                 | never to use    |                 |
    |                 |                 | the full        |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy        |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit             | OT_BOOL         | Use just-in-    | casadi::Functio |
    |                 |                 | time compiler   | nInternal       |
    |                 |                 | to speed up the |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit_options     | OT_DICT         | Options to be   | casadi::Functio |
    |                 |                 | passed to the   | nInternal       |
    |                 |                 | jit compiler.   |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | monitor         | OT_STRINGVECTOR | Monitors to be  | casadi::Functio |
    |                 |                 | activated       | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | output_scheme   | OT_STRINGVECTOR | Custom output   | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | print_time      | OT_BOOL         | print           | casadi::Nlpsol  |
    |                 |                 | information     |                 |
    |                 |                 | about execution |                 |
    |                 |                 | time            |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | regularity_chec | OT_BOOL         | Throw           | casadi::Functio |
    | k               |                 | exceptions when | nInternal       |
    |                 |                 | NaN or Inf      |                 |
    |                 |                 | appears during  |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | user_data       | OT_VOIDPTR      | A user-defined  | casadi::Functio |
    |                 |                 | field that can  | nInternal       |
    |                 |                 | be used to      |                 |
    |                 |                 | identify the    |                 |
    |                 |                 | function or     |                 |
    |                 |                 | pass additional |                 |
    |                 |                 | information     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | verbose         | OT_BOOL         | Verbose         | casadi::Functio |
    |                 |                 | evaluation  for | nInternal       |
    |                 |                 | debugging       |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | verbose_init    | OT_BOOL         | Print out       | casadi::Nlpsol  |
    |                 |                 | timing          |                 |
    |                 |                 | information     |                 |
    |                 |                 | about the       |                 |
    |                 |                 | different       |                 |
    |                 |                 | stages of       |                 |
    |                 |                 | initialization  |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | warn_initial_bo | OT_BOOL         | Warn if the     | casadi::Nlpsol  |
    | unds            |                 | initial guess   |                 |
    |                 |                 | does not        |                 |
    |                 |                 | satisfy LBX and |                 |
    |                 |                 | UBX             |                 |
    +-----------------+-----------------+-----------------+-----------------+

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X0              |                        | Decision variables,    |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_P               |                        | Value of fixed         |
    |                        |                        | parameters (np x 1)    |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBX             |                        | Decision variables     |
    |                        |                        | lower bound (nx x 1),  |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBX             |                        | Decision variables     |
    |                        |                        | upper bound (nx x 1),  |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBG             |                        | Constraints lower      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBG             |                        | Constraints upper      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X,       |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G,       |
    |                        |                        | initial guess (ng x 1) |
    +------------------------+------------------------+------------------------+

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X               |                        | Decision variables at  |
    |                        |                        | the optimal solution   |
    |                        |                        | (nx x 1)               |
    +------------------------+------------------------+------------------------+
    | NLPSOL_F               |                        | Cost function value at |
    |                        |                        | the optimal solution   |
    |                        |                        | (1 x 1)                |
    +------------------------+------------------------+------------------------+
    | NLPSOL_G               |                        | Constraints function   |
    |                        |                        | at the optimal         |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X at the |
    |                        |                        | solution (nx x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G at the |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_P           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on P at the |
    |                        |                        | solution (np x 1)      |
    +------------------------+------------------------+------------------------+

    List of plugins
    ===============



    - ipopt

    - knitro

    - snopt

    - worhp

    - scpgen

    - sqpmethod

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Nlpsol.doc("myextraplugin")



    --------------------------------------------------------------------------------

    ipopt
    -----



    When in warmstart mode, output NLPSOL_LAM_X may be used as input

    NOTE: Even when max_iter == 0, it is not guaranteed that input(NLPSOL_X0) ==
    output(NLPSOL_X). Indeed if bounds on X or constraints are unmet, they will
    differ.

    For a good tutorial on IPOPT,
    seehttp://drops.dagstuhl.de/volltexte/2009/2089/pdf/09061.WaechterAndreas.Paper.2089.pdf

    A good resource about the algorithms in IPOPT is: Wachter and L. T. Biegler,
    On the Implementation of an Interior-Point Filter Line-Search Algorithm for
    Large-Scale Nonlinear Programming, Mathematical Programming 106(1), pp.
    25-57, 2006 (As Research Report RC 23149, IBM T. J. Watson Research Center,
    Yorktown, USA

    Caveats: with default options, multipliers for the decision variables are
    wrong for equality constraints. Change the 'fixed_variable_treatment' to
    'make_constraint' or 'relax_bounds' to obtain correct results.

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | con_integer_md         | OT_DICT                | Integer metadata (a    |
    |                        |                        | dictionary with lists  |
    |                        |                        | of integers) about     |
    |                        |                        | constraints to be      |
    |                        |                        | passed to IPOPT        |
    +------------------------+------------------------+------------------------+
    | con_numeric_md         | OT_DICT                | Numeric metadata (a    |
    |                        |                        | dictionary with lists  |
    |                        |                        | of reals) about        |
    |                        |                        | constraints to be      |
    |                        |                        | passed to IPOPT        |
    +------------------------+------------------------+------------------------+
    | con_string_md          | OT_DICT                | String metadata (a     |
    |                        |                        | dictionary with lists  |
    |                        |                        | of strings) about      |
    |                        |                        | constraints to be      |
    |                        |                        | passed to IPOPT        |
    +------------------------+------------------------+------------------------+
    | grad_f                 | OT_FUNCTION            | Function for           |
    |                        |                        | calculating the        |
    |                        |                        | gradient of the        |
    |                        |                        | objective (column,     |
    |                        |                        | autogenerated by       |
    |                        |                        | default)               |
    +------------------------+------------------------+------------------------+
    | grad_f_options         | OT_DICT                | Options for the        |
    |                        |                        | autogenerated gradient |
    |                        |                        | of the objective.      |
    +------------------------+------------------------+------------------------+
    | hess_lag               | OT_FUNCTION            | Function for           |
    |                        |                        | calculating the        |
    |                        |                        | Hessian of the         |
    |                        |                        | Lagrangian             |
    |                        |                        | (autogenerated by      |
    |                        |                        | default)               |
    +------------------------+------------------------+------------------------+
    | hess_lag_options       | OT_DICT                | Options for the        |
    |                        |                        | autogenerated Hessian  |
    |                        |                        | of the Lagrangian.     |
    +------------------------+------------------------+------------------------+
    | ipopt                  | OT_DICT                | Options to be passed   |
    |                        |                        | to IPOPT               |
    +------------------------+------------------------+------------------------+
    | jac_g                  | OT_FUNCTION            | Function for           |
    |                        |                        | calculating the        |
    |                        |                        | Jacobian of the        |
    |                        |                        | constraints            |
    |                        |                        | (autogenerated by      |
    |                        |                        | default)               |
    +------------------------+------------------------+------------------------+
    | jac_g_options          | OT_DICT                | Options for the        |
    |                        |                        | autogenerated Jacobian |
    |                        |                        | of the constraints.    |
    +------------------------+------------------------+------------------------+
    | pass_nonlinear_variabl | OT_BOOL                | Pass list of variables |
    | es                     |                        | entering nonlinearly   |
    |                        |                        | to IPOPT               |
    +------------------------+------------------------+------------------------+
    | var_integer_md         | OT_DICT                | Integer metadata (a    |
    |                        |                        | dictionary with lists  |
    |                        |                        | of integers) about     |
    |                        |                        | variables to be passed |
    |                        |                        | to IPOPT               |
    +------------------------+------------------------+------------------------+
    | var_numeric_md         | OT_DICT                | Numeric metadata (a    |
    |                        |                        | dictionary with lists  |
    |                        |                        | of reals) about        |
    |                        |                        | variables to be passed |
    |                        |                        | to IPOPT               |
    +------------------------+------------------------+------------------------+
    | var_string_md          | OT_DICT                | String metadata (a     |
    |                        |                        | dictionary with lists  |
    |                        |                        | of strings) about      |
    |                        |                        | variables to be passed |
    |                        |                        | to IPOPT               |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    knitro
    ------



    KNITRO interface

    >List of available options

    +---------+--------------+--------------------------------+
    |   Id    |     Type     |          Description           |
    +=========+==============+================================+
    | contype | OT_INTVECTOR | Type of constraint             |
    +---------+--------------+--------------------------------+
    | knitro  | OT_DICT      | Options to be passed to KNITRO |
    +---------+--------------+--------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    snopt
    -----



    SNOPT interface

    >List of available options

    +-------+---------+-------------------------------+
    |  Id   |  Type   |          Description          |
    +=======+=========+===============================+
    | snopt | OT_DICT | Options to be passed to SNOPT |
    +-------+---------+-------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    worhp
    -----



    WORHP interface

    >List of available options

    +-------+---------+-------------------------------+
    |  Id   |  Type   |          Description          |
    +=======+=========+===============================+
    | worhp | OT_DICT | Options to be passed to WORHP |
    +-------+---------+-------------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    scpgen
    ------



    A structure-exploiting sequential quadratic programming (to be come
    sequential convex programming) method for nonlinear programming.

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | beta                   | OT_DOUBLE              | Line-search parameter, |
    |                        |                        | restoration factor of  |
    |                        |                        | stepsize               |
    +------------------------+------------------------+------------------------+
    | c1                     | OT_DOUBLE              | Armijo condition,      |
    |                        |                        | coefficient of         |
    |                        |                        | decrease in merit      |
    +------------------------+------------------------+------------------------+
    | codegen                | OT_BOOL                | C-code generation      |
    +------------------------+------------------------+------------------------+
    | hessian_approximation  | OT_STRING              | gauss-newton|exact     |
    +------------------------+------------------------+------------------------+
    | lbfgs_memory           | OT_INT                 | Size of L-BFGS memory. |
    +------------------------+------------------------+------------------------+
    | max_iter               | OT_INT                 | Maximum number of SQP  |
    |                        |                        | iterations             |
    +------------------------+------------------------+------------------------+
    | max_iter_ls            | OT_INT                 | Maximum number of      |
    |                        |                        | linesearch iterations  |
    +------------------------+------------------------+------------------------+
    | merit_memsize          | OT_INT                 | Size of memory to      |
    |                        |                        | store history of merit |
    |                        |                        | function values        |
    +------------------------+------------------------+------------------------+
    | merit_start            | OT_DOUBLE              | Lower bound for the    |
    |                        |                        | merit function         |
    |                        |                        | parameter              |
    +------------------------+------------------------+------------------------+
    | name_x                 | OT_STRINGVECTOR        | Names of the           |
    |                        |                        | variables.             |
    +------------------------+------------------------+------------------------+
    | print_header           | OT_BOOL                | Print the header with  |
    |                        |                        | problem statistics     |
    +------------------------+------------------------+------------------------+
    | print_x                | OT_INTVECTOR           | Which variables to     |
    |                        |                        | print.                 |
    +------------------------+------------------------+------------------------+
    | qpsol                  | OT_STRING              | The QP solver to be    |
    |                        |                        | used by the SQP method |
    +------------------------+------------------------+------------------------+
    | qpsol_options          | OT_DICT                | Options to be passed   |
    |                        |                        | to the QP solver       |
    +------------------------+------------------------+------------------------+
    | reg_threshold          | OT_DOUBLE              | Threshold for the      |
    |                        |                        | regularization.        |
    +------------------------+------------------------+------------------------+
    | regularize             | OT_BOOL                | Automatic              |
    |                        |                        | regularization of      |
    |                        |                        | Lagrange Hessian.      |
    +------------------------+------------------------+------------------------+
    | tol_du                 | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | dual infeasability     |
    +------------------------+------------------------+------------------------+
    | tol_pr                 | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | primal infeasibility   |
    +------------------------+------------------------+------------------------+
    | tol_pr_step            | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | the step size          |
    +------------------------+------------------------+------------------------+
    | tol_reg                | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | regularization         |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    sqpmethod
    ---------



    A textbook SQPMethod

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | beta                   | OT_DOUBLE              | Line-search parameter, |
    |                        |                        | restoration factor of  |
    |                        |                        | stepsize               |
    +------------------------+------------------------+------------------------+
    | c1                     | OT_DOUBLE              | Armijo condition,      |
    |                        |                        | coefficient of         |
    |                        |                        | decrease in merit      |
    +------------------------+------------------------+------------------------+
    | hessian_approximation  | OT_STRING              | limited-memory|exact   |
    +------------------------+------------------------+------------------------+
    | lbfgs_memory           | OT_INT                 | Size of L-BFGS memory. |
    +------------------------+------------------------+------------------------+
    | max_iter               | OT_INT                 | Maximum number of SQP  |
    |                        |                        | iterations             |
    +------------------------+------------------------+------------------------+
    | max_iter_ls            | OT_INT                 | Maximum number of      |
    |                        |                        | linesearch iterations  |
    +------------------------+------------------------+------------------------+
    | merit_memory           | OT_INT                 | Size of memory to      |
    |                        |                        | store history of merit |
    |                        |                        | function values        |
    +------------------------+------------------------+------------------------+
    | min_step_size          | OT_DOUBLE              | The size (inf-norm) of |
    |                        |                        | the step size should   |
    |                        |                        | not become smaller     |
    |                        |                        | than this.             |
    +------------------------+------------------------+------------------------+
    | print_header           | OT_BOOL                | Print the header with  |
    |                        |                        | problem statistics     |
    +------------------------+------------------------+------------------------+
    | qpsol                  | OT_STRING              | The QP solver to be    |
    |                        |                        | used by the SQP method |
    +------------------------+------------------------+------------------------+
    | qpsol_options          | OT_DICT                | Options to be passed   |
    |                        |                        | to the QP solver       |
    +------------------------+------------------------+------------------------+
    | regularize             | OT_BOOL                | Automatic              |
    |                        |                        | regularization of      |
    |                        |                        | Lagrange Hessian.      |
    +------------------------+------------------------+------------------------+
    | tol_du                 | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | dual infeasability     |
    +------------------------+------------------------+------------------------+
    | tol_pr                 | OT_DOUBLE              | Stopping criterion for |
    |                        |                        | primal infeasibility   |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson


    """
  return _casadi.nlpsol(*args)

def nlpsol_in(*args):
  """
    nlpsol_in() -> std::vector< std::string,std::allocator< std::string > >
    nlpsol_in(int ind) -> std::string

    >  CASADI_EXPORT[str] nlpsol_in()
    ------------------------------------------------------------------------

    Get input scheme of NLP solvers.

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X0              |                        | Decision variables,    |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_P               |                        | Value of fixed         |
    |                        |                        | parameters (np x 1)    |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBX             |                        | Decision variables     |
    |                        |                        | lower bound (nx x 1),  |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBX             |                        | Decision variables     |
    |                        |                        | upper bound (nx x 1),  |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBG             |                        | Constraints lower      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBG             |                        | Constraints upper      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X,       |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G,       |
    |                        |                        | initial guess (ng x 1) |
    +------------------------+------------------------+------------------------+

    >  str nlpsol_in(int ind)
    ------------------------------------------------------------------------

    Get NLP solver input scheme name by index.

    >Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X0              |                        | Decision variables,    |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_P               |                        | Value of fixed         |
    |                        |                        | parameters (np x 1)    |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBX             |                        | Decision variables     |
    |                        |                        | lower bound (nx x 1),  |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBX             |                        | Decision variables     |
    |                        |                        | upper bound (nx x 1),  |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LBG             |                        | Constraints lower      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default -inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_UBG             |                        | Constraints upper      |
    |                        |                        | bound (ng x 1),        |
    |                        |                        | default +inf.          |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X,       |
    |                        |                        | initial guess (nx x 1) |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G0          |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G,       |
    |                        |                        | initial guess (ng x 1) |
    +------------------------+------------------------+------------------------+


    """
  return _casadi.nlpsol_in(*args)

def nlpsol_out(*args):
  """
    nlpsol_out() -> std::vector< std::string,std::allocator< std::string > >
    nlpsol_out(int ind) -> std::string

    >  CASADI_EXPORT[str] nlpsol_out()
    ------------------------------------------------------------------------

    Get NLP solver output scheme of NLP solvers.

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X               |                        | Decision variables at  |
    |                        |                        | the optimal solution   |
    |                        |                        | (nx x 1)               |
    +------------------------+------------------------+------------------------+
    | NLPSOL_F               |                        | Cost function value at |
    |                        |                        | the optimal solution   |
    |                        |                        | (1 x 1)                |
    +------------------------+------------------------+------------------------+
    | NLPSOL_G               |                        | Constraints function   |
    |                        |                        | at the optimal         |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X at the |
    |                        |                        | solution (nx x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G at the |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_P           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on P at the |
    |                        |                        | solution (np x 1)      |
    +------------------------+------------------------+------------------------+

    >  str nlpsol_out(int ind)
    ------------------------------------------------------------------------

    Get output scheme name by index.

    >Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6) []

    +------------------------+------------------------+------------------------+
    |       Full name        |         Short          |      Description       |
    +========================+========================+========================+
    | NLPSOL_X               |                        | Decision variables at  |
    |                        |                        | the optimal solution   |
    |                        |                        | (nx x 1)               |
    +------------------------+------------------------+------------------------+
    | NLPSOL_F               |                        | Cost function value at |
    |                        |                        | the optimal solution   |
    |                        |                        | (1 x 1)                |
    +------------------------+------------------------+------------------------+
    | NLPSOL_G               |                        | Constraints function   |
    |                        |                        | at the optimal         |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_X           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on X at the |
    |                        |                        | solution (nx x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_G           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on G at the |
    |                        |                        | solution (ng x 1)      |
    +------------------------+------------------------+------------------------+
    | NLPSOL_LAM_P           |                        | Lagrange multipliers   |
    |                        |                        | for bounds on P at the |
    |                        |                        | solution (np x 1)      |
    +------------------------+------------------------+------------------------+


    """
  return _casadi.nlpsol_out(*args)

def nlpsol_n_in(*args):
  """
    nlpsol_n_in() -> int

    Number of NLP solver inputs.


    """
  return _casadi.nlpsol_n_in(*args)

def nlpsol_n_out(*args):
  """
    nlpsol_n_out() -> int

    Number of NLP solver outputs.


    """
  return _casadi.nlpsol_n_out(*args)

def nlpsol_default_in(*args):
  """
    nlpsol_default_in(int ind) -> double
    nlpsol_default_in() -> std::vector< double,std::allocator< double > >

    Default input for an NLP solver.


    """
  return _casadi.nlpsol_default_in(*args)

def has_nlpsol(*args):
  """
    has_nlpsol(std::string const & name) -> bool

    Check if a particular plugin is available.


    """
  return _casadi.has_nlpsol(*args)

def load_nlpsol(*args):
  """
    load_nlpsol(std::string const & name)

    Explicitly load a plugin dynamically.


    """
  return _casadi.load_nlpsol(*args)

def doc_nlpsol(*args):
  """
    doc_nlpsol(std::string const & name) -> std::string

    Get the documentation string for a plugin.


    """
  return _casadi.doc_nlpsol(*args)

def rootfinder(*args):
  """
    rootfinder(std::string const & name, std::string const & solver, Function f, casadi::Dict const & opts=casadi::Dict()) -> Function

    Create a solver for rootfinding problems Takes a function where one of the
    inputs is unknown and one of the outputs is a residual function that is
    always zero, defines a new function where the the unknown input has been
    replaced by a guess for the unknown and the residual output has been
    replaced by the calculated value for the input.

    For a function [y0, y1, ...,yi, .., yn] = F(x0, x1, ..., xj, ..., xm), where
    xj is unknown and yi=0, defines a new function [y0, y1, ...,xj, .., yn] =
    G(x0, x1, ..., xj_guess, ..., xm),

    xj and yi must have the same dimension and d(yi)/d(xj) must be invertable.

    By default, the first input is unknown and the first output is the residual.

    General information
    ===================



    >List of available options

    +-----------------+-----------------+-----------------+-----------------+
    |       Id        |      Type       |   Description   |     Used in     |
    +=================+=================+=================+=================+
    | ad_weight       | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | derivative calc |                 |
    |                 |                 | ulation.When    |                 |
    |                 |                 | there is an     |                 |
    |                 |                 | option of       |                 |
    |                 |                 | either using    |                 |
    |                 |                 | forward or      |                 |
    |                 |                 | reverse mode    |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives,    |                 |
    |                 |                 | the condition a |                 |
    |                 |                 | d_weight*nf<=(1 |                 |
    |                 |                 | -ad_weight)*na  |                 |
    |                 |                 | is used where   |                 |
    |                 |                 | nf and na are   |                 |
    |                 |                 | estimates of    |                 |
    |                 |                 | the number of   |                 |
    |                 |                 | forward/reverse |                 |
    |                 |                 | mode            |                 |
    |                 |                 | directional     |                 |
    |                 |                 | derivatives     |                 |
    |                 |                 | needed. By      |                 |
    |                 |                 | default,        |                 |
    |                 |                 | ad_weight is    |                 |
    |                 |                 | calculated      |                 |
    |                 |                 | automatically,  |                 |
    |                 |                 | but this can be |                 |
    |                 |                 | overridden by   |                 |
    |                 |                 | setting this    |                 |
    |                 |                 | option. In      |                 |
    |                 |                 | particular, 0   |                 |
    |                 |                 | means forcing   |                 |
    |                 |                 | forward mode    |                 |
    |                 |                 | and 1 forcing   |                 |
    |                 |                 | reverse mode.   |                 |
    |                 |                 | Leave unset for |                 |
    |                 |                 | (class          |                 |
    |                 |                 | specific)       |                 |
    |                 |                 | heuristics.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | ad_weight_sp    | OT_DOUBLE       | Weighting       | casadi::Functio |
    |                 |                 | factor for      | nInternal       |
    |                 |                 | sparsity        |                 |
    |                 |                 | pattern         |                 |
    |                 |                 | calculation cal |                 |
    |                 |                 | culation.Overri |                 |
    |                 |                 | des default     |                 |
    |                 |                 | behavior. Set   |                 |
    |                 |                 | to 0 and 1 to   |                 |
    |                 |                 | force forward   |                 |
    |                 |                 | and reverse     |                 |
    |                 |                 | mode            |                 |
    |                 |                 | respectively.   |                 |
    |                 |                 | Cf. option      |                 |
    |                 |                 | "ad_weight".    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | compiler        | OT_STRING       | Just-in-time    | casadi::Functio |
    |                 |                 | compiler plugin | nInternal       |
    |                 |                 | to be used.     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | constraints     | OT_INTVECTOR    | Constrain the   | casadi::Rootfin |
    |                 |                 | unknowns. 0     | der             |
    |                 |                 | (default): no   |                 |
    |                 |                 | constraint on   |                 |
    |                 |                 | ui, 1: ui >=    |                 |
    |                 |                 | 0.0, -1: ui <=  |                 |
    |                 |                 | 0.0, 2: ui >    |                 |
    |                 |                 | 0.0, -2: ui <   |                 |
    |                 |                 | 0.0.            |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | derivative_of   | OT_FUNCTION     | The function is | casadi::Functio |
    |                 |                 | a derivative of | nInternal       |
    |                 |                 | another         |                 |
    |                 |                 | function. The   |                 |
    |                 |                 | type of         |                 |
    |                 |                 | derivative      |                 |
    |                 |                 | (directional    |                 |
    |                 |                 | derivative,     |                 |
    |                 |                 | Jacobian) is    |                 |
    |                 |                 | inferred from   |                 |
    |                 |                 | the function    |                 |
    |                 |                 | name.           |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | gather_stats    | OT_BOOL         | Flag to         | casadi::Functio |
    |                 |                 | indicate        | nInternal       |
    |                 |                 | whether         |                 |
    |                 |                 | statistics must |                 |
    |                 |                 | be gathered     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_input  | OT_INT          | Index of the    | casadi::Rootfin |
    |                 |                 | input that      | der             |
    |                 |                 | corresponds to  |                 |
    |                 |                 | the actual      |                 |
    |                 |                 | root-finding    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | implicit_output | OT_INT          | Index of the    | casadi::Rootfin |
    |                 |                 | output that     | der             |
    |                 |                 | corresponds to  |                 |
    |                 |                 | the actual      |                 |
    |                 |                 | root-finding    |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | input_scheme    | OT_STRINGVECTOR | Custom input    | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | inputs_check    | OT_BOOL         | Throw           | casadi::Functio |
    |                 |                 | exceptions when | nInternal       |
    |                 |                 | the numerical   |                 |
    |                 |                 | values of the   |                 |
    |                 |                 | inputs don't    |                 |
    |                 |                 | make sense      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jac_penalty     | OT_DOUBLE       | When requested  | casadi::Functio |
    |                 |                 | for a number of | nInternal       |
    |                 |                 | forward/reverse |                 |
    |                 |                 | directions, it  |                 |
    |                 |                 | may be cheaper  |                 |
    |                 |                 | to compute      |                 |
    |                 |                 | first the full  |                 |
    |                 |                 | jacobian and    |                 |
    |                 |                 | then multiply   |                 |
    |                 |                 | with seeds,     |                 |
    |                 |                 | rather than     |                 |
    |                 |                 | obtain the      |                 |
    |                 |                 | requested       |                 |
    |                 |                 | directions in a |                 |
    |                 |                 | straightforward |                 |
    |                 |                 | manner. Casadi  |                 |
    |                 |                 | uses a          |                 |
    |                 |                 | heuristic to    |                 |
    |                 |                 | decide which is |                 |
    |                 |                 | cheaper. A high |                 |
    |                 |                 | value of        |                 |
    |                 |                 | 'jac_penalty'   |                 |
    |                 |                 | makes it less   |                 |
    |                 |                 | likely for the  |                 |
    |                 |                 | heurstic to     |                 |
    |                 |                 | chose the full  |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy. The   |                 |
    |                 |                 | special value   |                 |
    |                 |                 | -1 indicates    |                 |
    |                 |                 | never to use    |                 |
    |                 |                 | the full        |                 |
    |                 |                 | Jacobian        |                 |
    |                 |                 | strategy        |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jacobian_functi | OT_FUNCTION     | Function object | casadi::Rootfin |
    | on              |                 | for calculating | der             |
    |                 |                 | the Jacobian    |                 |
    |                 |                 | (autogenerated  |                 |
    |                 |                 | by default)     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit             | OT_BOOL         | Use just-in-    | casadi::Functio |
    |                 |                 | time compiler   | nInternal       |
    |                 |                 | to speed up the |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | jit_options     | OT_DICT         | Options to be   | casadi::Functio |
    |                 |                 | passed to the   | nInternal       |
    |                 |                 | jit compiler.   |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver   | OT_STRING       | User-defined    | casadi::Rootfin |
    |                 |                 | linear solver   | der             |
    |                 |                 | class. Needed   |                 |
    |                 |                 | for             |                 |
    |                 |                 | sensitivities.  |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | linear_solver_o | OT_DICT         | Options to be   | casadi::Rootfin |
    | ptions          |                 | passed to the   | der             |
    |                 |                 | linear solver.  |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | monitor         | OT_STRINGVECTOR | Monitors to be  | casadi::Functio |
    |                 |                 | activated       | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | output_scheme   | OT_STRINGVECTOR | Custom output   | casadi::Functio |
    |                 |                 | scheme          | nInternal       |
    +-----------------+-----------------+-----------------+-----------------+
    | regularity_chec | OT_BOOL         | Throw           | casadi::Functio |
    | k               |                 | exceptions when | nInternal       |
    |                 |                 | NaN or Inf      |                 |
    |                 |                 | appears during  |                 |
    |                 |                 | evaluation      |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | user_data       | OT_VOIDPTR      | A user-defined  | casadi::Functio |
    |                 |                 | field that can  | nInternal       |
    |                 |                 | be used to      |                 |
    |                 |                 | identify the    |                 |
    |                 |                 | function or     |                 |
    |                 |                 | pass additional |                 |
    |                 |                 | information     |                 |
    +-----------------+-----------------+-----------------+-----------------+
    | verbose         | OT_BOOL         | Verbose         | casadi::Functio |
    |                 |                 | evaluation  for | nInternal       |
    |                 |                 | debugging       |                 |
    +-----------------+-----------------+-----------------+-----------------+

    List of plugins
    ===============



    - kinsol

    - nlpsol

    - newton

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Rootfinder.doc("myextraplugin")



    --------------------------------------------------------------------------------

    kinsol
    ------



    KINSOL interface from the Sundials suite

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | abstol                 | OT_DOUBLE              | Stopping criterion     |
    |                        |                        | tolerance              |
    +------------------------+------------------------+------------------------+
    | disable_internal_warni | OT_BOOL                | Disable KINSOL         |
    | ngs                    |                        | internal warning       |
    |                        |                        | messages               |
    +------------------------+------------------------+------------------------+
    | exact_jacobian         | OT_BOOL                | Use exact Jacobian     |
    |                        |                        | information            |
    +------------------------+------------------------+------------------------+
    | f_scale                | OT_DOUBLEVECTOR        | Equation scaling       |
    |                        |                        | factors                |
    +------------------------+------------------------+------------------------+
    | iterative_solver       | OT_STRING              | gmres|bcgstab|tfqmr    |
    +------------------------+------------------------+------------------------+
    | linear_solver_type     | OT_STRING              | dense|banded|iterative |
    |                        |                        | |user_defined          |
    +------------------------+------------------------+------------------------+
    | lower_bandwidth        | OT_INT                 | Lower bandwidth for    |
    |                        |                        | banded linear solvers  |
    +------------------------+------------------------+------------------------+
    | max_iter               | OT_INT                 | Maximum number of      |
    |                        |                        | Newton iterations.     |
    |                        |                        | Putting 0 sets the     |
    |                        |                        | default value of       |
    |                        |                        | KinSol.                |
    +------------------------+------------------------+------------------------+
    | max_krylov             | OT_INT                 | Maximum Krylov space   |
    |                        |                        | dimension              |
    +------------------------+------------------------+------------------------+
    | pretype                | OT_STRING              | Type of preconditioner |
    +------------------------+------------------------+------------------------+
    | strategy               | OT_STRING              | Globalization strategy |
    +------------------------+------------------------+------------------------+
    | u_scale                | OT_DOUBLEVECTOR        | Variable scaling       |
    |                        |                        | factors                |
    +------------------------+------------------------+------------------------+
    | upper_bandwidth        | OT_INT                 | Upper bandwidth for    |
    |                        |                        | banded linear solvers  |
    +------------------------+------------------------+------------------------+
    | use_preconditioner     | OT_BOOL                | Precondition an        |
    |                        |                        | iterative solver       |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    nlpsol
    ------





    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    newton
    ------



    Implements simple newton iterations to solve an implicit function.

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | abstol                 | OT_DOUBLE              | Stopping criterion     |
    |                        |                        | tolerance on max(|F|)  |
    +------------------------+------------------------+------------------------+
    | abstolStep             | OT_DOUBLE              | Stopping criterion     |
    |                        |                        | tolerance on step size |
    +------------------------+------------------------+------------------------+
    | max_iter               | OT_INT                 | Maximum number of      |
    |                        |                        | Newton iterations to   |
    |                        |                        | perform before         |
    |                        |                        | returning.             |
    +------------------------+------------------------+------------------------+
    | print_iteration        | OT_BOOL                | Print information      |
    |                        |                        | about each iteration   |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson


    """
  return _casadi.rootfinder(*args)

def has_rootfinder(*args):
  """
    has_rootfinder(std::string const & name) -> bool

    Check if a particular plugin is available.


    """
  return _casadi.has_rootfinder(*args)

def load_rootfinder(*args):
  """
    load_rootfinder(std::string const & name)

    Explicitly load a plugin dynamically.


    """
  return _casadi.load_rootfinder(*args)

def doc_rootfinder(*args):
  """
    doc_rootfinder(std::string const & name) -> std::string

    Get the documentation string for a plugin.


    """
  return _casadi.doc_rootfinder(*args)

def linsol(*args):
  """
    linsol(std::string const & name, std::string const & solver, Sparsity sp, int nrhs, casadi::Dict const & opts=casadi::Dict()) -> Function

    Create a solver for linear systems of equations Solves the linear system A*X
    = B or A^T*X = B for X with A square and non-singular

    If A is structurally singular, an error will be thrown during init. If A is
    numerically singular, the prepare step will fail.

    The usual procedure to use Linsol is: init()

    set the first input (A)

    prepare()

    set the second input (b)

    solve()

    Repeat steps 4 and 5 to work with other b vectors.

    The standard evaluation combines the prepare() and solve() step and may
    therefore more expensive if A is invariant.

    General information
    ===================



    >Input scheme: casadi::LinsolInput (LINSOL_NUM_IN = 2) []

    +-----------+-------+----------------------------------------------+
    | Full name | Short |                 Description                  |
    +===========+=======+==============================================+
    | LINSOL_A  |       | The square matrix A: sparse, (n x n)         |
    +-----------+-------+----------------------------------------------+
    | LINSOL_B  |       | The right-hand-side matrix b: dense, (n x m) |
    +-----------+-------+----------------------------------------------+

    >Output scheme: casadi::LinsolOutput (LINSOL_NUM_OUT = 1) []

    +-----------+-------+---------------------------------------------+
    | Full name | Short |                 Description                 |
    +===========+=======+=============================================+
    | LINSOL_X  |       | Solution to the linear system of equations. |
    +-----------+-------+---------------------------------------------+

    List of plugins
    ===============



    - csparsecholesky

    - csparse

    - lapacklu

    - lapackqr

    - symbolicqr

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Linsol.doc("myextraplugin")



    --------------------------------------------------------------------------------

    csparsecholesky
    ---------------



    Linsol with CSparseCholesky Interface

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    csparse
    -------



    Linsol with CSparse Interface

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    lapacklu
    --------



    This class solves the linear system A.x=b by making an LU factorization of
    A: A = L.U, with L lower and U upper triangular

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | allow_equilibration_fa | OT_BOOL                | Non-fatal error when   |
    | ilure                  |                        | equilibration fails    |
    +------------------------+------------------------+------------------------+
    | equilibration          | OT_BOOL                | Equilibrate the matrix |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    lapackqr
    --------



    This class solves the linear system A.x=b by making an QR factorization of
    A: A = Q.R, with Q orthogonal and R upper triangular

    --------------------------------------------------------------------------------





    --------------------------------------------------------------------------------

    symbolicqr
    ----------



    Linsol based on QR factorization with sparsity pattern based reordering
    without partial pivoting

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | codegen                | OT_BOOL                | C-code generation      |
    +------------------------+------------------------+------------------------+
    | compiler               | OT_STRING              | Compiler command to be |
    |                        |                        | used for compiling     |
    |                        |                        | generated code         |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    Joel Andersson


    """
  return _casadi.linsol(*args)

def has_linsol(*args):
  """
    has_linsol(std::string const & name) -> bool

    Check if a particular plugin is available.


    """
  return _casadi.has_linsol(*args)

def load_linsol(*args):
  """
    load_linsol(std::string const & name)

    Explicitly load a plugin dynamically.


    """
  return _casadi.load_linsol(*args)

def doc_linsol(*args):
  """
    doc_linsol(std::string const & name) -> std::string

    Get the documentation string for a plugin.


    """
  return _casadi.doc_linsol(*args)

def linsol_n_in(*args):
  """
    linsol_n_in() -> int

    Number of linear solver inputs.


    """
  return _casadi.linsol_n_in(*args)

def linsol_n_out(*args):
  """
    linsol_n_out() -> int

    Number of linear solver outputs.


    """
  return _casadi.linsol_n_out(*args)

def linsol_in(*args):
  """
    linsol_in() -> std::vector< std::string,std::allocator< std::string > >
    linsol_in(int ind) -> std::string

    Linear solver input scheme.


    """
  return _casadi.linsol_in(*args)

def linsol_out(*args):
  """
    linsol_out() -> std::vector< std::string,std::allocator< std::string > >
    linsol_out(int ind) -> std::string

    Linear solver output scheme.


    """
  return _casadi.linsol_out(*args)
class CodeGenerator(_object):
    """
    C++ includes:
    code_generator.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CodeGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CodeGenerator, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::CodeGenerator self, casadi::Dict const & opts=casadi::Dict()) -> CodeGenerator

        Constructor.


        """
        this = _casadi.new_CodeGenerator(*args)
        try: self.this.append(this)
        except: self.this = this
    def add(self, *args):
        """
        add(CodeGenerator self, Function f)

        Add a function (name generated)


        """
        return _casadi.CodeGenerator_add(self, *args)

    def generate(self, *args):
        """
        generate(CodeGenerator self, std::string const & name)
        generate(CodeGenerator self) -> std::string

        >  void CodeGenerator.generate(str name) const 
        ------------------------------------------------------------------------

        Generate a file.

        >  str CodeGenerator.generate() const 
        ------------------------------------------------------------------------

        Generate a file, return code as string.


        """
        return _casadi.CodeGenerator_generate(self, *args)

    def compile(self, *args):
        """
        compile(CodeGenerator self, std::string const & name, std::string const & compiler="gcc -fPIC -O2") -> std::string

        Compile and load function.


        """
        return _casadi.CodeGenerator_compile(self, *args)

    def addInclude(self, *args):
        """
        addInclude(CodeGenerator self, std::string const & new_include, bool relative_path=False, std::string const & use_ifdef=std::string())

        Add an include file optionally using a relative path "..." instead of an
        absolute path <...>


        """
        return _casadi.CodeGenerator_addInclude(self, *args)

    __swig_destroy__ = _casadi.delete_CodeGenerator
CodeGenerator_swigregister = _casadi.CodeGenerator_swigregister
CodeGenerator_swigregister(CodeGenerator)

FLAG = _casadi.FLAG

def _horzcat(*args):
  """
    _horzcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v) -> Sparsity
    _horzcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v) -> MX
    _horzcat(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & v) -> IM
    _horzcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v) -> DM
    _horzcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v) -> SX
    """
  return _casadi._horzcat(*args)

def _vertcat(*args):
  """
    _vertcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v) -> Sparsity
    _vertcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v) -> MX
    _vertcat(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & v) -> IM
    _vertcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v) -> DM
    _vertcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v) -> SX
    """
  return _casadi._vertcat(*args)

def horzsplit(*args):
  """
    horzsplit(Sparsity v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    horzsplit(Sparsity v, int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    horzsplit(MX v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    horzsplit(MX v, int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    horzsplit(IM v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    horzsplit(IM v, int incr=1) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    horzsplit(DM v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    horzsplit(DM v, int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    horzsplit(SX v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    horzsplit(SX v, int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    """
  return _casadi.horzsplit(*args)

def offset(*args):
  """
    offset(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v, bool vert=True) -> std::vector< int,std::allocator< int > >
    offset(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, bool vert=True) -> std::vector< int,std::allocator< int > >
    offset(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & v, 
        bool vert=True) -> std::vector< int,std::allocator< int > >
    offset(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, 
        bool vert=True) -> std::vector< int,std::allocator< int > >
    offset(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, 
        bool vert=True) -> std::vector< int,std::allocator< int > >
    """
  return _casadi.offset(*args)

def vertsplit(*args):
  """
    vertsplit(Sparsity v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    vertsplit(Sparsity v, int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    vertsplit(MX v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    vertsplit(MX v, int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    vertsplit(IM v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    vertsplit(IM v, int incr=1) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    vertsplit(DM v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    vertsplit(DM v, int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    vertsplit(SX v, std::vector< int,std::allocator< int > > const & offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    vertsplit(SX v, int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    """
  return _casadi.vertsplit(*args)

def blockcat(*args):
  """
    blockcat(std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > > const & v) -> Sparsity
    blockcat(Sparsity A, Sparsity B, Sparsity C, Sparsity D) -> Sparsity
    blockcat(std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & v) -> MX
    blockcat(MX A, MX B, MX C, MX D) -> MX
    blockcat(std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > > const & v) -> IM
    blockcat(IM A, IM B, IM C, IM D) -> IM
    blockcat(std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const & v) -> DM
    blockcat(DM A, DM B, DM C, DM D) -> DM
    blockcat(std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const & v) -> SX
    blockcat(SX A, SX B, SX C, SX D) -> SX
    """
  return _casadi.blockcat(*args)

def blocksplit(*args):
  """
    blocksplit(Sparsity x, std::vector< int,std::allocator< int > > const & vert_offset, std::vector< int,std::allocator< int > > const & horz_offset) -> std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > >
    blocksplit(Sparsity x, int vert_incr=1, int horz_incr=1) -> std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > >
    blocksplit(MX x, std::vector< int,std::allocator< int > > const & vert_offset, std::vector< int,std::allocator< int > > const & horz_offset) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >
    blocksplit(MX x, int vert_incr=1, int horz_incr=1) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >
    blocksplit(IM x, std::vector< int,std::allocator< int > > const & vert_offset, std::vector< int,std::allocator< int > > const & horz_offset) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >
    blocksplit(IM x, int vert_incr=1, int horz_incr=1) -> std::vector< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >,std::allocator< std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > > >
    blocksplit(DM x, std::vector< int,std::allocator< int > > const & vert_offset, std::vector< int,std::allocator< int > > const & horz_offset) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >
    blocksplit(DM x, int vert_incr=1, int horz_incr=1) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >
    blocksplit(SX x, std::vector< int,std::allocator< int > > const & vert_offset, std::vector< int,std::allocator< int > > const & horz_offset) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >
    blocksplit(SX x, int vert_incr=1, int horz_incr=1) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >
    """
  return _casadi.blocksplit(*args)

def _diagcat(*args):
  """
    _diagcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & A) -> Sparsity
    _diagcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & A) -> MX
    _diagcat(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & A) -> IM
    _diagcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & A) -> DM
    _diagcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & A) -> SX
    """
  return _casadi._diagcat(*args)

def diagsplit(*args):
  """
    diagsplit(Sparsity x, std::vector< int,std::allocator< int > > const & output_offset1, std::vector< int,std::allocator< int > > const & output_offset2) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    diagsplit(Sparsity x, std::vector< int,std::allocator< int > > const & output_offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    diagsplit(Sparsity x, int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    diagsplit(Sparsity x, int incr1, int incr2) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >
    diagsplit(MX x, std::vector< int,std::allocator< int > > const & output_offset1, std::vector< int,std::allocator< int > > const & output_offset2) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    diagsplit(MX x, std::vector< int,std::allocator< int > > const & output_offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    diagsplit(MX x, int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    diagsplit(MX x, int incr1, int incr2) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    diagsplit(IM x, std::vector< int,std::allocator< int > > const & output_offset1, std::vector< int,std::allocator< int > > const & output_offset2) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    diagsplit(IM x, std::vector< int,std::allocator< int > > const & output_offset) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    diagsplit(IM x, int incr=1) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    diagsplit(IM x, int incr1, int incr2) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    diagsplit(DM x, std::vector< int,std::allocator< int > > const & output_offset1, std::vector< int,std::allocator< int > > const & output_offset2) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    diagsplit(DM x, std::vector< int,std::allocator< int > > const & output_offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    diagsplit(DM x, int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    diagsplit(DM x, int incr1, int incr2) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    diagsplit(SX x, std::vector< int,std::allocator< int > > const & output_offset1, std::vector< int,std::allocator< int > > const & output_offset2) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    diagsplit(SX x, std::vector< int,std::allocator< int > > const & output_offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    diagsplit(SX x, int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    diagsplit(SX x, int incr1, int incr2) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    """
  return _casadi.diagsplit(*args)

def _veccat(*args):
  """
    _veccat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & x) -> Sparsity
    _veccat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & x) -> MX
    _veccat(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & x) -> IM
    _veccat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & x) -> DM
    _veccat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & x) -> SX
    """
  return _casadi._veccat(*args)

def mtimes(*args):
  """
    mtimes(Sparsity x, Sparsity y) -> Sparsity
    mtimes(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & args) -> Sparsity
    mtimes(MX x, MX y) -> MX
    mtimes(std::vector< casadi::MX,std::allocator< casadi::MX > > const & args) -> MX
    mtimes(IM x, IM y) -> IM
    mtimes(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & args) -> IM
    mtimes(DM x, DM y) -> DM
    mtimes(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & args) -> DM
    mtimes(SX x, SX y) -> SX
    mtimes(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & args) -> SX

    [INTERNAL]  Sparse matrix-
    matrix multiplication: z <- z + x*y.


    """
  return _casadi.mtimes(*args)

def mac(*args):
  """
    mac(Sparsity X, Sparsity Y, Sparsity Z) -> Sparsity
    mac(MX X, MX Y, MX Z) -> MX
    mac(IM X, IM Y, IM Z) -> IM
    mac(DM X, DM Y, DM Z) -> DM
    mac(SX X, SX Y, SX Z) -> SX
    """
  return _casadi.mac(*args)

def transpose(*args):
  """
    transpose(Sparsity X) -> Sparsity
    transpose(MX X) -> MX
    transpose(IM X) -> IM
    transpose(DM X) -> DM
    transpose(SX X) -> SX
    """
  return _casadi.transpose(*args)

def vec(*args):
  """
    vec(Sparsity a) -> Sparsity
    vec(MX a) -> MX
    vec(IM a) -> IM
    vec(DM a) -> DM
    vec(SX a) -> SX
    """
  return _casadi.vec(*args)

def reshape(*args):
  """
    reshape(Sparsity a, int nrow, int ncol) -> Sparsity
    reshape(Sparsity a, std::pair< int,int > rc) -> Sparsity
    reshape(Sparsity a, Sparsity sp) -> Sparsity
    reshape(MX a, int nrow, int ncol) -> MX
    reshape(MX a, std::pair< int,int > rc) -> MX
    reshape(MX a, Sparsity sp) -> MX
    reshape(IM a, int nrow, int ncol) -> IM
    reshape(IM a, std::pair< int,int > rc) -> IM
    reshape(IM a, Sparsity sp) -> IM
    reshape(DM a, int nrow, int ncol) -> DM
    reshape(DM a, std::pair< int,int > rc) -> DM
    reshape(DM a, Sparsity sp) -> DM
    reshape(SX a, int nrow, int ncol) -> SX
    reshape(SX a, std::pair< int,int > rc) -> SX
    reshape(SX a, Sparsity sp) -> SX
    """
  return _casadi.reshape(*args)

def sprank(*args):
  """
    sprank(Sparsity A) -> int
    sprank(MX A) -> int
    sprank(IM A) -> int
    sprank(DM A) -> int
    sprank(SX A) -> int
    """
  return _casadi.sprank(*args)

def norm_0_mul(*args):
  """
    norm_0_mul(Sparsity x, Sparsity y) -> int
    norm_0_mul(MX x, MX y) -> int
    norm_0_mul(IM x, IM y) -> int
    norm_0_mul(DM x, DM y) -> int
    norm_0_mul(SX x, SX y) -> int
    """
  return _casadi.norm_0_mul(*args)

def triu(*args):
  """
    triu(Sparsity a, bool includeDiagonal=True) -> Sparsity
    triu(MX a, bool includeDiagonal=True) -> MX
    triu(IM a, bool includeDiagonal=True) -> IM
    triu(DM a, bool includeDiagonal=True) -> DM
    triu(SX a, bool includeDiagonal=True) -> SX
    """
  return _casadi.triu(*args)

def tril(*args):
  """
    tril(Sparsity a, bool includeDiagonal=True) -> Sparsity
    tril(MX a, bool includeDiagonal=True) -> MX
    tril(IM a, bool includeDiagonal=True) -> IM
    tril(DM a, bool includeDiagonal=True) -> DM
    tril(SX a, bool includeDiagonal=True) -> SX
    """
  return _casadi.tril(*args)

def kron(*args):
  """
    kron(Sparsity a, Sparsity b) -> Sparsity
    kron(MX a, MX b) -> MX
    kron(IM a, IM b) -> IM
    kron(DM a, DM b) -> DM
    kron(SX a, SX b) -> SX
    """
  return _casadi.kron(*args)

def repmat(*args):
  """
    repmat(Sparsity A, int n, int m=1) -> Sparsity
    repmat(Sparsity A, std::pair< int,int > const & rc) -> Sparsity
    repmat(MX A, int n, int m=1) -> MX
    repmat(MX A, std::pair< int,int > const & rc) -> MX
    repmat(IM A, int n, int m=1) -> IM
    repmat(IM A, std::pair< int,int > const & rc) -> IM
    repmat(DM A, int n, int m=1) -> DM
    repmat(DM A, std::pair< int,int > const & rc) -> DM
    repmat(SX A, int n, int m=1) -> SX
    repmat(SX A, std::pair< int,int > const & rc) -> SX
    """
  return _casadi.repmat(*args)

def plus(*args):
  """
    plus(MX x, MX y) -> MX
    plus(IM x, IM y) -> IM
    plus(DM x, DM y) -> DM
    plus(SX x, SX y) -> SX
    plus(double const & x, double const & y) -> double
    """
  return _casadi.plus(*args)

def minus(*args):
  """
    minus(MX x, MX y) -> MX
    minus(IM x, IM y) -> IM
    minus(DM x, DM y) -> DM
    minus(SX x, SX y) -> SX
    minus(double const & x, double const & y) -> double
    """
  return _casadi.minus(*args)

def times(*args):
  """
    times(MX x, MX y) -> MX
    times(IM x, IM y) -> IM
    times(DM x, DM y) -> DM
    times(SX x, SX y) -> SX
    times(double const & x, double const & y) -> double
    """
  return _casadi.times(*args)

def rdivide(*args):
  """
    rdivide(MX x, MX y) -> MX
    rdivide(IM x, IM y) -> IM
    rdivide(DM x, DM y) -> DM
    rdivide(SX x, SX y) -> SX
    rdivide(double const & x, double const & y) -> double
    """
  return _casadi.rdivide(*args)

def ldivide(*args):
  """
    ldivide(MX x, MX y) -> MX
    ldivide(IM x, IM y) -> IM
    ldivide(DM x, DM y) -> DM
    ldivide(SX x, SX y) -> SX
    ldivide(double const & x, double const & y) -> double
    """
  return _casadi.ldivide(*args)

def lt(*args):
  """
    lt(MX x, MX y) -> MX
    lt(IM x, IM y) -> IM
    lt(DM x, DM y) -> DM
    lt(SX x, SX y) -> SX
    lt(double const & x, double const & y) -> double
    """
  return _casadi.lt(*args)

def le(*args):
  """
    le(MX x, MX y) -> MX
    le(IM x, IM y) -> IM
    le(DM x, DM y) -> DM
    le(SX x, SX y) -> SX
    le(double const & x, double const & y) -> double
    """
  return _casadi.le(*args)

def gt(*args):
  """
    gt(MX x, MX y) -> MX
    gt(IM x, IM y) -> IM
    gt(DM x, DM y) -> DM
    gt(SX x, SX y) -> SX
    gt(double const & x, double const & y) -> double
    """
  return _casadi.gt(*args)

def ge(*args):
  """
    ge(MX x, MX y) -> MX
    ge(IM x, IM y) -> IM
    ge(DM x, DM y) -> DM
    ge(SX x, SX y) -> SX
    ge(double const & x, double const & y) -> double
    """
  return _casadi.ge(*args)

def eq(*args):
  """
    eq(MX x, MX y) -> MX
    eq(IM x, IM y) -> IM
    eq(DM x, DM y) -> DM
    eq(SX x, SX y) -> SX
    eq(double const & x, double const & y) -> double
    """
  return _casadi.eq(*args)

def ne(*args):
  """
    ne(MX x, MX y) -> MX
    ne(IM x, IM y) -> IM
    ne(DM x, DM y) -> DM
    ne(SX x, SX y) -> SX
    ne(double const & x, double const & y) -> double
    """
  return _casadi.ne(*args)

def logic_and(*args):
  """
    logic_and(MX x, MX y) -> MX
    logic_and(IM x, IM y) -> IM
    logic_and(DM x, DM y) -> DM
    logic_and(SX x, SX y) -> SX
    logic_and(double const & x, double const & y) -> double
    """
  return _casadi.logic_and(*args)

def logic_or(*args):
  """
    logic_or(MX x, MX y) -> MX
    logic_or(IM x, IM y) -> IM
    logic_or(DM x, DM y) -> DM
    logic_or(SX x, SX y) -> SX
    logic_or(double const & x, double const & y) -> double
    """
  return _casadi.logic_or(*args)

def logic_not(*args):
  """
    logic_not(MX x) -> MX
    logic_not(IM x) -> IM
    logic_not(DM x) -> DM
    logic_not(SX x) -> SX
    logic_not(double const & x) -> double
    """
  return _casadi.logic_not(*args)

def fabs(*args):
  """
    fabs(MX x) -> MX
    fabs(IM x) -> IM
    fabs(DM x) -> DM
    fabs(SX x) -> SX
    fabs(double const & x) -> double
    """
  return _casadi.fabs(*args)

def sqrt(*args):
  """
    sqrt(MX x) -> MX
    sqrt(IM x) -> IM
    sqrt(DM x) -> DM
    sqrt(SX x) -> SX
    sqrt(double const & x) -> double
    """
  return _casadi.sqrt(*args)

def sin(*args):
  """
    sin(MX x) -> MX
    sin(IM x) -> IM
    sin(DM x) -> DM
    sin(SX x) -> SX
    sin(double const & x) -> double
    """
  return _casadi.sin(*args)

def cos(*args):
  """
    cos(MX x) -> MX
    cos(IM x) -> IM
    cos(DM x) -> DM
    cos(SX x) -> SX
    cos(double const & x) -> double
    """
  return _casadi.cos(*args)

def tan(*args):
  """
    tan(MX x) -> MX
    tan(IM x) -> IM
    tan(DM x) -> DM
    tan(SX x) -> SX
    tan(double const & x) -> double
    """
  return _casadi.tan(*args)

def atan(*args):
  """
    atan(MX x) -> MX
    atan(IM x) -> IM
    atan(DM x) -> DM
    atan(SX x) -> SX
    atan(double const & x) -> double
    """
  return _casadi.atan(*args)

def asin(*args):
  """
    asin(MX x) -> MX
    asin(IM x) -> IM
    asin(DM x) -> DM
    asin(SX x) -> SX
    asin(double const & x) -> double
    """
  return _casadi.asin(*args)

def acos(*args):
  """
    acos(MX x) -> MX
    acos(IM x) -> IM
    acos(DM x) -> DM
    acos(SX x) -> SX
    acos(double const & x) -> double
    """
  return _casadi.acos(*args)

def tanh(*args):
  """
    tanh(MX x) -> MX
    tanh(IM x) -> IM
    tanh(DM x) -> DM
    tanh(SX x) -> SX
    tanh(double const & x) -> double
    """
  return _casadi.tanh(*args)

def sinh(*args):
  """
    sinh(MX x) -> MX
    sinh(IM x) -> IM
    sinh(DM x) -> DM
    sinh(SX x) -> SX
    sinh(double const & x) -> double
    """
  return _casadi.sinh(*args)

def cosh(*args):
  """
    cosh(MX x) -> MX
    cosh(IM x) -> IM
    cosh(DM x) -> DM
    cosh(SX x) -> SX
    cosh(double const & x) -> double
    """
  return _casadi.cosh(*args)

def atanh(*args):
  """
    atanh(MX x) -> MX
    atanh(IM x) -> IM
    atanh(DM x) -> DM
    atanh(SX x) -> SX
    atanh(double const & x) -> double
    """
  return _casadi.atanh(*args)

def asinh(*args):
  """
    asinh(MX x) -> MX
    asinh(IM x) -> IM
    asinh(DM x) -> DM
    asinh(SX x) -> SX
    asinh(double const & x) -> double
    """
  return _casadi.asinh(*args)

def acosh(*args):
  """
    acosh(MX x) -> MX
    acosh(IM x) -> IM
    acosh(DM x) -> DM
    acosh(SX x) -> SX
    acosh(double const & x) -> double
    """
  return _casadi.acosh(*args)

def exp(*args):
  """
    exp(MX x) -> MX
    exp(IM x) -> IM
    exp(DM x) -> DM
    exp(SX x) -> SX
    exp(double const & x) -> double
    """
  return _casadi.exp(*args)

def log(*args):
  """
    log(MX x) -> MX
    log(IM x) -> IM
    log(DM x) -> DM
    log(SX x) -> SX
    log(double const & x) -> double
    """
  return _casadi.log(*args)

def log10(*args):
  """
    log10(MX x) -> MX
    log10(IM x) -> IM
    log10(DM x) -> DM
    log10(SX x) -> SX
    log10(double const & x) -> double
    """
  return _casadi.log10(*args)

def floor(*args):
  """
    floor(MX x) -> MX
    floor(IM x) -> IM
    floor(DM x) -> DM
    floor(SX x) -> SX
    floor(double const & x) -> double
    """
  return _casadi.floor(*args)

def ceil(*args):
  """
    ceil(MX x) -> MX
    ceil(IM x) -> IM
    ceil(DM x) -> DM
    ceil(SX x) -> SX
    ceil(double const & x) -> double
    """
  return _casadi.ceil(*args)

def erf(*args):
  """
    erf(MX x) -> MX
    erf(IM x) -> IM
    erf(DM x) -> DM
    erf(SX x) -> SX
    erf(double const & x) -> double
    """
  return _casadi.erf(*args)

def erfinv(*args):
  """
    erfinv(MX x) -> MX
    erfinv(IM x) -> IM
    erfinv(DM x) -> DM
    erfinv(SX x) -> SX
    erfinv(double const & x) -> double
    """
  return _casadi.erfinv(*args)

def sign(*args):
  """
    sign(MX x) -> MX
    sign(IM x) -> IM
    sign(DM x) -> DM
    sign(SX x) -> SX
    sign(double const & x) -> double
    """
  return _casadi.sign(*args)

def power(*args):
  """
    power(MX x, MX n) -> MX
    power(IM x, IM n) -> IM
    power(DM x, DM n) -> DM
    power(SX x, SX n) -> SX
    power(double const & x, double const & n) -> double
    """
  return _casadi.power(*args)

def mod(*args):
  """
    mod(MX x, MX y) -> MX
    mod(IM x, IM y) -> IM
    mod(DM x, DM y) -> DM
    mod(SX x, SX y) -> SX
    mod(double const & x, double const & y) -> double
    """
  return _casadi.mod(*args)

def atan2(*args):
  """
    atan2(MX x, MX y) -> MX
    atan2(IM x, IM y) -> IM
    atan2(DM x, DM y) -> DM
    atan2(SX x, SX y) -> SX
    atan2(double const & x, double const & y) -> double
    """
  return _casadi.atan2(*args)

def fmin(*args):
  """
    fmin(MX x, MX y) -> MX
    fmin(IM x, IM y) -> IM
    fmin(DM x, DM y) -> DM
    fmin(SX x, SX y) -> SX
    fmin(double const & x, double const & y) -> double
    """
  return _casadi.fmin(*args)

def fmax(*args):
  """
    fmax(MX x, MX y) -> MX
    fmax(IM x, IM y) -> IM
    fmax(DM x, DM y) -> DM
    fmax(SX x, SX y) -> SX
    fmax(double const & x, double const & y) -> double
    """
  return _casadi.fmax(*args)

def simplify(*args):
  """
    simplify(MX x) -> MX
    simplify(IM x) -> IM
    simplify(DM x) -> DM
    simplify(SX x) -> SX
    simplify(double const & x) -> double
    """
  return _casadi.simplify(*args)

def is_equal(*args):
  """
    is_equal(MX x, MX y, int depth=0) -> bool
    is_equal(IM x, IM y, int depth=0) -> bool
    is_equal(DM x, DM y, int depth=0) -> bool
    is_equal(SX x, SX y, int depth=0) -> bool
    is_equal(double const & x, double const & y, int depth=0) -> bool
    """
  return _casadi.is_equal(*args)

def copysign(*args):
  """
    copysign(MX x, MX y) -> MX
    copysign(IM x, IM y) -> IM
    copysign(DM x, DM y) -> DM
    copysign(SX x, SX y) -> SX
    copysign(double const & x, double const & y) -> double
    """
  return _casadi.copysign(*args)

def constpow(*args):
  """
    constpow(MX x, MX y) -> MX
    constpow(IM x, IM y) -> IM
    constpow(DM x, DM y) -> DM
    constpow(SX x, SX y) -> SX
    constpow(double const & x, double const & y) -> double
    """
  return _casadi.constpow(*args)

def mpower(*args):
  """
    mpower(MX x, MX n) -> MX
    mpower(IM x, IM n) -> IM
    mpower(DM x, DM n) -> DM
    mpower(SX x, SX n) -> SX
    """
  return _casadi.mpower(*args)

def mrdivide(*args):
  """
    mrdivide(MX x, MX y) -> MX
    mrdivide(IM x, IM y) -> IM
    mrdivide(DM x, DM y) -> DM
    mrdivide(SX x, SX y) -> SX
    """
  return _casadi.mrdivide(*args)

def mldivide(*args):
  """
    mldivide(MX x, MX y) -> MX
    mldivide(IM x, IM y) -> IM
    mldivide(DM x, DM y) -> DM
    mldivide(SX x, SX y) -> SX
    """
  return _casadi.mldivide(*args)

def symvar(*args):
  """
    symvar(MX x) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    symvar(IM x) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    symvar(DM x) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    symvar(SX x) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    """
  return _casadi.symvar(*args)

def bilin(*args):
  """
    bilin(MX A, MX x, MX y) -> MX
    bilin(IM A, IM x, IM y) -> IM
    bilin(DM A, DM x, DM y) -> DM
    bilin(SX A, SX x, SX y) -> SX

    [INTERNAL]  Calculates dot(x,
    mul(A, y))


    """
  return _casadi.bilin(*args)

def rank1(*args):
  """
    rank1(MX A, MX alpha, MX x, MX y) -> MX
    rank1(IM A, IM alpha, IM x, IM y) -> IM
    rank1(DM A, DM alpha, DM x, DM y) -> DM
    rank1(SX A, SX alpha, SX x, SX y) -> SX

    >  void rank1(real_t *A, const int *sp_A, real_t alpha, const real_t *x)
    ------------------------------------------------------------------------
    [INTERNAL] 
    Adds a multiple alpha/2 of the outer product mul(x, trans(x)) to A.

    >  void rank1(real_t *A, const int *sp_A, real_t alpha, const real_t *x, const real_t *y)
    ------------------------------------------------------------------------
    [INTERNAL] 

    """
  return _casadi.rank1(*args)

def sum_square(*args):
  """
    sum_square(MX X) -> MX
    sum_square(IM X) -> IM
    sum_square(DM X) -> DM
    sum_square(SX X) -> SX
    """
  return _casadi.sum_square(*args)

def linspace(*args):
  """
    linspace(MX a, MX b, int nsteps) -> MX
    linspace(IM a, IM b, int nsteps) -> IM
    linspace(DM a, DM b, int nsteps) -> DM
    linspace(SX a, SX b, int nsteps) -> SX
    """
  return _casadi.linspace(*args)

def cross(*args):
  """
    cross(MX a, MX b, int dim=-1) -> MX
    cross(IM a, IM b, int dim=-1) -> IM
    cross(DM a, DM b, int dim=-1) -> DM
    cross(SX a, SX b, int dim=-1) -> SX
    """
  return _casadi.cross(*args)

def skew(*args):
  """
    skew(MX a) -> MX
    skew(IM a) -> IM
    skew(DM a) -> DM
    skew(SX a) -> SX
    """
  return _casadi.skew(*args)

def inv_skew(*args):
  """
    inv_skew(MX a) -> MX
    inv_skew(IM a) -> IM
    inv_skew(DM a) -> DM
    inv_skew(SX a) -> SX
    """
  return _casadi.inv_skew(*args)

def det(*args):
  """
    det(MX A) -> MX
    det(IM A) -> IM
    det(DM A) -> DM
    det(SX A) -> SX
    """
  return _casadi.det(*args)

def inv(*args):
  """
    inv(MX A) -> MX
    inv(IM A) -> IM
    inv(DM A) -> DM
    inv(SX A) -> SX
    """
  return _casadi.inv(*args)

def trace(*args):
  """
    trace(MX a) -> MX
    trace(IM a) -> IM
    trace(DM a) -> DM
    trace(SX a) -> SX
    """
  return _casadi.trace(*args)

def tril2symm(*args):
  """
    tril2symm(MX a) -> MX
    tril2symm(IM a) -> IM
    tril2symm(DM a) -> DM
    tril2symm(SX a) -> SX
    """
  return _casadi.tril2symm(*args)

def triu2symm(*args):
  """
    triu2symm(MX a) -> MX
    triu2symm(IM a) -> IM
    triu2symm(DM a) -> DM
    triu2symm(SX a) -> SX
    """
  return _casadi.triu2symm(*args)

def norm_F(*args):
  """
    norm_F(MX x) -> MX
    norm_F(IM x) -> IM
    norm_F(DM x) -> DM
    norm_F(SX x) -> SX
    """
  return _casadi.norm_F(*args)

def norm_2(*args):
  """
    norm_2(MX x) -> MX
    norm_2(IM x) -> IM
    norm_2(DM x) -> DM
    norm_2(SX x) -> SX
    """
  return _casadi.norm_2(*args)

def norm_1(*args):
  """
    norm_1(MX x) -> MX
    norm_1(IM x) -> IM
    norm_1(DM x) -> DM
    norm_1(SX x) -> SX
    """
  return _casadi.norm_1(*args)

def norm_inf(*args):
  """
    norm_inf(MX x) -> MX
    norm_inf(IM x) -> IM
    norm_inf(DM x) -> DM
    norm_inf(SX x) -> SX

    [INTERNAL]  Inf-norm of a
    vector * Returns the largest element in absolute value


    """
  return _casadi.norm_inf(*args)

def sum2(*args):
  """
    sum2(MX x) -> MX
    sum2(IM x) -> IM
    sum2(DM x) -> DM
    sum2(SX x) -> SX
    """
  return _casadi.sum2(*args)

def sum1(*args):
  """
    sum1(MX x) -> MX
    sum1(IM x) -> IM
    sum1(DM x) -> DM
    sum1(SX x) -> SX
    """
  return _casadi.sum1(*args)

def dot(*args):
  """
    dot(MX x, MX y) -> MX
    dot(IM x, IM y) -> IM
    dot(DM x, DM y) -> DM
    dot(SX x, SX y) -> SX

    [INTERNAL]  Inner product.


    """
  return _casadi.dot(*args)

def nullspace(*args):
  """
    nullspace(MX A) -> MX
    nullspace(IM A) -> IM
    nullspace(DM A) -> DM
    nullspace(SX A) -> SX
    """
  return _casadi.nullspace(*args)

def polyval(*args):
  """
    polyval(MX p, MX x) -> MX
    polyval(IM p, IM x) -> IM
    polyval(DM p, DM x) -> DM
    polyval(SX p, SX x) -> SX

    [INTERNAL]  Evaluate a
    polynomial.


    """
  return _casadi.polyval(*args)

def diag(*args):
  """
    diag(MX A) -> MX
    diag(IM A) -> IM
    diag(DM A) -> DM
    diag(SX A) -> SX
    """
  return _casadi.diag(*args)

def unite(*args):
  """
    unite(MX A, MX B) -> MX
    unite(IM A, IM B) -> IM
    unite(DM A, DM B) -> DM
    unite(SX A, SX B) -> SX
    """
  return _casadi.unite(*args)

def densify(*args):
  """
    densify(MX x) -> MX
    densify(IM x) -> IM
    densify(DM x) -> DM
    densify(SX x) -> SX

    [INTERNAL]  Convert sparse to
    dense.


    """
  return _casadi.densify(*args)

def project(*args):
  """
    project(MX A, Sparsity sp, bool intersect=False) -> MX
    project(IM A, Sparsity sp, bool intersect=False) -> IM
    project(DM A, Sparsity sp, bool intersect=False) -> DM
    project(SX A, Sparsity sp, bool intersect=False) -> SX

    [INTERNAL]  Sparse copy: y <-
    x, w work vector (length >= number of rows)


    """
  return _casadi.project(*args)

def if_else(*args):
  """
    if_else(MX cond, MX if_true, MX if_false, bool short_circuit=True) -> MX
    if_else(IM cond, IM if_true, IM if_false, bool short_circuit=True) -> IM
    if_else(DM cond, DM if_true, DM if_false, bool short_circuit=True) -> DM
    if_else(SX cond, SX if_true, SX if_false, bool short_circuit=True) -> SX
    """
  return _casadi.if_else(*args)

def conditional(*args):
  """
    conditional(MX ind, std::vector< casadi::MX,std::allocator< casadi::MX > > const & x, MX x_default, 
        bool short_circuit=True) -> MX
    conditional(IM ind, std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & x, 
        IM x_default, bool short_circuit=True) -> IM
    conditional(DM ind, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & x, 
        DM x_default, bool short_circuit=True) -> DM
    conditional(SX ind, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & x, 
        SX x_default, bool short_circuit=True) -> SX
    """
  return _casadi.conditional(*args)

def depends_on(*args):
  """
    depends_on(MX f, MX arg) -> bool
    depends_on(IM f, IM arg) -> bool
    depends_on(DM f, DM arg) -> bool
    depends_on(SX f, SX arg) -> bool
    """
  return _casadi.depends_on(*args)

def solve(*args):
  """
    solve(MX A, MX b) -> MX
    solve(MX A, MX b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> MX
    solve(IM A, IM b) -> IM
    solve(IM A, IM b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> IM
    solve(DM A, DM b) -> DM
    solve(DM A, DM b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> DM
    solve(SX A, SX b) -> SX
    solve(SX A, SX b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> SX
    """
  return _casadi.solve(*args)

def pinv(*args):
  """
    pinv(MX A) -> MX
    pinv(MX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> MX
    pinv(IM A) -> IM
    pinv(IM A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> IM
    pinv(DM A) -> DM
    pinv(DM A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> DM
    pinv(SX A) -> SX
    pinv(SX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> SX
    """
  return _casadi.pinv(*args)

def jacobian(*args):
  """
    jacobian(MX ex, MX arg) -> MX
    jacobian(IM ex, IM arg) -> IM
    jacobian(DM ex, DM arg) -> DM
    jacobian(SX ex, SX arg) -> SX
    """
  return _casadi.jacobian(*args)

def jtimes(*args):
  """
    jtimes(MX ex, MX arg, MX v, bool tr=False) -> MX
    jtimes(IM ex, IM arg, IM v, bool tr=False) -> IM
    jtimes(DM ex, DM arg, DM v, bool tr=False) -> DM
    jtimes(SX ex, SX arg, SX v, bool tr=False) -> SX
    """
  return _casadi.jtimes(*args)

def nl_var(*args):
  """
    nl_var(MX expr, MX var) -> std::vector< bool,std::allocator< bool > >
    nl_var(IM expr, IM var) -> std::vector< bool,std::allocator< bool > >
    nl_var(DM expr, DM var) -> std::vector< bool,std::allocator< bool > >
    nl_var(SX expr, SX var) -> std::vector< bool,std::allocator< bool > >
    """
  return _casadi.nl_var(*args)

def gradient(*args):
  """
    gradient(MX ex, MX arg) -> MX
    gradient(IM ex, IM arg) -> IM
    gradient(DM ex, DM arg) -> DM
    gradient(SX ex, SX arg) -> SX
    """
  return _casadi.gradient(*args)

def tangent(*args):
  """
    tangent(MX ex, MX arg) -> MX
    tangent(IM ex, IM arg) -> IM
    tangent(DM ex, DM arg) -> DM
    tangent(SX ex, SX arg) -> SX
    """
  return _casadi.tangent(*args)

def hessian(*args):
  """
    hessian(MX ex, MX arg) -> MX
    hessian(IM ex, IM arg) -> IM
    hessian(DM ex, DM arg) -> DM
    hessian(SX ex, SX arg) -> SX
    """
  return _casadi.hessian(*args)

def n_nodes(*args):
  """
    n_nodes(MX A) -> int
    n_nodes(IM A) -> int
    n_nodes(DM A) -> int
    n_nodes(SX A) -> int
    """
  return _casadi.n_nodes(*args)

def print_operator(*args):
  """
    print_operator(MX xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string
    print_operator(IM xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string
    print_operator(DM xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string
    print_operator(SX xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string
    """
  return _casadi.print_operator(*args)

def repsum(*args):
  """
    repsum(MX A, int n, int m=1) -> MX
    repsum(IM A, int n, int m=1) -> IM
    repsum(DM A, int n, int m=1) -> DM
    repsum(SX A, int n, int m=1) -> SX
    """
  return _casadi.repsum(*args)

def substitute(*args):
  """
    substitute(MX ex, MX v, MX vdef) -> MX
    substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, 
        std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    substitute(IM ex, IM v, IM vdef) -> IM
    substitute(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & ex, 
        std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & v, 
        std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & vdef) -> std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > >
    substitute(DM ex, DM v, DM vdef) -> DM
    substitute(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, 
        std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, 
        std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & vdef) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >
    substitute(SX ex, SX v, SX vdef) -> SX
    substitute(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, 
        std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, 
        std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & vdef) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >
    """
  return _casadi.substitute(*args)

def substitute_inplace(*args):
  """
    substitute_inplace(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > & INOUT1, 
        std::vector< casadi::MX,std::allocator< casadi::MX > > & INOUT2, 
        bool reverse=False)
    substitute_inplace(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & v, 
        std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > & INOUT1, 
        std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > & INOUT2, 
        bool reverse=False)
    substitute_inplace(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, 
        std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > & INOUT1, 
        std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > & INOUT2, 
        bool reverse=False)
    substitute_inplace(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, 
        std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > & INOUT1, 
        std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > & INOUT2, 
        bool reverse=False)
    """
  return _casadi.substitute_inplace(*args)

def shared(*args):
  """
    shared(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::string const & v_prefix="v_", 
        std::string const & v_suffix="")
    shared(std::vector< casadi::Matrix< int >,std::allocator< casadi::Matrix< int > > > const & ex, 
        std::string const & v_prefix="v_", std::string const & v_suffix="")
    shared(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, 
        std::string const & v_prefix="v_", std::string const & v_suffix="")
    shared(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, 
        std::string const & v_prefix="v_", std::string const & v_suffix="")
    """
  return _casadi.shared(*args)

def logic_all(*args):
  """
    logic_all(IM x) -> IM
    logic_all(DM x) -> DM
    logic_all(SX x) -> SX
    """
  return _casadi.logic_all(*args)

def logic_any(*args):
  """
    logic_any(IM x) -> IM
    logic_any(DM x) -> DM
    logic_any(SX x) -> SX
    """
  return _casadi.logic_any(*args)

def adj(*args):
  """
    adj(IM A) -> IM
    adj(DM A) -> DM
    adj(SX A) -> SX
    """
  return _casadi.adj(*args)

def getMinor(*args):
  """
    getMinor(IM x, int i, int j) -> IM
    getMinor(DM x, int i, int j) -> DM
    getMinor(SX x, int i, int j) -> SX
    """
  return _casadi.getMinor(*args)

def cofactor(*args):
  """
    cofactor(IM x, int i, int j) -> IM
    cofactor(DM x, int i, int j) -> DM
    cofactor(SX x, int i, int j) -> SX
    """
  return _casadi.cofactor(*args)

def qr(*args):
  """
    qr(IM A)
    qr(DM A)
    qr(SX A)
    """
  return _casadi.qr(*args)

def chol(*args):
  """
    chol(IM A) -> IM
    chol(DM A) -> DM
    chol(SX A) -> SX
    """
  return _casadi.chol(*args)

def norm_inf_mul(*args):
  """
    norm_inf_mul(IM x, IM y) -> IM
    norm_inf_mul(DM x, DM y) -> DM
    norm_inf_mul(SX x, SX y) -> SX

    [INTERNAL]  Inf-norm of
    a Matrix-matrix product,*

    Parameters:
    -----------

    dwork:  A real work vector that you must allocate Minimum size: y.size1()

    iwork:  A integer work vector that you must allocate Minimum size:
    y.size1()+x.size2()+1


    """
  return _casadi.norm_inf_mul(*args)

def sparsify(*args):
  """
    sparsify(IM A, double tol=0) -> IM
    sparsify(DM A, double tol=0) -> DM
    sparsify(SX A, double tol=0) -> SX

    [INTERNAL]  Convert dense to
    sparse.


    """
  return _casadi.sparsify(*args)

def expand(*args):
  """
    expand(IM ex)
    expand(DM ex)
    expand(SX ex)
    """
  return _casadi.expand(*args)

def pw_const(*args):
  """
    pw_const(IM t, IM tval, IM val) -> IM
    pw_const(DM t, DM tval, DM val) -> DM
    pw_const(SX t, SX tval, SX val) -> SX
    """
  return _casadi.pw_const(*args)

def pw_lin(*args):
  """
    pw_lin(IM t, IM tval, IM val) -> IM
    pw_lin(DM t, DM tval, DM val) -> DM
    pw_lin(SX t, SX tval, SX val) -> SX
    """
  return _casadi.pw_lin(*args)

def heaviside(*args):
  """
    heaviside(IM x) -> IM
    heaviside(DM x) -> DM
    heaviside(SX x) -> SX
    """
  return _casadi.heaviside(*args)

def rectangle(*args):
  """
    rectangle(IM x) -> IM
    rectangle(DM x) -> DM
    rectangle(SX x) -> SX
    """
  return _casadi.rectangle(*args)

def triangle(*args):
  """
    triangle(IM x) -> IM
    triangle(DM x) -> DM
    triangle(SX x) -> SX
    """
  return _casadi.triangle(*args)

def ramp(*args):
  """
    ramp(IM x) -> IM
    ramp(DM x) -> DM
    ramp(SX x) -> SX
    """
  return _casadi.ramp(*args)

def gauss_quadrature(*args):
  """
    gauss_quadrature(IM f, IM x, IM a, IM b, int order=5) -> IM
    gauss_quadrature(IM f, IM x, IM a, IM b, int order, IM w) -> IM
    gauss_quadrature(DM f, DM x, DM a, DM b, int order=5) -> DM
    gauss_quadrature(DM f, DM x, DM a, DM b, int order, DM w) -> DM
    gauss_quadrature(SX f, SX x, SX a, SX b, int order=5) -> SX
    gauss_quadrature(SX f, SX x, SX a, SX b, int order, SX w) -> SX
    """
  return _casadi.gauss_quadrature(*args)

def taylor(*args):
  """
    taylor(IM ex, IM x, IM a=0, int order=1) -> IM
    taylor(DM ex, DM x, DM a=0, int order=1) -> DM
    taylor(SX ex, SX x, SX a=0, int order=1) -> SX
    """
  return _casadi.taylor(*args)

def mtaylor(*args):
  """
    mtaylor(IM ex, IM x, IM a, int order=1) -> IM
    mtaylor(IM ex, IM x, IM a, int order, std::vector< int,std::allocator< int > > const & order_contributions) -> IM
    mtaylor(DM ex, DM x, DM a, int order=1) -> DM
    mtaylor(DM ex, DM x, DM a, int order, std::vector< int,std::allocator< int > > const & order_contributions) -> DM
    mtaylor(SX ex, SX x, SX a, int order=1) -> SX
    mtaylor(SX ex, SX x, SX a, int order, std::vector< int,std::allocator< int > > const & order_contributions) -> SX
    """
  return _casadi.mtaylor(*args)

def poly_coeff(*args):
  """
    poly_coeff(IM ex, IM x) -> IM
    poly_coeff(DM ex, DM x) -> DM
    poly_coeff(SX ex, SX x) -> SX
    """
  return _casadi.poly_coeff(*args)

def poly_roots(*args):
  """
    poly_roots(IM p) -> IM
    poly_roots(DM p) -> DM
    poly_roots(SX p) -> SX
    """
  return _casadi.poly_roots(*args)

def eig_symbolic(*args):
  """
    eig_symbolic(IM m) -> IM
    eig_symbolic(DM m) -> DM
    eig_symbolic(SX m) -> SX
    """
  return _casadi.eig_symbolic(*args)

def find(*args):
  """find(MX x) -> MX"""
  return _casadi.find(*args)

def matrix_expand(*args):
  """
    matrix_expand(std::vector< casadi::MX,std::allocator< casadi::MX > > const & e, std::vector< casadi::MX,std::allocator< casadi::MX > > const & boundary=std::vector< casadi::MX >(), 
        casadi::Dict const & options=casadi::Dict()) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    matrix_expand(MX e, std::vector< casadi::MX,std::allocator< casadi::MX > > const & boundary=std::vector< casadi::MX >(), 
        casadi::Dict const & options=casadi::Dict()) -> MX
    """
  return _casadi.matrix_expand(*args)

def graph_substitute(*args):
  """
    graph_substitute(MX ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> MX
    graph_substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, 
        std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> std::vector< casadi::MX,std::allocator< casadi::MX > >
    """
  return _casadi.graph_substitute(*args)
class Compiler(SharedObject):
    """
    Compiler.

    Just-in-time compilation of code

    General information
    ===================



    List of plugins
    ===============



    - clang

    - shell

    Note: some of the plugins in this list might not be available on your
    system. Also, there might be extra plugins available to you that are not
    listed here. You can obtain their documentation with
    Compiler.doc("myextraplugin")



    --------------------------------------------------------------------------------

    clang
    -----



    Interface to the JIT compiler CLANG

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | flags                  | OT_STRINGVECTOR        | Compile flags for the  |
    |                        |                        | JIT compiler. Default: |
    |                        |                        | None                   |
    +------------------------+------------------------+------------------------+
    | include_path           | OT_STRING              | Include paths for the  |
    |                        |                        | JIT compiler. The      |
    |                        |                        | include directory      |
    |                        |                        | shipped with CasADi    |
    |                        |                        | will be automatically  |
    |                        |                        | appended.              |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    --------------------------------------------------------------------------------

    shell
    -----



    Interface to the JIT compiler SHELL

    >List of available options

    +------------------------+------------------------+------------------------+
    |           Id           |          Type          |      Description       |
    +========================+========================+========================+
    | compiler               | OT_STRING              | Compiler command       |
    +------------------------+------------------------+------------------------+
    | compiler_setup         | OT_STRING              | Compiler setup         |
    |                        |                        | command. Intended to   |
    |                        |                        | be fixed. The 'flag'   |
    |                        |                        | option is the prefered |
    |                        |                        | way to set custom      |
    |                        |                        | flags.                 |
    +------------------------+------------------------+------------------------+
    | flags                  | OT_STRINGVECTOR        | Compile flags for the  |
    |                        |                        | JIT compiler. Default: |
    |                        |                        | None                   |
    +------------------------+------------------------+------------------------+

    --------------------------------------------------------------------------------



    Joris Gillis

    C++ includes: compiler.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Compiler, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Compiler, name)
    __repr__ = _swig_repr
    def test_cast(*args):
        """test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
        return _casadi.Compiler_test_cast(*args)

    if _newclass:test_cast = staticmethod(test_cast)
    __swig_getmethods__["test_cast"] = lambda x: test_cast
    def hasPlugin(*args):
        """hasPlugin(std::string const & name) -> bool"""
        return _casadi.Compiler_hasPlugin(*args)

    if _newclass:hasPlugin = staticmethod(hasPlugin)
    __swig_getmethods__["hasPlugin"] = lambda x: hasPlugin
    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi.Compiler_loadPlugin(*args)

    if _newclass:loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin
    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi.Compiler_doc(*args)

    if _newclass:doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc
    def plugin_name(self, *args):
        """
        plugin_name(Compiler self) -> std::string

        Query plugin name.


        """
        return _casadi.Compiler_plugin_name(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::Compiler self) -> Compiler
        __init__(casadi::Compiler self, std::string const & name, std::string const & compiler, casadi::Dict const & opts=casadi::Dict()) -> Compiler
        __init__(casadi::Compiler self, Compiler other) -> Compiler

        >  Compiler()
        ------------------------------------------------------------------------

        Default constructor.

        >  Compiler(str name, str compiler, Dict opts=Dict())
        ------------------------------------------------------------------------

        Compiler factory (new syntax, includes initialization)


        """
        this = _casadi.new_Compiler(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_Compiler
Compiler_swigregister = _casadi.Compiler_swigregister
Compiler_swigregister(Compiler)

def Compiler_test_cast(*args):
  """Compiler_test_cast(casadi::SharedObjectNode const * ptr) -> bool"""
  return _casadi.Compiler_test_cast(*args)

def Compiler_hasPlugin(*args):
  """Compiler_hasPlugin(std::string const & name) -> bool"""
  return _casadi.Compiler_hasPlugin(*args)

def Compiler_loadPlugin(*args):
  """Compiler_loadPlugin(std::string const & name)"""
  return _casadi.Compiler_loadPlugin(*args)

def Compiler_doc(*args):
  """Compiler_doc(std::string const & name) -> std::string"""
  return _casadi.Compiler_doc(*args)

class Library(SharedObject):
    """
    Library, either just-in-time compiled or dynamically loaded.

    C++ includes: compiler.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Library, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Library, name)
    __repr__ = _swig_repr
    def has(self, *args):
        """has(Library self, std::string const & sym) -> bool"""
        return _casadi.Library_has(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::Library self) -> Library
        __init__(casadi::Library self, std::string const & bin_name) -> Library
        __init__(casadi::Library self, Compiler compiler) -> Library
        __init__(casadi::Library self, Library other) -> Library

        >  Library()
        ------------------------------------------------------------------------

        Default constructor.


        """
        this = _casadi.new_Library(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_Library
Library_swigregister = _casadi.Library_swigregister
Library_swigregister(Library)

class Callback(Function):
    """
    Callback function functionality This class provides a public API to the
    FunctionInternal class that can be subclassed by the user, who is then able
    to implement the different virtual method. Note that the Function class also
    provides a public API to FunctionInternal, but only allows calling, not
    being called.

    The user is responsible for not deleting this class for the lifetime of the
    internal function object.

    Joris Gillis, Joel Andersson

    C++ includes: callback.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [Function]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Callback, name, value)
    __swig_getmethods__ = {}
    for _s in [Function]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Callback, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(casadi::Callback self) -> Callback
        __init__(casadi::Callback self, Callback obj) -> Callback

        >  Callback()
        ------------------------------------------------------------------------

        Default constructor.

        >  Callback(Callback obj)
        ------------------------------------------------------------------------

        Copy constructor (throws an error)


        """
        if self.__class__ == Callback:
            _self = None
        else:
            _self = self
        this = _casadi.new_Callback(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def create(*args):
        """create(std::string const & name, Callback n, casadi::Dict const & opts=casadi::Dict()) -> Function"""
        return _casadi.Callback_create(*args)

    if _newclass:create = staticmethod(create)
    __swig_getmethods__["create"] = lambda x: create
    def construct(self, *args):
        """
        construct(Callback self, std::string const & name, casadi::Dict const & opts=casadi::Dict())

        Construct internal object This is the step that actually construct the
        internal object, as the class constructor only creates a null pointer. It
        should be called from the user constructor.


        """
        return _casadi.Callback_construct(self, *args)

    __swig_destroy__ = _casadi.delete_Callback
    def init(self, *args):
        """
        init(Callback self)

        Initialize the object This function is called after the object construction
        (for the whole class hierarchy) is complete, but before the finalization
        step. It is called recursively for the whole class hierarchy, starting with
        the lowest level.


        """
        return _casadi.Callback_init(self, *args)

    def finalize(self, *args):
        """
        finalize(Callback self)

        Finalize the object This function is called after the construction and init
        steps are completed, but before user functions are called. It is called
        recursively for the whole class hierarchy, starting with the highest level.


        """
        return _casadi.Callback_finalize(self, *args)

    def eval(self, *args):
        """
        eval(Callback self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >

        Evaluate numerically, temporary matrices and work vectors.


        """
        return _casadi.Callback_eval(self, *args)

    def get_n_in(self, *args):
        """
        get_n_in(Callback self) -> int

        Get the number of inputs This function is called during construction.


        """
        return _casadi.Callback_get_n_in(self, *args)

    def get_n_out(self, *args):
        """
        get_n_out(Callback self) -> int

        Get the number of outputs This function is called during construction.


        """
        return _casadi.Callback_get_n_out(self, *args)

    def get_sparsity_in(self, *args):
        """
        get_sparsity_in(Callback self, int i) -> Sparsity

        Get the sparsity of an input This function is called during construction.


        """
        return _casadi.Callback_get_sparsity_in(self, *args)

    def get_sparsity_out(self, *args):
        """
        get_sparsity_out(Callback self, int i) -> Sparsity

        Get the sparsity of an output This function is called during construction.


        """
        return _casadi.Callback_get_sparsity_out(self, *args)

    def get_name_in(self, *args):
        """
        get_name_in(Callback self, int i) -> std::string

        Get the sparsity of an input This function is called during construction.


        """
        return _casadi.Callback_get_name_in(self, *args)

    def get_name_out(self, *args):
        """
        get_name_out(Callback self, int i) -> std::string

        Get the sparsity of an output This function is called during construction.


        """
        return _casadi.Callback_get_name_out(self, *args)

    def has_jacobian(self, *args):
        """
        has_jacobian(Callback self) -> bool

        Return Jacobian of all input elements with respect to all output elements.


        """
        return _casadi.Callback_has_jacobian(self, *args)

    def get_jacobian(self, *args):
        """
        get_jacobian(Callback self, std::string const & name, casadi::Dict const & opts) -> Function

        Return Jacobian of all input elements with respect to all output elements.


        """
        return _casadi.Callback_get_jacobian(self, *args)

    def get_forward(self, *args):
        """
        get_forward(Callback self, std::string const & name, int nfwd, casadi::Dict & opts) -> Function

        Return function that calculates forward derivatives forward(nfwd) returns a
        cached instance if available, and calls  Function get_forward(int nfwd) if
        no cached version is available.


        """
        return _casadi.Callback_get_forward(self, *args)

    def get_n_forward(self, *args):
        """
        get_n_forward(Callback self) -> int

        Return function that calculates forward derivatives forward(nfwd) returns a
        cached instance if available, and calls  Function get_forward(int nfwd) if
        no cached version is available.


        """
        return _casadi.Callback_get_n_forward(self, *args)

    def get_reverse(self, *args):
        """
        get_reverse(Callback self, std::string const & name, int nadj, casadi::Dict & opts) -> Function

        Return function that calculates adjoint derivatives reverse(nadj) returns a
        cached instance if available, and calls  Function get_reverse(int nadj) if
        no cached version is available.


        """
        return _casadi.Callback_get_reverse(self, *args)

    def get_n_reverse(self, *args):
        """
        get_n_reverse(Callback self) -> int

        Return function that calculates adjoint derivatives reverse(nadj) returns a
        cached instance if available, and calls  Function get_reverse(int nadj) if
        no cached version is available.


        """
        return _casadi.Callback_get_n_reverse(self, *args)

    def __disown__(self):
        self.this.disown()
        _casadi.disown_Callback(self)
        return weakref_proxy(self)
Callback_swigregister = _casadi.Callback_swigregister
Callback_swigregister(Callback)

def Callback_create(*args):
  """Callback_create(std::string const & name, Callback n, casadi::Dict const & opts=casadi::Dict()) -> Function"""
  return _casadi.Callback_create(*args)

class GlobalOptions(_object):
    """
    Collects global CasADi options.

    Note to developers: use sparingly. Global options are - in general - a
    rather bad idea

    this class must never be instantiated. Access its static members directly
    Joris Gillis

    C++ includes: global_options.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GlobalOptions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GlobalOptions, name)
    __repr__ = _swig_repr
    def setSimplificationOnTheFly(*args):
        """setSimplificationOnTheFly(bool flag)"""
        return _casadi.GlobalOptions_setSimplificationOnTheFly(*args)

    if _newclass:setSimplificationOnTheFly = staticmethod(setSimplificationOnTheFly)
    __swig_getmethods__["setSimplificationOnTheFly"] = lambda x: setSimplificationOnTheFly
    def getSimplificationOnTheFly(*args):
        """getSimplificationOnTheFly() -> bool"""
        return _casadi.GlobalOptions_getSimplificationOnTheFly(*args)

    if _newclass:getSimplificationOnTheFly = staticmethod(getSimplificationOnTheFly)
    __swig_getmethods__["getSimplificationOnTheFly"] = lambda x: getSimplificationOnTheFly
    def setHierarchicalSparsity(*args):
        """setHierarchicalSparsity(bool flag)"""
        return _casadi.GlobalOptions_setHierarchicalSparsity(*args)

    if _newclass:setHierarchicalSparsity = staticmethod(setHierarchicalSparsity)
    __swig_getmethods__["setHierarchicalSparsity"] = lambda x: setHierarchicalSparsity
    def getHierarchicalSparsity(*args):
        """getHierarchicalSparsity() -> bool"""
        return _casadi.GlobalOptions_getHierarchicalSparsity(*args)

    if _newclass:getHierarchicalSparsity = staticmethod(getHierarchicalSparsity)
    __swig_getmethods__["getHierarchicalSparsity"] = lambda x: getHierarchicalSparsity
    def setCasadiPath(*args):
        """setCasadiPath(std::string const & path)"""
        return _casadi.GlobalOptions_setCasadiPath(*args)

    if _newclass:setCasadiPath = staticmethod(setCasadiPath)
    __swig_getmethods__["setCasadiPath"] = lambda x: setCasadiPath
    def getCasadiPath(*args):
        """getCasadiPath() -> std::string"""
        return _casadi.GlobalOptions_getCasadiPath(*args)

    if _newclass:getCasadiPath = staticmethod(getCasadiPath)
    __swig_getmethods__["getCasadiPath"] = lambda x: getCasadiPath
    def __init__(self, *args): 
        """__init__(casadi::GlobalOptions self, GlobalOptions other) -> GlobalOptions"""
        this = _casadi.new_GlobalOptions(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_GlobalOptions
GlobalOptions_swigregister = _casadi.GlobalOptions_swigregister
GlobalOptions_swigregister(GlobalOptions)

def GlobalOptions_setSimplificationOnTheFly(*args):
  """GlobalOptions_setSimplificationOnTheFly(bool flag)"""
  return _casadi.GlobalOptions_setSimplificationOnTheFly(*args)

def GlobalOptions_getSimplificationOnTheFly(*args):
  """GlobalOptions_getSimplificationOnTheFly() -> bool"""
  return _casadi.GlobalOptions_getSimplificationOnTheFly(*args)

def GlobalOptions_setHierarchicalSparsity(*args):
  """GlobalOptions_setHierarchicalSparsity(bool flag)"""
  return _casadi.GlobalOptions_setHierarchicalSparsity(*args)

def GlobalOptions_getHierarchicalSparsity(*args):
  """GlobalOptions_getHierarchicalSparsity() -> bool"""
  return _casadi.GlobalOptions_getHierarchicalSparsity(*args)

def GlobalOptions_setCasadiPath(*args):
  """GlobalOptions_setCasadiPath(std::string const & path)"""
  return _casadi.GlobalOptions_setCasadiPath(*args)

def GlobalOptions_getCasadiPath(*args):
  """GlobalOptions_getCasadiPath() -> std::string"""
  return _casadi.GlobalOptions_getCasadiPath(*args)

class CasadiMeta(_object):
    """
    Collects global CasADi meta information.

    Joris Gillis

    C++ includes: casadi_meta.hpp 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CasadiMeta, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CasadiMeta, name)
    __repr__ = _swig_repr
    def getVersion(*args):
        """getVersion() -> std::string"""
        return _casadi.CasadiMeta_getVersion(*args)

    if _newclass:getVersion = staticmethod(getVersion)
    __swig_getmethods__["getVersion"] = lambda x: getVersion
    def getGitRevision(*args):
        """getGitRevision() -> std::string"""
        return _casadi.CasadiMeta_getGitRevision(*args)

    if _newclass:getGitRevision = staticmethod(getGitRevision)
    __swig_getmethods__["getGitRevision"] = lambda x: getGitRevision
    def getGitDescribe(*args):
        """getGitDescribe() -> std::string"""
        return _casadi.CasadiMeta_getGitDescribe(*args)

    if _newclass:getGitDescribe = staticmethod(getGitDescribe)
    __swig_getmethods__["getGitDescribe"] = lambda x: getGitDescribe
    def getFeatureList(*args):
        """getFeatureList() -> std::string"""
        return _casadi.CasadiMeta_getFeatureList(*args)

    if _newclass:getFeatureList = staticmethod(getFeatureList)
    __swig_getmethods__["getFeatureList"] = lambda x: getFeatureList
    def getBuildType(*args):
        """getBuildType() -> std::string"""
        return _casadi.CasadiMeta_getBuildType(*args)

    if _newclass:getBuildType = staticmethod(getBuildType)
    __swig_getmethods__["getBuildType"] = lambda x: getBuildType
    def getCompilerId(*args):
        """getCompilerId() -> std::string"""
        return _casadi.CasadiMeta_getCompilerId(*args)

    if _newclass:getCompilerId = staticmethod(getCompilerId)
    __swig_getmethods__["getCompilerId"] = lambda x: getCompilerId
    def getCompiler(*args):
        """getCompiler() -> std::string"""
        return _casadi.CasadiMeta_getCompiler(*args)

    if _newclass:getCompiler = staticmethod(getCompiler)
    __swig_getmethods__["getCompiler"] = lambda x: getCompiler
    def getCompilerFlags(*args):
        """getCompilerFlags() -> std::string"""
        return _casadi.CasadiMeta_getCompilerFlags(*args)

    if _newclass:getCompilerFlags = staticmethod(getCompilerFlags)
    __swig_getmethods__["getCompilerFlags"] = lambda x: getCompilerFlags
    def getModules(*args):
        """getModules() -> std::string"""
        return _casadi.CasadiMeta_getModules(*args)

    if _newclass:getModules = staticmethod(getModules)
    __swig_getmethods__["getModules"] = lambda x: getModules
    def getPlugins(*args):
        """getPlugins() -> std::string"""
        return _casadi.CasadiMeta_getPlugins(*args)

    if _newclass:getPlugins = staticmethod(getPlugins)
    __swig_getmethods__["getPlugins"] = lambda x: getPlugins
    def getInstallPrefix(*args):
        """getInstallPrefix() -> std::string"""
        return _casadi.CasadiMeta_getInstallPrefix(*args)

    if _newclass:getInstallPrefix = staticmethod(getInstallPrefix)
    __swig_getmethods__["getInstallPrefix"] = lambda x: getInstallPrefix
    def __init__(self, *args): 
        """__init__(casadi::CasadiMeta self, CasadiMeta other) -> CasadiMeta"""
        this = _casadi.new_CasadiMeta(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_CasadiMeta
CasadiMeta_swigregister = _casadi.CasadiMeta_swigregister
CasadiMeta_swigregister(CasadiMeta)

def CasadiMeta_getVersion(*args):
  """CasadiMeta_getVersion() -> std::string"""
  return _casadi.CasadiMeta_getVersion(*args)

def CasadiMeta_getGitRevision(*args):
  """CasadiMeta_getGitRevision() -> std::string"""
  return _casadi.CasadiMeta_getGitRevision(*args)

def CasadiMeta_getGitDescribe(*args):
  """CasadiMeta_getGitDescribe() -> std::string"""
  return _casadi.CasadiMeta_getGitDescribe(*args)

def CasadiMeta_getFeatureList(*args):
  """CasadiMeta_getFeatureList() -> std::string"""
  return _casadi.CasadiMeta_getFeatureList(*args)

def CasadiMeta_getBuildType(*args):
  """CasadiMeta_getBuildType() -> std::string"""
  return _casadi.CasadiMeta_getBuildType(*args)

def CasadiMeta_getCompilerId(*args):
  """CasadiMeta_getCompilerId() -> std::string"""
  return _casadi.CasadiMeta_getCompilerId(*args)

def CasadiMeta_getCompiler(*args):
  """CasadiMeta_getCompiler() -> std::string"""
  return _casadi.CasadiMeta_getCompiler(*args)

def CasadiMeta_getCompilerFlags(*args):
  """CasadiMeta_getCompilerFlags() -> std::string"""
  return _casadi.CasadiMeta_getCompilerFlags(*args)

def CasadiMeta_getModules(*args):
  """CasadiMeta_getModules() -> std::string"""
  return _casadi.CasadiMeta_getModules(*args)

def CasadiMeta_getPlugins(*args):
  """CasadiMeta_getPlugins() -> std::string"""
  return _casadi.CasadiMeta_getPlugins(*args)

def CasadiMeta_getInstallPrefix(*args):
  """CasadiMeta_getInstallPrefix() -> std::string"""
  return _casadi.CasadiMeta_getInstallPrefix(*args)


def collocation_points(*args):
  """
    collocation_points(int order, std::string const & scheme="radau") -> std::vector< double,std::allocator< double > >

    Obtain collocation points of specific order and scheme.

    Parameters:
    -----------

    scheme:  'radau' or 'legendre'


    """
  return _casadi.collocation_points(*args)

def collocationInterpolators(*args):
  """
    collocationInterpolators(std::vector< double,std::allocator< double > > const & tau_root)

    Obtain collocation interpolating matrices.

    Parameters:
    -----------

    tau_root:  location of collocation points, as obtained from
    collocationPoints

    C:  interpolating coefficients to obtain derivatives Length: order+1, order
    + 1



    ::

    dX/dt @collPoint(j) ~ Sum_i C[j][i]*X@collPoint(i)



    Parameters:
    -----------

    D:  interpolating coefficients to obtain end state Length: order+1


    """
  return _casadi.collocationInterpolators(*args)
LEGENDRE = _casadi.LEGENDRE
RADAU = _casadi.RADAU

def simpleRK(*args):
  """
    simpleRK(Function f, int N=10, int order=4) -> Function

    Construct an explicit Runge-Kutta integrator The constructed function has
    three inputs, corresponding to initial state (x0), parameter (p) and
    integration time (h) and one output, corresponding to final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials


    """
  return _casadi.simpleRK(*args)

def simpleIRK(*args):
  """
    simpleIRK(Function f, int N=10, int order=4, std::string const & scheme="radau", std::string const & solver="newton", 
        casadi::Dict const & solver_options=casadi::Dict()) -> Function

    Construct an implicit Runge-Kutta integrator using a collocation scheme The
    constructed function has three inputs, corresponding to initial state (x0),
    parameter (p) and integration time (h) and one output, corresponding to
    final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials

    scheme:  Collocation scheme, as excepted by collocationPoints function.


    """
  return _casadi.simpleIRK(*args)

def simpleIntegrator(*args):
  """
    simpleIntegrator(Function f, std::string const & integrator="cvodes", casadi::Dict const & integrator_options=casadi::Dict()) -> Function

    Simplified wrapper for the Integrator class Constructs an integrator using
    the same syntax as simpleRK and simpleIRK. The constructed function has
    three inputs, corresponding to initial state (x0), parameter (p) and
    integration time (h) and one output, corresponding to final state (xf).

    Parameters:
    -----------

    f:  ODE function with two inputs (x and p) and one output (xdot)

    N:  Number of integrator steps

    order:  Order of interpolating polynomials

    scheme:  Collocation scheme, as excepted by collocationPoints function.


    """
  return _casadi.simpleIntegrator(*args)
class NlpBuilder(PrintNlpBuilder):
    """
    A symbolic NLP representation.

    Joel Andersson

    C++ includes: nlp_builder.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [PrintNlpBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NlpBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintNlpBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NlpBuilder, name)
    __repr__ = _swig_repr
    __swig_getmethods__["x"] = _casadi.NlpBuilder_x_get
    if _newclass:x = _swig_property(_casadi.NlpBuilder_x_get)
    __swig_getmethods__["f"] = _casadi.NlpBuilder_f_get
    if _newclass:f = _swig_property(_casadi.NlpBuilder_f_get)
    __swig_getmethods__["g"] = _casadi.NlpBuilder_g_get
    if _newclass:g = _swig_property(_casadi.NlpBuilder_g_get)
    __swig_getmethods__["x_lb"] = _casadi.NlpBuilder_x_lb_get
    if _newclass:x_lb = _swig_property(_casadi.NlpBuilder_x_lb_get)
    __swig_getmethods__["x_ub"] = _casadi.NlpBuilder_x_ub_get
    if _newclass:x_ub = _swig_property(_casadi.NlpBuilder_x_ub_get)
    __swig_getmethods__["g_lb"] = _casadi.NlpBuilder_g_lb_get
    if _newclass:g_lb = _swig_property(_casadi.NlpBuilder_g_lb_get)
    __swig_getmethods__["g_ub"] = _casadi.NlpBuilder_g_ub_get
    if _newclass:g_ub = _swig_property(_casadi.NlpBuilder_g_ub_get)
    __swig_getmethods__["x_init"] = _casadi.NlpBuilder_x_init_get
    if _newclass:x_init = _swig_property(_casadi.NlpBuilder_x_init_get)
    __swig_getmethods__["lambda_init"] = _casadi.NlpBuilder_lambda_init_get
    if _newclass:lambda_init = _swig_property(_casadi.NlpBuilder_lambda_init_get)
    def parse_nl(self, *args):
        """
        parse_nl(NlpBuilder self, std::string const & filename, casadi::Dict const & options=casadi::Dict())

        Parse an AMPL och PyOmo NL-file.


        """
        return _casadi.NlpBuilder_parse_nl(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::NlpBuilder self) -> NlpBuilder
        __init__(casadi::NlpBuilder self, NlpBuilder other) -> NlpBuilder
        """
        this = _casadi.new_NlpBuilder(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_NlpBuilder
NlpBuilder_swigregister = _casadi.NlpBuilder_swigregister
NlpBuilder_swigregister(NlpBuilder)

CONSTANT = _casadi.CONSTANT
PARAMETER = _casadi.PARAMETER
DISCRETE = _casadi.DISCRETE
CONTINUOUS = _casadi.CONTINUOUS
INPUT = _casadi.INPUT
OUTPUT = _casadi.OUTPUT
INTERNAL = _casadi.INTERNAL
ALGEBRAIC = _casadi.ALGEBRAIC
DIFFERENTIAL = _casadi.DIFFERENTIAL
NO_ALIAS = _casadi.NO_ALIAS
ALIAS = _casadi.ALIAS
NEGATED_ALIAS = _casadi.NEGATED_ALIAS
CAT_UNKNOWN = _casadi.CAT_UNKNOWN
CAT_DERIVATIVE = _casadi.CAT_DERIVATIVE
CAT_STATE = _casadi.CAT_STATE
CAT_DEPENDENT_CONSTANT = _casadi.CAT_DEPENDENT_CONSTANT
CAT_INDEPENDENT_CONSTANT = _casadi.CAT_INDEPENDENT_CONSTANT
CAT_DEPENDENT_PARAMETER = _casadi.CAT_DEPENDENT_PARAMETER
CAT_INDEPENDENT_PARAMETER = _casadi.CAT_INDEPENDENT_PARAMETER
CAT_ALGEBRAIC = _casadi.CAT_ALGEBRAIC
class Variable(PrintVariable):
    """Proxy of C++ casadi::Variable class"""
    __swig_setmethods__ = {}
    for _s in [PrintVariable]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Variable, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintVariable]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Variable, name)
    __repr__ = _swig_repr
    def name(self, *args):
        """name(Variable self) -> std::string"""
        return _casadi.Variable_name(self, *args)

    __swig_getmethods__["v"] = _casadi.Variable_v_get
    if _newclass:v = _swig_property(_casadi.Variable_v_get)
    __swig_getmethods__["d"] = _casadi.Variable_d_get
    if _newclass:d = _swig_property(_casadi.Variable_d_get)
    __swig_getmethods__["nominal"] = _casadi.Variable_nominal_get
    if _newclass:nominal = _swig_property(_casadi.Variable_nominal_get)
    __swig_getmethods__["start"] = _casadi.Variable_start_get
    if _newclass:start = _swig_property(_casadi.Variable_start_get)
    __swig_getmethods__["min"] = _casadi.Variable_min_get
    if _newclass:min = _swig_property(_casadi.Variable_min_get)
    __swig_getmethods__["max"] = _casadi.Variable_max_get
    if _newclass:max = _swig_property(_casadi.Variable_max_get)
    __swig_getmethods__["guess"] = _casadi.Variable_guess_get
    if _newclass:guess = _swig_property(_casadi.Variable_guess_get)
    __swig_getmethods__["derivative_start"] = _casadi.Variable_derivative_start_get
    if _newclass:derivative_start = _swig_property(_casadi.Variable_derivative_start_get)
    __swig_getmethods__["variability"] = _casadi.Variable_variability_get
    if _newclass:variability = _swig_property(_casadi.Variable_variability_get)
    __swig_getmethods__["causality"] = _casadi.Variable_causality_get
    if _newclass:causality = _swig_property(_casadi.Variable_causality_get)
    __swig_getmethods__["category"] = _casadi.Variable_category_get
    if _newclass:category = _swig_property(_casadi.Variable_category_get)
    __swig_getmethods__["alias"] = _casadi.Variable_alias_get
    if _newclass:alias = _swig_property(_casadi.Variable_alias_get)
    __swig_getmethods__["description"] = _casadi.Variable_description_get
    if _newclass:description = _swig_property(_casadi.Variable_description_get)
    __swig_getmethods__["valueReference"] = _casadi.Variable_valueReference_get
    if _newclass:valueReference = _swig_property(_casadi.Variable_valueReference_get)
    __swig_getmethods__["unit"] = _casadi.Variable_unit_get
    if _newclass:unit = _swig_property(_casadi.Variable_unit_get)
    __swig_getmethods__["display_unit"] = _casadi.Variable_display_unit_get
    if _newclass:display_unit = _swig_property(_casadi.Variable_display_unit_get)
    __swig_getmethods__["free"] = _casadi.Variable_free_get
    if _newclass:free = _swig_property(_casadi.Variable_free_get)
    def __init__(self, *args): 
        """
        __init__(casadi::Variable self) -> Variable
        __init__(casadi::Variable self, std::string const & name, Sparsity sp=casadi::Sparsity::scalar()) -> Variable
        __init__(casadi::Variable self, Variable other) -> Variable
        """
        this = _casadi.new_Variable(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_Variable
Variable_swigregister = _casadi.Variable_swigregister
Variable_swigregister(Variable)

class DaeBuilder(PrintDaeBuilder):
    """
    An initial-value problem in differential-algebraic equations.

    Independent variables:
    ======================





    ::

      t:      time
      



    Time-continuous variables:
    ==========================





    ::

      x:      states defined by ODE
      s:      implicitly defined states
      z:      algebraic variables
      u:      control signals
      q:      quadrature states
      y:      outputs
      



    Time-constant variables:
    ========================





    ::

      p:      free parameters
      d:      dependent parameters
      



    Dynamic constraints (imposed everywhere):
    =========================================





    ::

      ODE                    \\dot{x} ==  ode(t, x, s, z, u, p, d)
      DAE or implicit ODE:         0 ==  dae(t, x, s, z, u, p, d, sdot)
      algebraic equations:         0 ==  alg(t, x, s, z, u, p, d)
      quadrature equations:  \\dot{q} == quad(t, x, s, z, u, p, d)
      dependent parameters:        d == ddef(t, x, s, z, u, p, d)
      output equations:            y == ydef(t, x, s, z, u, p, d)
      



    Point constraints (imposed pointwise):
    ======================================





    ::

      Initial equations:           0 == init(t, x, s, z, u, p, d, sdot)
      



    Joel Andersson

    C++ includes: dae_builder.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [PrintDaeBuilder]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DaeBuilder, name, value)
    __swig_getmethods__ = {}
    for _s in [PrintDaeBuilder]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DaeBuilder, name)
    __repr__ = _swig_repr
    __swig_getmethods__["t"] = _casadi.DaeBuilder_t_get
    if _newclass:t = _swig_property(_casadi.DaeBuilder_t_get)
    __swig_getmethods__["x"] = _casadi.DaeBuilder_x_get
    if _newclass:x = _swig_property(_casadi.DaeBuilder_x_get)
    __swig_getmethods__["ode"] = _casadi.DaeBuilder_ode_get
    if _newclass:ode = _swig_property(_casadi.DaeBuilder_ode_get)
    __swig_getmethods__["lam_ode"] = _casadi.DaeBuilder_lam_ode_get
    if _newclass:lam_ode = _swig_property(_casadi.DaeBuilder_lam_ode_get)
    __swig_getmethods__["s"] = _casadi.DaeBuilder_s_get
    if _newclass:s = _swig_property(_casadi.DaeBuilder_s_get)
    __swig_getmethods__["sdot"] = _casadi.DaeBuilder_sdot_get
    if _newclass:sdot = _swig_property(_casadi.DaeBuilder_sdot_get)
    __swig_getmethods__["dae"] = _casadi.DaeBuilder_dae_get
    if _newclass:dae = _swig_property(_casadi.DaeBuilder_dae_get)
    __swig_getmethods__["lam_dae"] = _casadi.DaeBuilder_lam_dae_get
    if _newclass:lam_dae = _swig_property(_casadi.DaeBuilder_lam_dae_get)
    __swig_getmethods__["z"] = _casadi.DaeBuilder_z_get
    if _newclass:z = _swig_property(_casadi.DaeBuilder_z_get)
    __swig_getmethods__["alg"] = _casadi.DaeBuilder_alg_get
    if _newclass:alg = _swig_property(_casadi.DaeBuilder_alg_get)
    __swig_getmethods__["lam_alg"] = _casadi.DaeBuilder_lam_alg_get
    if _newclass:lam_alg = _swig_property(_casadi.DaeBuilder_lam_alg_get)
    __swig_getmethods__["q"] = _casadi.DaeBuilder_q_get
    if _newclass:q = _swig_property(_casadi.DaeBuilder_q_get)
    __swig_getmethods__["quad"] = _casadi.DaeBuilder_quad_get
    if _newclass:quad = _swig_property(_casadi.DaeBuilder_quad_get)
    __swig_getmethods__["lam_quad"] = _casadi.DaeBuilder_lam_quad_get
    if _newclass:lam_quad = _swig_property(_casadi.DaeBuilder_lam_quad_get)
    __swig_getmethods__["w"] = _casadi.DaeBuilder_w_get
    if _newclass:w = _swig_property(_casadi.DaeBuilder_w_get)
    __swig_getmethods__["wdef"] = _casadi.DaeBuilder_wdef_get
    if _newclass:wdef = _swig_property(_casadi.DaeBuilder_wdef_get)
    __swig_getmethods__["lam_wdef"] = _casadi.DaeBuilder_lam_wdef_get
    if _newclass:lam_wdef = _swig_property(_casadi.DaeBuilder_lam_wdef_get)
    __swig_getmethods__["y"] = _casadi.DaeBuilder_y_get
    if _newclass:y = _swig_property(_casadi.DaeBuilder_y_get)
    __swig_getmethods__["ydef"] = _casadi.DaeBuilder_ydef_get
    if _newclass:ydef = _swig_property(_casadi.DaeBuilder_ydef_get)
    __swig_getmethods__["lam_ydef"] = _casadi.DaeBuilder_lam_ydef_get
    if _newclass:lam_ydef = _swig_property(_casadi.DaeBuilder_lam_ydef_get)
    __swig_getmethods__["u"] = _casadi.DaeBuilder_u_get
    if _newclass:u = _swig_property(_casadi.DaeBuilder_u_get)
    __swig_getmethods__["p"] = _casadi.DaeBuilder_p_get
    if _newclass:p = _swig_property(_casadi.DaeBuilder_p_get)
    __swig_getmethods__["c"] = _casadi.DaeBuilder_c_get
    if _newclass:c = _swig_property(_casadi.DaeBuilder_c_get)
    __swig_getmethods__["cdef"] = _casadi.DaeBuilder_cdef_get
    if _newclass:cdef = _swig_property(_casadi.DaeBuilder_cdef_get)
    __swig_getmethods__["d"] = _casadi.DaeBuilder_d_get
    if _newclass:d = _swig_property(_casadi.DaeBuilder_d_get)
    __swig_getmethods__["ddef"] = _casadi.DaeBuilder_ddef_get
    if _newclass:ddef = _swig_property(_casadi.DaeBuilder_ddef_get)
    __swig_getmethods__["lam_ddef"] = _casadi.DaeBuilder_lam_ddef_get
    if _newclass:lam_ddef = _swig_property(_casadi.DaeBuilder_lam_ddef_get)
    __swig_getmethods__["init"] = _casadi.DaeBuilder_init_get
    if _newclass:init = _swig_property(_casadi.DaeBuilder_init_get)
    def add_p(self, *args):
        """
        add_p(DaeBuilder self, std::string const & name=std::string(), int n=1) -> MX

        Add a new parameter


        """
        return _casadi.DaeBuilder_add_p(self, *args)

    def add_u(self, *args):
        """
        add_u(DaeBuilder self, std::string const & name=std::string(), int n=1) -> MX

        Add a new control.


        """
        return _casadi.DaeBuilder_add_u(self, *args)

    def add_x(self, *args):
        """
        add_x(DaeBuilder self, std::string const & name=std::string(), int n=1) -> MX

        Add a new differential state.


        """
        return _casadi.DaeBuilder_add_x(self, *args)

    def add_s(self, *args):
        """
        add_s(DaeBuilder self, std::string const & name=std::string(), int n=1) -> std::pair< casadi::MX,casadi::MX >

        Add a implicit state.


        """
        return _casadi.DaeBuilder_add_s(self, *args)

    def add_z(self, *args):
        """
        add_z(DaeBuilder self, std::string const & name=std::string(), int n=1) -> MX

        Add a new algebraic variable.


        """
        return _casadi.DaeBuilder_add_z(self, *args)

    def add_q(self, *args):
        """
        add_q(DaeBuilder self, std::string const & name=std::string(), int n=1) -> MX

        Add a new quadrature state.


        """
        return _casadi.DaeBuilder_add_q(self, *args)

    def add_d(self, *args):
        """
        add_d(DaeBuilder self, MX new_ddef, std::string const & name=std::string()) -> MX

        Add a new dependent parameter.


        """
        return _casadi.DaeBuilder_add_d(self, *args)

    def add_y(self, *args):
        """
        add_y(DaeBuilder self, MX new_ydef, std::string const & name=std::string()) -> MX

        Add a new output.


        """
        return _casadi.DaeBuilder_add_y(self, *args)

    def add_ode(self, *args):
        """
        add_ode(DaeBuilder self, MX new_ode, std::string const & name=std::string())

        Add an ordinary differential equation.


        """
        return _casadi.DaeBuilder_add_ode(self, *args)

    def add_dae(self, *args):
        """
        add_dae(DaeBuilder self, MX new_dae, std::string const & name=std::string())

        Add a differential-algebraic equation.


        """
        return _casadi.DaeBuilder_add_dae(self, *args)

    def add_alg(self, *args):
        """
        add_alg(DaeBuilder self, MX new_alg, std::string const & name=std::string())

        Add an algebraic equation.


        """
        return _casadi.DaeBuilder_add_alg(self, *args)

    def add_quad(self, *args):
        """
        add_quad(DaeBuilder self, MX new_quad, std::string const & name=std::string())

        Add a quadrature equation.


        """
        return _casadi.DaeBuilder_add_quad(self, *args)

    def sanity_check(self, *args):
        """
        sanity_check(DaeBuilder self)

        Check if dimensions match.


        """
        return _casadi.DaeBuilder_sanity_check(self, *args)

    def split_dae(self, *args):
        """
        split_dae(DaeBuilder self)

        Identify and separate the algebraic variables and equations in the DAE.


        """
        return _casadi.DaeBuilder_split_dae(self, *args)

    def eliminate_alg(self, *args):
        """
        eliminate_alg(DaeBuilder self)

        Eliminate algebraic variables and equations transforming them into outputs.


        """
        return _casadi.DaeBuilder_eliminate_alg(self, *args)

    def make_semi_explicit(self, *args):
        """
        make_semi_explicit(DaeBuilder self)

        Transform the implicit DAE to a semi-explicit DAE.


        """
        return _casadi.DaeBuilder_make_semi_explicit(self, *args)

    def make_explicit(self, *args):
        """
        make_explicit(DaeBuilder self)

        Transform the implicit DAE or semi-explicit DAE into an explicit ODE.


        """
        return _casadi.DaeBuilder_make_explicit(self, *args)

    def sort_d(self, *args):
        """
        sort_d(DaeBuilder self)

        Sort dependent parameters.


        """
        return _casadi.DaeBuilder_sort_d(self, *args)

    def split_d(self, *args):
        """
        split_d(DaeBuilder self)

        Eliminate interdependencies amongst dependent parameters.


        """
        return _casadi.DaeBuilder_split_d(self, *args)

    def eliminate_d(self, *args):
        """
        eliminate_d(DaeBuilder self)

        Eliminate dependent parameters.


        """
        return _casadi.DaeBuilder_eliminate_d(self, *args)

    def eliminate_quad(self, *args):
        """
        eliminate_quad(DaeBuilder self)

        Eliminate quadrature states and turn them into ODE states.


        """
        return _casadi.DaeBuilder_eliminate_quad(self, *args)

    def sort_dae(self, *args):
        """
        sort_dae(DaeBuilder self)

        Sort the DAE and implicitly defined states.


        """
        return _casadi.DaeBuilder_sort_dae(self, *args)

    def sort_alg(self, *args):
        """
        sort_alg(DaeBuilder self)

        Sort the algebraic equations and algebraic states.


        """
        return _casadi.DaeBuilder_sort_alg(self, *args)

    def scale_variables(self, *args):
        """
        scale_variables(DaeBuilder self)

        Scale the variables.


        """
        return _casadi.DaeBuilder_scale_variables(self, *args)

    def scale_equations(self, *args):
        """
        scale_equations(DaeBuilder self)

        Scale the implicit equations.


        """
        return _casadi.DaeBuilder_scale_equations(self, *args)

    def parse_fmi(self, *args):
        """
        parse_fmi(DaeBuilder self, std::string const & filename)

        Import existing problem from FMI/XML


        """
        return _casadi.DaeBuilder_parse_fmi(self, *args)

    def add_lc(self, *args):
        """
        add_lc(DaeBuilder self, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & f_out) -> MX

        Add a named linear combination of output expressions.


        """
        return _casadi.DaeBuilder_add_lc(self, *args)

    def create(self, *args):
        """
        create(DaeBuilder self, std::string const & fname, std::vector< std::string,std::allocator< std::string > > const & s_in, 
            std::vector< std::string,std::allocator< std::string > > const & s_out) -> Function

        Construct a function object.


        """
        return _casadi.DaeBuilder_create(self, *args)

    def __call__(self, *args):
        """__call__(DaeBuilder self, std::string const & name) -> MX"""
        return _casadi.DaeBuilder___call__(self, *args)

    def der(self, *args):
        """
        der(DaeBuilder self, std::string const & name) -> MX
        der(DaeBuilder self, MX var) -> MX

        >  MX DaeBuilder.der(str name) const 
        ------------------------------------------------------------------------

        Get a derivative expression by name.

        >  MX DaeBuilder.der(MX var) const 
        ------------------------------------------------------------------------

        Get a derivative expression by non-differentiated expression.


        """
        return _casadi.DaeBuilder_der(self, *args)

    def nominal(self, *args):
        """
        nominal(DaeBuilder self, std::string const & name) -> double
        nominal(DaeBuilder self, MX var) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.nominal(str name) const 
        ------------------------------------------------------------------------

        Get the nominal value by name.

        >  [double] DaeBuilder.nominal(MX var) const 
        ------------------------------------------------------------------------

        Get the nominal value(s) by expression.


        """
        return _casadi.DaeBuilder_nominal(self, *args)

    def set_nominal(self, *args):
        """
        set_nominal(DaeBuilder self, std::string const & name, double val)
        set_nominal(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val)

        >  void DaeBuilder.set_nominal(str name, double val)
        ------------------------------------------------------------------------

        Set the nominal value by name.

        >  void DaeBuilder.set_nominal(MX var, [double ] val)
        ------------------------------------------------------------------------

        Set the nominal value(s) by expression.


        """
        return _casadi.DaeBuilder_set_nominal(self, *args)

    def min(self, *args):
        """
        min(DaeBuilder self, std::string const & name, bool normalized=False) -> double
        min(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.min(str name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the lower bound by name.

        >  [double] DaeBuilder.min(MX var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the lower bound(s) by expression.


        """
        return _casadi.DaeBuilder_min(self, *args)

    def set_min(self, *args):
        """
        set_min(DaeBuilder self, std::string const & name, double val, bool normalized=False)
        set_min(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)

        >  void DaeBuilder.set_min(str name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the lower bound by name.

        >  void DaeBuilder.set_min(MX var, [double ] val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the lower bound(s) by expression.


        """
        return _casadi.DaeBuilder_set_min(self, *args)

    def max(self, *args):
        """
        max(DaeBuilder self, std::string const & name, bool normalized=False) -> double
        max(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.max(str name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the upper bound by name.

        >  [double] DaeBuilder.max(MX var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the upper bound(s) by expression.


        """
        return _casadi.DaeBuilder_max(self, *args)

    def set_max(self, *args):
        """
        set_max(DaeBuilder self, std::string const & name, double val, bool normalized=False)
        set_max(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)

        >  void DaeBuilder.set_max(str name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the upper bound by name.

        >  void DaeBuilder.set_max(MX var, [double ] val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the upper bound(s) by expression.


        """
        return _casadi.DaeBuilder_set_max(self, *args)

    def guess(self, *args):
        """
        guess(DaeBuilder self, std::string const & name, bool normalized=False) -> double
        guess(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.guess(str name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the initial guess by name.

        >  [double] DaeBuilder.guess(MX var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the initial guess(es) by expression.


        """
        return _casadi.DaeBuilder_guess(self, *args)

    def set_guess(self, *args):
        """
        set_guess(DaeBuilder self, std::string const & name, double val, bool normalized=False)
        set_guess(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)

        >  void DaeBuilder.set_guess(str name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the initial guess by name.

        >  void DaeBuilder.set_guess(MX var, [double ] val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the initial guess(es) by expression.


        """
        return _casadi.DaeBuilder_set_guess(self, *args)

    def start(self, *args):
        """
        start(DaeBuilder self, std::string const & name, bool normalized=False) -> double
        start(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.start(str name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) value at time 0 by name.

        >  [double] DaeBuilder.start(MX var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) value(s) at time 0 by expression.


        """
        return _casadi.DaeBuilder_start(self, *args)

    def set_start(self, *args):
        """
        set_start(DaeBuilder self, std::string const & name, double val, bool normalized=False)
        set_start(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)

        >  void DaeBuilder.set_start(str name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) value at time 0 by name.

        >  void DaeBuilder.set_start(MX var, [double ] val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) value(s) at time 0 by expression.


        """
        return _casadi.DaeBuilder_set_start(self, *args)

    def derivative_start(self, *args):
        """
        derivative_start(DaeBuilder self, std::string const & name, bool normalized=False) -> double
        derivative_start(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >

        >  double DaeBuilder.derivative_start(str name, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) derivative value at time 0 by name.

        >  [double] DaeBuilder.derivative_start(MX var, bool normalized=false) const 
        ------------------------------------------------------------------------

        Get the (optionally normalized) derivative value(s) at time 0 by expression.


        """
        return _casadi.DaeBuilder_derivative_start(self, *args)

    def set_derivative_start(self, *args):
        """
        set_derivative_start(DaeBuilder self, std::string const & name, double val, bool normalized=False)
        set_derivative_start(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)

        >  void DaeBuilder.set_derivative_start(str name, double val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) derivative value at time 0 by name.

        >  void DaeBuilder.set_derivative_start(MX var, [double ] val, bool normalized=false)
        ------------------------------------------------------------------------

        Set the (optionally normalized) derivative value(s) at time 0 by expression.


        """
        return _casadi.DaeBuilder_set_derivative_start(self, *args)

    def unit(self, *args):
        """
        unit(DaeBuilder self, std::string const & name) -> std::string
        unit(DaeBuilder self, MX var) -> std::string

        >  str DaeBuilder.unit(str name) const 
        ------------------------------------------------------------------------

        Get the unit for a component.

        >  str DaeBuilder.unit(MX var) const 
        ------------------------------------------------------------------------

        Get the unit given a vector of symbolic variables (all units must be
        identical)


        """
        return _casadi.DaeBuilder_unit(self, *args)

    def set_unit(self, *args):
        """
        set_unit(DaeBuilder self, std::string const & name, std::string const & val)

        Set the unit for a component.


        """
        return _casadi.DaeBuilder_set_unit(self, *args)

    def add_variable(self, *args):
        """
        add_variable(DaeBuilder self, std::string const & name, Variable var)
        add_variable(DaeBuilder self, std::string const & name, int n=1) -> MX
        add_variable(DaeBuilder self, std::string const & name, Sparsity sp) -> MX

        >  void DaeBuilder.add_variable(str name, Variable var)
        ------------------------------------------------------------------------

        Add a variable.

        >  MX DaeBuilder.add_variable(str name, int n=1)

        >  MX DaeBuilder.add_variable(str name, Sparsity sp)
        ------------------------------------------------------------------------

        Add a new variable: returns corresponding symbolic expression.


        """
        return _casadi.DaeBuilder_add_variable(self, *args)

    def variable(self, *args):
        """
        variable(DaeBuilder self, std::string const & name) -> Variable
        variable(DaeBuilder self, std::string const & name) -> Variable

        Access a variable by name


        """
        return _casadi.DaeBuilder_variable(self, *args)

    def __init__(self, *args): 
        """
        __init__(casadi::DaeBuilder self) -> DaeBuilder
        __init__(casadi::DaeBuilder self, DaeBuilder other) -> DaeBuilder

        Default constructor.


        """
        this = _casadi.new_DaeBuilder(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _casadi.delete_DaeBuilder
DaeBuilder_swigregister = _casadi.DaeBuilder_swigregister
DaeBuilder_swigregister(DaeBuilder)

class XmlFile(SharedObject):
    """
    XML parser Can be used for parsing XML files into CasADi data structures.

    Joel Andersson

    C++ includes: xml_file.hpp 
    """
    __swig_setmethods__ = {}
    for _s in [SharedObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, XmlFile, name, value)
    __swig_getmethods__ = {}
    for _s in [SharedObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, XmlFile, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _casadi.delete_XmlFile
    def loadPlugin(*args):
        """loadPlugin(std::string const & name)"""
        return _casadi.XmlFile_loadPlugin(*args)

    if _newclass:loadPlugin = staticmethod(loadPlugin)
    __swig_getmethods__["loadPlugin"] = lambda x: loadPlugin
    def doc(*args):
        """doc(std::string const & name) -> std::string"""
        return _casadi.XmlFile_doc(*args)

    if _newclass:doc = staticmethod(doc)
    __swig_getmethods__["doc"] = lambda x: doc
    def __init__(self, *args): 
        """
        __init__(casadi::XmlFile self) -> XmlFile
        __init__(casadi::XmlFile self, std::string const & name) -> XmlFile
        __init__(casadi::XmlFile self, XmlFile other) -> XmlFile
        """
        this = _casadi.new_XmlFile(*args)
        try: self.this.append(this)
        except: self.this = this
XmlFile_swigregister = _casadi.XmlFile_swigregister
XmlFile_swigregister(XmlFile)

def XmlFile_loadPlugin(*args):
  """XmlFile_loadPlugin(std::string const & name)"""
  return _casadi.XmlFile_loadPlugin(*args)

def XmlFile_doc(*args):
  """XmlFile_doc(std::string const & name) -> std::string"""
  return _casadi.XmlFile_doc(*args)

def swig_typename_convertor_cpp2python(s):
  import re
  s = s.replace("C/C++ prototypes","Python usages")
  s = s.replace("casadi::","")
  s = s.replace("MXDict","str:MX")
  s = s.replace("SXDict","str:SX")
  s = s.replace("std::string","str")
  s = s.replace(" const &","")
  s = s.replace("casadi_","")
  s = re.sub(r"\b((\w+)(< \w+ >)?)::\2\b",r"\1",s)
  s = re.sub("(const )?Matrix< ?SXElem *>( &)?",r"SX",s)
  s = re.sub("(const )?GenericMatrix< ?(\w+) *>( ?&)?",r"\2 ",s)
  s = re.sub("(const )?Matrix< ?int *>( ?&)?",r"IM ",s)
  s = re.sub("(const )?Matrix< ?double *>( ?&)?",r"DM ",s)
  s = re.sub("(const )?Matrix< ?(\w+) *>( ?&)?",r"array(\2) ",s)
  s = re.sub("(const )?GenericMatrix< ?([\w\(\)]+) *>( ?&)?",r"\2 ",s)
  s = re.sub(r"const (\w+) &",r"\1 ",s)
  s = re.sub(r"< [\w\(\)]+ +>\(",r"(",s)
  for i in range(5):
    s = re.sub(r"(const )? ?std::pair< ?([\w\(\)\]\[: ]+?) ?, ?([\w\(\)\]\[: ]+?) ?> ?&?",r"(\2,\3) ",s)
    s = re.sub(r"(const )? ?std::vector< ?([\w\(\)\[\] ]+) ?(, ?std::allocator< ?\2 ?>)? ?> ?&?",r"[\2] ",s)
  s = re.sub(r"\b(\w+)(< \w+ >)?::\1",r"\1",s)
  s = s.replace("casadi::","")
  s = s.replace("::",".")
  s = s.replace(".operator ()","")
  s = re.sub(r"([A-Z]\w+)Vector",r"[\1]",s)
  return s

def swig_typename_convertor_python2cpp(a):
  try:
    import numpy as np
  except:
    class NoExist:
      pass
    class Temp(object):
      ndarray = NoExist
    np = Temp()
  if isinstance(a,list):
    if len(a)>0:
      return "[%s]" % "|".join(set([swig_typename_convertor_python2cpp(i) for i in a]))
    else:
      return "[]"
  elif isinstance(a,tuple):
    return "(%s)" % ",".join([swig_typename_convertor_python2cpp(i) for i in a])
  elif isinstance(a,np.ndarray):
    return "np.array(%s)" % ",".join(set([swig_typename_convertor_python2cpp(i) for i in np.array(a).flatten().tolist()]))
  elif isinstance(a,dict):
    return "|".join(set([swig_typename_convertor_python2cpp(i) for i in a.keys()])) +":"+ "|".join(set([swig_typename_convertor_python2cpp(i) for i in a.values()]))

  return type(a).__name__


def swig_monkeypatch(v,cl=True):
  import re
  if hasattr(v,"__monkeypatched__"):
    return v
  def foo(*args,**kwargs):
    try:
      return v(*args,**kwargs)
    except NotImplementedError as e:
      import sys
      exc_info = sys.exc_info()
      if e.message.startswith("Wrong number or type of arguments for overloaded function"):

        s = e.args[0]
        s = s.replace("'new_","'")
        #s = re.sub(r"overloaded function '(\w+?)_(\w+)'",r"overloaded function '\1.\2'",s)
        m = re.search("overloaded function '([\w\.]+)'",s)
        if m:
          name = m.group(1)
          name = name.replace(".__call__","")
        else:
          name = "method"
        ne = NotImplementedError(swig_typename_convertor_cpp2python(s)+"You have: %s(%s)\n" % (name,", ".join(map(swig_typename_convertor_python2cpp,args[1:] if cl else args)+ ["%s=%s" % (k,swig_typename_convertor_python2cpp(vv)) for k,vv in kwargs.items()])))
        raise ne.__class__, ne, exc_info[2].tb_next
      else:
        raise exc_info[1], None, exc_info[2].tb_next
    except TypeError as e:
      import sys
      exc_info = sys.exc_info()

      methodname = "method"
      try:
        methodname = exc_info[2].tb_next.tb_frame.f_code.co_name
      except:
        pass

      if e.message.startswith("in method '"):
        s = e.args[0]
        s = re.sub(r"method '(\w+?)_(\w+)'",r"method '\1.\2'",s)
        m = re.search("method '([\w\.]+)'",s)
        if m:
          name = m.group(1)
          name = name.replace(".__call__","")
        else:
          name = "method"
        ne = TypeError(swig_typename_convertor_cpp2python(s)+" expected.\nYou have: %s(%s)\n" % (name,", ".join(map(swig_typename_convertor_python2cpp,args[1:] if cl else args))))
        raise ne.__class__, ne, exc_info[2].tb_next
      elif e.message.startswith("Expecting one of"):
        s = e.args[0]
        conversion = {"mul": "*", "div": "/", "add": "+", "sub": "-","le":"<=","ge":">=","lt":"<","gt":">","eq":"==","pow":"**"}
        if methodname.startswith("__") and methodname[2:-2] in conversion:
          ne = TypeError(swig_typename_convertor_cpp2python(s)+"\nYou try to do: %s %s %s.\n" % (  swig_typename_convertor_python2cpp(args[0]),conversion[methodname[2:-2]] ,swig_typename_convertor_python2cpp(args[1]) ))
        elif methodname.startswith("__r") and methodname[3:-2] in conversion:
          ne = TypeError(swig_typename_convertor_cpp2python(s)+"\nYou try to do: %s %s %s.\n" % ( swig_typename_convertor_python2cpp(args[1]),  conversion[methodname[3:-2]], swig_typename_convertor_python2cpp(args[0]) ))
        else:
          ne = TypeError(swig_typename_convertor_cpp2python(s)+"\nYou have: (%s)\n" % (", ".join(map(swig_typename_convertor_python2cpp,args[1:] if cl else args))))
        raise ne.__class__, ne, exc_info[2].tb_next
      else:
        s = e.args[0]
        ne = TypeError(s+"\nYou have: (%s)\n" % (", ".join(map(swig_typename_convertor_python2cpp,args[1:] if cl else args) + ["%s=%s" % (k,swig_typename_convertor_python2cpp(vv)) for k,vv in kwargs.items()]  )))
        raise ne.__class__, ne, exc_info[2].tb_next
    except AttributeError as e:
      import sys
      exc_info = sys.exc_info()
      if e.message=="type object 'object' has no attribute '__getattr__'":
        # swig 3.0 bug
        ne = AttributeError("Unkown attribute: %s has no attribute '%s'." % (str(args[1]),args[2]))
        raise ne.__class__, ne, exc_info[2].tb_next
      else:
        raise exc_info[1], None, exc_info[2].tb_next
    except Exception as e:
      import sys
      exc_info = sys.exc_info()
      raise exc_info[1], None, exc_info[2].tb_next

  if v.__doc__ is not None:
    foo.__doc__ = swig_typename_convertor_cpp2python(v.__doc__)
  foo.__name__ = v.__name__
  foo.__monkeypatched__ = True
  return foo

import inspect

for name,cl in locals().items():
  if not inspect.isclass(cl): continue
  for k,v in inspect.getmembers(cl, inspect.ismethod):
    if k == "__del__" or v.__name__ == "<lambda>": continue
    vv = v
    setattr(cl,k,swig_monkeypatch(vv))
  for k,v in inspect.getmembers(cl, inspect.isfunction):
    setattr(cl,k,staticmethod(swig_monkeypatch(v,cl=False)))


for name,v in locals().items():
  if not inspect.isfunction(v): continue
  if name.startswith("swig") : continue
  p = swig_monkeypatch(v,cl=False)
  #setattr(casadi,name,p)
  import sys
  setattr(sys.modules[__name__], name, p)



# This file is compatible with both classic and new-style classes.


